diff -urN -x .svn espgs-8.15rc2/addons/addons.mak trunk/addons/addons.mak
--- espgs-8.15rc2/addons/addons.mak	2005-02-17 03:02:30.000000000 +0100
+++ trunk/addons/addons.mak	2005-03-14 00:04:03.655395809 +0100
@@ -52,6 +52,9 @@
 #       cdj970   HP DeskJet 970
 #	chp2200  HP Business Inkjet 2200
 #       dl2100   DEC DL2100
+#	dmprt	 dot matrix printer driver for Ghostscript (it can use 
+#		 dviprt printer config files, japanese)
+#	escpage  Epson ESC/Page driver for Ghostscript (japanese)
 #	fmpr	 Fujitsu FMPR (japanese)
 #	fmlbp	 Fujitsu FMLBP2xx Page Printer (japanese)
 #	gdi	 Samsung's old driver for their SmartGDI laser printers:
@@ -110,6 +113,7 @@
 #	mj6000c	 Epson Stylus Color 400, 800, 1520 (japanese)
 #	mj8000c	 Epson Stylus Color 3000 (japanese)
 #	ml600	 Okidata Microline 600CL/620CL (japanese)
+#	npdl     NEC MultiWriter, PC-PR1000/2000 (japanese)
 #       oki4w    Okidata OkiPage 4w+
 #	opvp	 Gluecode for Vector Driver API
 #	pcl3     PCL-3(+) printers: Many, especially older HP inkjets,
@@ -118,6 +122,7 @@
 #	pr1000_4 NEC PC-PR 1000/4 (japanese)
 #	pr150	 NEC PC-PR 150 (japanese)
 #	pr201	 NEC PC-PR 201 (japanese)
+#	rpdl     Ricoh RPDL I/II/III/IV drver for Ghostscript (japanese)
 #	samsunggdi Samsung's old driver for their SmartGDI laser printers:
 #		 ML-4500, ML-2xx, ML-1xxx, ML-5080, ML-6040, ... and
 #		 Lexmark E210, same as "gdi"
@@ -307,6 +312,180 @@
 	$(GLCC) $(GLO_)gdevln03.$(OBJ) $(C_) $(ADSRC)gdevln03.c
 
 
+### -------------------------- EPSON Page/Color -------------------------- ###
+###                                                                        ###
+###                                                                        ###
+
+ESCV_DIR=$(ADSRC)eplaser
+ESCV_SRC=$(ESCV_DIR)$(D)
+escv_opts=-DGS_VERSION_MAJOR=$(GS_VERSION_MAJOR)
+
+escv_=$(GLOBJ)gdevescv.$(OBJ)
+
+$(GLOBJ)gdevescv.$(OBJ): $(ESCV_SRC)gdevescv.c $(ESCV_SRC)gdevescv.h $(PDEVH)
+	$(GLCC) -DA4 $(GLO_)gdevescv.$(OBJ) $(C_) $(escv_opts) $(ESCV_SRC)gdevescv.c
+
+
+$(DD)alc1900.dev: $(escv_) $(DD)page.dev
+	$(SETPDEV) $(DD)alc1900 $(escv_)
+
+$(DD)alc2000.dev: $(escv_) $(DD)page.dev
+	$(SETPDEV) $(DD)alc2000 $(escv_)
+
+$(DD)alc4000.dev: $(escv_) $(DD)page.dev
+	$(SETPDEV) $(DD)alc4000 $(escv_)
+
+$(DD)alc4100.dev: $(escv_) $(DD)page.dev
+	$(SETPDEV) $(DD)alc4100 $(escv_)
+
+$(DD)alc8500.dev: $(escv_) $(DD)page.dev
+	$(SETPDEV) $(DD)alc8500 $(escv_)
+
+$(DD)alc8600.dev: $(escv_) $(DD)page.dev
+	$(SETPDEV) $(DD)alc8600 $(escv_)
+
+$(DD)alc9100.dev: $(escv_) $(DD)page.dev
+	$(SETPDEV) $(DD)alc9100 $(escv_)
+
+$(DD)lp3000c.dev: $(escv_) $(DD)page.dev
+	$(SETPDEV) $(DD)lp3000c $(escv_)
+
+$(DD)lp8000c.dev: $(escv_) $(DD)page.dev
+	$(SETPDEV) $(DD)lp8000c $(escv_)
+
+$(DD)lp8200c.dev: $(escv_) $(DD)page.dev
+	$(SETPDEV) $(DD)lp8200c $(escv_)
+
+$(DD)lp8300c.dev: $(escv_) $(DD)page.dev
+	$(SETPDEV) $(DD)lp8300c $(escv_)
+
+$(DD)lp8500c.dev: $(escv_) $(DD)page.dev
+	$(SETPDEV) $(DD)lp8500c $(escv_)
+
+$(DD)lp8800c.dev: $(escv_) $(DD)page.dev
+	$(SETPDEV) $(DD)lp8800c $(escv_)
+
+$(DD)lp9000c.dev: $(escv_) $(DD)page.dev
+	$(SETPDEV) $(DD)lp9000c $(escv_)
+
+$(DD)lp9200c.dev: $(escv_) $(DD)page.dev
+	$(SETPDEV) $(DD)lp9200c $(escv_)
+
+$(DD)lp9500c.dev: $(escv_) $(DD)page.dev
+	$(SETPDEV) $(DD)lp9500c $(escv_)
+
+$(DD)lp9800c.dev: $(escv_) $(DD)page.dev
+	$(SETPDEV) $(DD)lp9800c $(escv_)
+
+### -------------------------- EPSON ESC/Page ----------------------------- ###
+###                                                                         ###
+###                                                                         ###
+
+ESMV_DIR=$(ADSRC)eplaser
+ESMV_SRC=$(ESMV_DIR)$(D)
+esmv_opts=-DGS_VERSION_MAJOR=$(GS_VERSION_MAJOR)
+
+esmv_=$(GLOBJ)gdevesmv.$(OBJ)
+
+$(GLOBJ)gdevesmv.$(OBJ): $(ESMV_SRC)gdevesmv.c $(ESMV_SRC)gdevescv.h $(PDEVH)
+	$(GLCC) -DA4 $(GLO_)gdevesmv.$(OBJ) $(C_) $(esmv_opts) $(ESMV_SRC)gdevesmv.c
+
+
+$(DD)epl2050.dev: $(esmv_) $(DD)page.dev
+	$(SETPDEV) $(DD)epl2050 $(esmv_)
+
+$(DD)epl2050p.dev: $(esmv_) $(DD)page.dev
+	$(SETPDEV) $(DD)epl2050p $(esmv_)
+
+$(DD)epl2120.dev: $(esmv_) $(DD)page.dev
+	$(SETPDEV) $(DD)epl2120 $(esmv_)
+
+$(DD)epl2500.dev: $(esmv_) $(DD)page.dev
+	$(SETPDEV) $(DD)epl2500 $(esmv_)
+
+$(DD)epl2750.dev: $(esmv_) $(DD)page.dev
+	$(SETPDEV) $(DD)epl2750 $(esmv_)
+
+$(DD)epl5800.dev: $(esmv_) $(DD)page.dev
+	$(SETPDEV) $(DD)epl5800 $(esmv_)
+
+$(DD)epl5900.dev: $(esmv_) $(DD)page.dev
+	$(SETPDEV) $(DD)epl5900 $(esmv_)
+
+$(DD)epl6100.dev: $(esmv_) $(DD)page.dev
+	$(SETPDEV) $(DD)epl6100 $(esmv_)
+
+$(DD)epl6200.dev: $(esmv_) $(DD)page.dev
+	$(SETPDEV) $(DD)epl6200 $(esmv_)
+
+$(DD)lp1800.dev: $(esmv_) $(DD)page.dev
+	$(SETPDEV) $(DD)lp1800 $(esmv_)
+
+$(DD)lp1900.dev: $(esmv_) $(DD)page.dev
+	$(SETPDEV) $(DD)lp1900 $(esmv_)
+
+$(DD)lp2200.dev: $(esmv_) $(DD)page.dev
+	$(SETPDEV) $(DD)lp2200 $(esmv_)
+
+$(DD)lp2400.dev: $(esmv_) $(DD)page.dev
+	$(SETPDEV) $(DD)lp2400 $(esmv_)
+
+$(DD)lp2500.dev: $(esmv_) $(DD)page.dev
+	$(SETPDEV) $(DD)lp2500 $(esmv_)
+
+$(DD)lp7500.dev: $(esmv_) $(DD)page.dev
+	$(SETPDEV) $(DD)lp7500 $(esmv_)
+
+$(DD)lp7700.dev: $(esmv_) $(DD)page.dev
+	$(SETPDEV) $(DD)lp7700 $(esmv_)
+
+$(DD)lp7900.dev: $(esmv_) $(DD)page.dev
+	$(SETPDEV) $(DD)lp7900 $(esmv_)
+
+$(DD)lp8100.dev: $(esmv_) $(DD)page.dev
+	$(SETPDEV) $(DD)lp8100 $(esmv_)
+
+$(DD)lp8300f.dev: $(esmv_) $(DD)page.dev
+	$(SETPDEV) $(DD)lp8300f $(esmv_)
+
+$(DD)lp8400f.dev: $(esmv_) $(DD)page.dev
+	$(SETPDEV) $(DD)lp8400f $(esmv_)
+
+$(DD)lp8600.dev: $(esmv_) $(DD)page.dev
+	$(SETPDEV) $(DD)lp8600 $(esmv_)
+
+$(DD)lp8600f.dev: $(esmv_) $(DD)page.dev
+	$(SETPDEV) $(DD)lp8600f $(esmv_)
+
+$(DD)lp8700.dev: $(esmv_) $(DD)page.dev
+	$(SETPDEV) $(DD)lp8700 $(esmv_)
+
+$(DD)lp8900.dev: $(esmv_) $(DD)page.dev
+	$(SETPDEV) $(DD)lp8900 $(esmv_)
+
+$(DD)lp9000b.dev: $(esmv_) $(DD)page.dev
+	$(SETPDEV) $(DD)lp9000b $(esmv_)
+
+$(DD)lp9100.dev: $(esmv_) $(DD)page.dev
+	$(SETPDEV) $(DD)lp9100 $(esmv_)
+
+$(DD)lp9200b.dev: $(esmv_) $(DD)page.dev
+	$(SETPDEV) $(DD)lp9200b $(esmv_)
+
+$(DD)lp9300.dev: $(esmv_) $(DD)page.dev
+	$(SETPDEV) $(DD)lp9300 $(esmv_)
+
+$(DD)lp9400.dev: $(esmv_) $(DD)page.dev
+	$(SETPDEV) $(DD)lp9400 $(esmv_)
+
+$(DD)lp9600.dev: $(esmv_) $(DD)page.dev
+	$(SETPDEV) $(DD)lp9600 $(esmv_)
+
+$(DD)lp9600s.dev: $(esmv_) $(DD)page.dev
+	$(SETPDEV) $(DD)lp9600s $(esmv_)
+
+
+
 # ------ The Lexmark 5700 and 7000 devices ------ #
 
 lex7000_=$(GLOBJ)gdevlx7.$(OBJ)
@@ -368,7 +547,7 @@
 ###                                                                      ###
 LIPS_DIR=$(ADSRC)lips4
 LIPS_SRC=$(LIPS_DIR)$(D)
-LIPS_OPT=-DGS_VERSION_MAJOR=$(GS_VERSION_MAJOR)
+LIPS_OPT=-DGS_VERSION_MAJOR=$(GS_VERSION_MAJOR) $(I_) $(LIPS_SRC)
 
 $(GLOBJ)gdevlprn.$(OBJ): $(LIPS_SRC)gdevlprn.c $(LIPS_SRC)gdevlprn.h\
  $(gdevprn_h) $(PDEVH)
@@ -776,6 +955,26 @@
 $(DD)mag256.dev: $(maguro_)
 	$(SETDEV) $(DD)mag256 $(maguro_)
 
+### ---------------- Dot matrix printer device ---------------- ###
+dmprt_=$(GLOBJ)gdevdmpr.$(OBJ) $(GLOBJ)dviprlib.$(OBJ) $(GLOBJ)gdevprn.$(OBJ)
+
+$(DD)dmprt.dev: $(dmprt_) $(DD)page.dev
+	$(SETDEV) $(DD)dmprt $(dmprt_)
+	$(ADDMOD) $(DD)dmprt -ps dmp_init
+
+$(GLOBJ)gdevdmpr.$(OBJ): $(JAPSRC)gdevdmpr.c $(JAPSRC)dviprlib.h $(PDEVH)
+	$(GLCC) $(O_)$@ $(C_) $(JAPSRC)gdevdmpr.c
+
+$(GLOBJ)dviprlib.$(OBJ): $(JAPSRC)dviprlib.c $(JAPSRC)dviprlib.h
+	$(GLCC) $(O_)$@ $(C_) $(JAPSRC)dviprlib.c
+
+extra-dmprt-install:
+	$(INSTALL_DATA) $(JAPSRC)dmp_init.ps $(gsdatadir)$(D)lib || exit 1
+	$(INSTALL_DATA) $(JAPSRC)dmp_site.ps $(gsdatadir)$(D)lib || exit 1
+	$(INSTALL_DATA) $(JAPSRC)escp_24.src $(gsdatadir)$(D)lib || exit 1
+
+
+
 ##
 ## EPSON MachJet driver 
 ##
@@ -846,6 +1045,49 @@
 $(GLOBJ)gdevlbp3.$(OBJ): $(JAPSRC)gdevlbp3.c $(PDEVH)
 	$(GLCC) $(O_)$@ $(C_) $(JAPSRC)gdevlbp3.c
 
+### --- The NEC NPDL language printer device ------ ###
+
+npdl_=$(GLOBJ)gdevnpdl.$(OBJ) $(GLOBJ)gdevlprn.$(OBJ)
+
+$(GLOBJ)gdevnpdl.$(OBJ): $(JAPSRC)gdevnpdl.c $(LIPS_SRC)gdevlprn.h $(PDEVH)
+	$(GLCC) -DA4 $(GLO_)gdevnpdl.$(OBJ) $(LIPS_OPT) $(C_) $(JAPSRC)gdevnpdl.c
+
+$(DD)npdl.dev: $(npdl_) $(DD)page.dev
+	$(SETPDEV) $(DD)npdl $(npdl_)
+
+### ------- EPSON ESC/Page printer device ----------------- ###
+
+escpage_=$(GLOBJ)gdevespg.$(OBJ) $(GLOBJ)gdevlprn.$(OBJ) $(GLOBJ)gdevlips.$(OBJ)
+
+$(GLOBJ)gdevespg.$(OBJ): $(JAPSRC)gdevespg.c $(LIPS_SRC)gdevlprn.h $(PDEVH)
+	$(GLCC) -DA4 $(GLO_)gdevespg.$(OBJ) $(LIPS_OPT) $(C_) $(JAPSRC)gdevespg.c
+
+$(DD)escpage.dev: $(escpage_) $(DD)page.dev
+	$(SETPDEV) $(DD)escpage $(escpage_)
+
+$(DD)lp2000.dev: $(escpage_) $(DD)page.dev
+	$(SETPDEV) $(DD)lp2000 $(escpage_)
+
+### --- The RICOH RPDL language printer device ------ ###
+
+rpdl_=$(GLOBJ)gdevrpdl.$(OBJ) $(GLOBJ)gdevlprn.$(OBJ)
+$(GLOBJ)gdevrpdl.$(OBJ): $(JAPSRC)gdevrpdl.c $(LIPS_SRC)gdevlprn.h $(PDEVH)
+	$(GLCC) $(GLO_)gdevrpdl.$(OBJ) $(LIPS_OPT) $(C_) $(JAPSRC)gdevrpdl.c
+
+$(DD)rpdl.dev: $(rpdl_) $(DD)page.dev
+	$(SETPDEV) $(DD)rpdl $(rpdl_)
+
+### ---------- RICOH RPDL IV(600dpi) printer devices ---------- ###
+#rpdl_=$(GLOBJ)gdevrpdl.$(OBJ)
+#$(GLOBJ)gdevrpdl.$(OBJ) : $(JAPSRC)gdevrpdl.c
+#	$(GLCC) $(GLO_)gdevrpdl.$(OBJ) $(C_) $(JAPSRC)gdevrpdl.c
+#
+#$(DD)nx100f.dev: $(rpdl_) $(DD)page.dev
+#	$(SETPDEV2) $(DD)nx100f $(rpdl_)
+#
+#$(DD)nx100v.dev: $(rpdl_) $(DD)page.dev
+#	$(SETPDEV2) $(DD)nx100v $(rpdl_)
+
 ### ------------ The ALPS Micro Dry printer devices ------------ ###
 
 alps_=$(GLOBJ)gdevalps.$(OBJ)
@@ -874,4 +1116,4 @@
 
 ### ------------ Build/Install special features ------------ ###
 
-install-addons-extras: extra-upp-install
+install-addons-extras: extra-dmprt-install extra-upp-install
diff -urN -x .svn espgs-8.15rc2/addons/eplaser/gdevescv.c trunk/addons/eplaser/gdevescv.c
--- espgs-8.15rc2/addons/eplaser/gdevescv.c	1970-01-01 01:00:00.000000000 +0100
+++ trunk/addons/eplaser/gdevescv.c	2005-03-14 00:03:53.458725483 +0100
@@ -0,0 +1,2483 @@
+/* Copyright (C) EPSON SOFTWARE DEVELOPMENT LABORATORY, INC. 1999,2000.
+   Copyright (C) SEIKO EPSON CORPORATION 2000-2005.
+
+   Ghostscript printer driver for EPSON ESC/Page-Color
+
+   This software is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility
+   to anyone for the consequences of using it or for whether it serves any
+   particular purpose or works at all, unless he says so in writing.  Refer
+   to the GNU General Public License for full details.
+
+   Everyone is granted permission to copy, modify and redistribute
+   this software, but only under the conditions described in the GNU
+   General Public License.  A copy of this license is supposed to have been
+   given to you along with this software so you can know your rights and
+   responsibilities.  It should be in a file named COPYING.  Among other
+   things, the copyright notice and this notice must be preserved on all
+   copies.
+ */
+
+/* Vector Version of ESC/Page-Color driver */
+
+/*
+　謝辞
+    本ドライバの作成にあたり、gdevlips(作者 大森紀人さん)を参考にさせて
+    頂きました。
+*/
+/*
+   ○Ghostscript 5.10/5.50 のバグについて
+
+   Ghostscript 5.10/5.50 の Vector driver の setlinewidth 関数には
+   バグがあります。本来スケールが変更されるにしたがって線の太さも変更され
+   なければなりませんが、Ghostscript 5.10/5.50 ではスケールを考慮するのを
+   忘れています。
+   このドライバはそのバグを回避するためにスケールを自分で処理しています。
+
+ */
+
+#if ( 6 > GS_VERSION_MAJOR )
+
+#include <string.h>
+
+#include "math_.h"
+#include "gx.h"
+#include "gserrors.h"
+#include "gsmatrix.h"
+#include "gsparam.h"
+#include "gxdevice.h"
+#include "gscspace.h"
+#include "gsutil.h"
+#include "gdevvec.h"
+#include "gdevpstr.h"
+#include "ghost.h"
+#include "gzstate.h"
+#include "imemory.h"
+#include "igstate.h"
+#include "gdevescv.h"
+#include "gspath.h"
+#include "gzpath.h"
+
+#else /* 6 <= GS_VERSION_MAJOR */
+
+#include <stdlib.h>		/* for abs() */
+#include "math_.h"
+#include "memory_.h"
+#include "gx.h"
+#include "gserrors.h"
+#include "gzpath.h"
+#include "gxdevice.h"
+#include "gdevvec.h"
+#include "gdevescv.h"
+
+#if ( 7 >= GS_VERSION_MAJOR )
+#include "gscspace.h"
+#endif
+
+#endif /* GS_VERSION_MAJOR */
+
+/* ---------------- Device definition ---------------- */
+
+/* Device procedures */
+private dev_proc_open_device(escv_open);
+private dev_proc_output_page(escv_output_page);
+private dev_proc_close_device(escv_close);
+private dev_proc_copy_mono(escv_copy_mono);
+private dev_proc_copy_color(escv_copy_color);
+private dev_proc_put_params(escv_put_params);
+private dev_proc_get_params(escv_get_params);
+private dev_proc_fill_mask(escv_fill_mask);
+private dev_proc_begin_image(escv_begin_image);
+
+
+#define	X_DPI		600
+#define	Y_DPI		600
+#define	VCACHE		0x3FF
+
+typedef struct gx_device_escv_s {
+    gx_device_vector_common;
+
+    bool		manualFeed;			/* Use manual feed */ 
+    int			cassetFeed;			/* Input Casset */ 
+    bool		RITOff;				/* RIT Control */
+    bool		Collate;			/* 印刷部数 */
+    int			toner_density;			/* トナー濃度 */
+    bool		toner_saving;			/* トナーセーブ */
+    int			prev_paper_size;
+    int			prev_paper_width;
+    int			prev_paper_height;
+    int			prev_num_copies;		/* */
+    int			prev_feed_mode;
+    int			orientation;			/* 方向 */
+    bool		faceup;				/* フェイス指定 */
+    int	                MediaType;			/* 紙種 */
+
+    bool		first_page;
+    bool		Duplex;				/* 両面印刷 */
+    bool		Tumble;				/* とじ方向 */
+    int			ncomp;				/* */
+    int			MaskReverse;			/* 反転処理 */
+    int			MaskState;			/* */
+    bool		c4map;				/* 4bit ColorMap */
+    bool		c8map;				/* 8bit ColorMap */
+    int			prev_x;
+    int			prev_y;
+    gx_color_index	prev_color;
+    gx_color_index	current_color;			/* Current Color */
+
+    /* for Font Downloading */
+    gx_bitmap_id	id_cache[VCACHE + 1];
+
+    floatp		lwidth;
+    long		cap;
+    long		join;
+    long		reverse_x;
+    long		reverse_y;
+    gs_matrix		xmat;
+    int			bx, by;
+    int			w, h;
+    int			roll;
+    float		sx, sy;
+    long		dd;
+} gx_device_escv;
+
+
+gs_public_st_suffix_add0_final(st_device_escv, gx_device_escv,
+      "gx_device_escv", device_escv_enum_ptrs, device_escv_reloc_ptrs,
+			       gx_device_finalize, st_device_vector);
+
+/*
+** 原点の値を 0 とした場合,計算誤差？の問題から描画エリアが狂うため
+** 原点を 0.001 としておく。
+*/
+#define escv_device_full_body(dtype, pprocs, dname, stype, w, h, xdpi, ydpi, \
+			      ncomp, depth, mg, mc, dg, dc, lm, bm, rm, tm)\
+        std_device_part1_(dtype, pprocs, dname, stype, open_init_closed),\
+        dci_values(ncomp, depth, mg, mc, dg, dc),\
+        std_device_part2_(w, h, xdpi, ydpi),\
+	offset_margin_values(0.001, 0.001, lm, 0, 0, tm), \
+        std_device_part3_()
+
+
+#define escv_device_body(name)	\
+  escv_device_full_body(gx_device_escv, 0, name, \
+				&st_device_escv,\
+/* width & height */		ESCPAGE_DEFAULT_WIDTH, ESCPAGE_DEFAULT_HEIGHT,\
+/* default resolution */	X_DPI, Y_DPI,\
+/* color info */		3, 24, 255, 255, 256, 256,\
+				ESCPAGE_LEFT_MARGIN_DEFAULT,\
+				ESCPAGE_BOTTOM_MARGIN_DEFAULT,\
+				ESCPAGE_RIGHT_MARGIN_DEFAULT,\
+				ESCPAGE_TOP_MARGIN_DEFAULT)
+
+
+#define escv_procs	\
+{\
+	escv_open,				/* open_device */\
+	gx_default_get_initial_matrix,		/* get_initial_matrix */\
+	NULL,					/* sync_output */\
+	escv_output_page,			/* output_page */\
+	escv_close,				/* close_device */\
+	gx_default_rgb_map_rgb_color,		/* map_rgb_color */\
+        gx_default_rgb_map_color_rgb,		/* map_color_rgb */\
+	gdev_vector_fill_rectangle,		/* fill_rectangle */\
+	NULL,					/* tile_rectangle */\
+	escv_copy_mono,				/* dev_t_proc_copy_mono */\
+	escv_copy_color,			/* dev_t_proc_copy_color */\
+	NULL,					/* draw_line */\
+	NULL,					/* get_bits */\
+	escv_get_params,			/* dev_t_proc_get_params */\
+	escv_put_params,			/* dev_t_proc_put_params */\
+	NULL,					/* map_cmyk_color */\
+	NULL,					/* get_xfont_procs */\
+	NULL,					/* get_xfont_device */\
+	NULL,					/* map_rgb_alpha_color */\
+	gx_page_device_get_page_device,		/* dev_t_proc_get_page_device */\
+	NULL,					/* get_alpha_bits */\
+	NULL,					/* copy_alpha */\
+	NULL,					/* get_band */\
+	NULL,					/* copy_rop */\
+	gdev_vector_fill_path,			/* fill_path */\
+	gdev_vector_stroke_path,		/* stroke_path */\
+	escv_fill_mask,				/* fill_mask */\
+	gdev_vector_fill_trapezoid,		/* fill_trapezoid */\
+	gdev_vector_fill_parallelogram,		/* fill_parallelogram */\
+	gdev_vector_fill_triangle,		/* fill_triangle */\
+	NULL,	/****** WRONG ******/		/* draw_thin_line */\
+	escv_begin_image,			/* begin_image */\
+	NULL,					/* image_data */\
+	NULL,					/* end_image */\
+	NULL,					/* strip_tile_rectangle */\
+	NULL					/******strip_copy_rop******/\
+}
+
+
+#define	escv_init_code			\
+    vector_initial_values,\
+    ESCPAGE_MANUALFEED_DEFAULT,\
+    ESCPAGE_CASSETFEED_DEFAULT,\
+    ESCPAGE_RIT_DEFAULT,		/* RIT */\
+    FALSE,				/* Collate */\
+    0,					/* toner_density */\
+    FALSE,				/* toner_saving */\
+    0, 0, 0, 0, -1,\
+    0,					/* orientation */\
+    ESCPAGE_FACEUP_DEFAULT,\
+    ESCPAGE_MEDIATYPE_DEFAULT,\
+    0,					/* first_page */\
+    0,					/* Duplex */\
+    ESCPAGE_TUMBLE_DEFAULT,\
+    0,					/* ncomp */\
+    0,					/* MaskReverse */\
+    0,					/* MaskState */\
+    TRUE,				/* 4bits Color Map */\
+    TRUE,				/* 8bits Color Map */\
+    0,					/* prev_x */\
+    0,					/* prev_y */\
+    0,					/* prev_color */\
+    0,					/* current_color */\
+    {0},				/* id_cache */\
+    3,					/* lwidth */\
+    0,					/* cap */\
+    3,					/* join */\
+    0,0,				/* reverse x, y */\
+    {0,},				/* matrix */\
+    0,0,				/* x, y */\
+    0,0,				/* width, hight */\
+    0,					/* roll */\
+    0,0,				/* scale x, y */\
+    0					/* */
+
+
+gx_device_escv far_data gs_lp8000c_device =
+{
+    escv_device_body("lp8000c"),
+    escv_procs,
+    escv_init_code
+};
+
+
+gx_device_escv far_data gs_lp8200c_device =
+{
+    escv_device_body("lp8200c"),
+    escv_procs,
+    escv_init_code
+};
+
+gx_device_escv far_data gs_lp8300c_device =
+{
+    escv_device_body("lp8300c"),
+    escv_procs,
+    escv_init_code
+};
+
+gx_device_escv far_data gs_lp8500c_device =
+{
+    escv_device_body("lp8500c"),
+    escv_procs,
+    escv_init_code
+};
+
+gx_device_escv far_data gs_lp8800c_device =
+{
+    escv_device_body("lp8800c"),
+    escv_procs,
+    escv_init_code
+};
+
+gx_device_escv far_data gs_lp9000c_device =
+{
+    escv_device_body("lp9000c"),
+    escv_procs,
+    escv_init_code
+};
+
+gx_device_escv far_data gs_lp9200c_device =
+{
+    escv_device_body("lp9200c"),
+    escv_procs,
+    escv_init_code
+};
+
+gx_device_escv far_data gs_lp9500c_device =
+{
+    escv_device_body("lp9500c"),
+    escv_procs,
+    escv_init_code
+};
+
+gx_device_escv far_data gs_lp9800c_device =
+{
+    escv_device_body("lp9800c"),
+    escv_procs,
+    escv_init_code
+};
+
+gx_device_escv far_data gs_lp3000c_device =
+{
+    escv_device_body("lp3000c"),
+    escv_procs,
+    escv_init_code
+};
+
+gx_device_escv far_data gs_alc8600_device =
+{
+    escv_device_body("alc8600"),
+    escv_procs,
+    escv_init_code
+};
+
+gx_device_escv far_data gs_alc8500_device =
+{
+    escv_device_body("alc8500"),
+    escv_procs,
+    escv_init_code
+};
+
+gx_device_escv far_data gs_alc2000_device =
+{
+    escv_device_body("alc2000"),
+    escv_procs,
+    escv_init_code
+};
+
+gx_device_escv far_data gs_alc4000_device =
+{
+    escv_device_body("alc4000"),
+    escv_procs,
+    escv_init_code
+};
+
+gx_device_escv far_data gs_alc4100_device =
+{
+    escv_device_body("alc4100"),
+    escv_procs,
+    escv_init_code
+};
+
+gx_device_escv far_data gs_alc1900_device =
+{
+    escv_device_body("alc1900"),
+    escv_procs,
+    escv_init_code
+};
+
+gx_device_escv far_data gs_alc9100_device =
+{
+    escv_device_body("alc9100"),
+    escv_procs,
+    escv_init_code
+};
+
+
+#if ( 6 > GS_VERSION_MAJOR )
+/* Vector device implementation */
+private int escv_beginpage(P1(gx_device_vector * vdev));
+private int escv_setfillcolor(P2(gx_device_vector * vdev, const gx_drawing_color * pdc));
+private int escv_setstrokecolor(P2(gx_device_vector * vdev, const gx_drawing_color * pdc));
+private int escv_setdash(P4(gx_device_vector * vdev, const float *pattern, 
+			      uint count, floatp offset));
+private int escv_setflat(P2(gx_device_vector * vdev, floatp flatness));
+private int escv_setlogop(P3(gx_device_vector * vdev, gs_logical_operation_t lop, 
+			       gs_logical_operation_t diff));
+private int escv_vector_dorect(gx_device_vector * vdev, fixed x0, fixed y0, fixed x1,
+			       fixed y1, gx_path_type_t type);
+private int escv_vector_dopath(gx_device_vector * vdev, const gx_path * ppath,
+			       gx_path_type_t type);
+private int escv_beginpath(P2(gx_device_vector * vdev, gx_path_type_t type));
+private int escv_moveto(P6(gx_device_vector * vdev, floatp x0, floatp y0,
+			   floatp x, floatp y, gx_path_type_t type));
+private int escv_lineto(P6(gx_device_vector * vdev, floatp x0, floatp y0,
+			   floatp x, floatp y, gx_path_type_t type));
+private int escv_curveto(P10(gx_device_vector * vdev, floatp x0, floatp y0,
+			       floatp x1, floatp y1, floatp x2, floatp y2,
+			       floatp x3, floatp y3, gx_path_type_t type));
+private int escv_closepath(P6(gx_device_vector * vdev, floatp x, floatp y,
+				floatp x_start, floatp y_start, gx_path_type_t type));
+
+private int escv_endpath(P2(gx_device_vector * vdev, gx_path_type_t type));
+private int escv_setlinewidth(gx_device_vector * vdev, floatp width);
+private int escv_setlinecap(gx_device_vector * vdev, gs_line_cap cap);
+private int escv_setlinejoin(gx_device_vector * vdev, gs_line_join join);
+private int escv_setmiterlimit(gx_device_vector * vdev, floatp limit);
+
+#else /* 6 <= GS_VERSION_MAJOR */
+
+/* Page management */
+private int escv_beginpage (gx_device_vector * vdev);
+/* Imager state */
+private int escv_setlinewidth (gx_device_vector * vdev, floatp width);
+private int escv_setlinecap (gx_device_vector * vdev, gs_line_cap cap);
+private int escv_setlinejoin (gx_device_vector * vdev, gs_line_join join);
+private int escv_setmiterlimit (gx_device_vector * vdev, floatp limit);
+private int escv_setdash (gx_device_vector * vdev, const float *pattern,
+		    uint count, floatp offset);
+private int escv_setflat (gx_device_vector * vdev, floatp flatness);
+private int escv_setlogop (gx_device_vector * vdev, gs_logical_operation_t lop,
+		     gs_logical_operation_t diff);
+/* Other state */
+#if ( 8 <= GS_VERSION_MAJOR )
+private bool escv_can_handle_hl_color (gx_device_vector * vdev, const gs_imager_state * pis,
+                         const gx_drawing_color * pdc);
+private int escv_setfillcolor (gx_device_vector * vdev, const gs_imager_state * pis, 
+                         const gx_drawing_color * pdc);
+private int escv_setstrokecolor (gx_device_vector * vdev, const gs_imager_state * pis,
+                           const gx_drawing_color * pdc);
+#else
+private int escv_setfillcolor (gx_device_vector * vdev, const gx_drawing_color * pdc);
+private int escv_setstrokecolor (gx_device_vector * vdev, const gx_drawing_color * pdc);
+#endif
+/* Paths */
+/* dopath and dorect are normally defaulted */
+private int escv_vector_dopath (gx_device_vector * vdev, const gx_path * ppath,
+		   gx_path_type_t type, const gs_matrix *pmat);
+private int escv_vector_dorect (gx_device_vector * vdev, fixed x0, fixed y0, fixed x1,
+		   fixed y1, gx_path_type_t type);
+private int escv_beginpath (gx_device_vector * vdev, gx_path_type_t type);
+private int escv_moveto (gx_device_vector * vdev, floatp x0, floatp y0,
+		   floatp x, floatp y, gx_path_type_t type);
+private int escv_lineto (gx_device_vector * vdev, floatp x0, floatp y0,
+		   floatp x, floatp y, gx_path_type_t type);
+private int escv_curveto (gx_device_vector * vdev, floatp x0, floatp y0,
+		    floatp x1, floatp y1, floatp x2, floatp y2,
+		    floatp x3, floatp y3, gx_path_type_t type);
+private int escv_closepath (gx_device_vector * vdev, floatp x0, floatp y0,
+		      floatp x_start, floatp y_start, gx_path_type_t type);
+private int escv_endpath (gx_device_vector * vdev, gx_path_type_t type);
+
+
+#endif /* GS_VERSION_MAJOR */
+
+private const gx_device_vector_procs escv_vector_procs =
+{
+	/* Page management */
+    escv_beginpage,
+	/* Imager state */
+    escv_setlinewidth,
+    escv_setlinecap,
+    escv_setlinejoin,
+    escv_setmiterlimit,
+    escv_setdash,
+    escv_setflat,
+    escv_setlogop,
+	/* Other state */
+#if ( 8 <= GS_VERSION_MAJOR )
+    escv_can_handle_hl_color,	/* add gs815 */
+#endif
+    escv_setfillcolor,	/* fill & stroke colors are the same */
+    escv_setstrokecolor,
+	/* Paths */
+    escv_vector_dopath,
+    escv_vector_dorect,
+    escv_beginpath,
+    escv_moveto,
+    escv_lineto,
+    escv_curveto,
+    escv_closepath,
+    escv_endpath
+};
+
+private void escv_write_begin(gx_device *, int, int, int, int, int, int, int, int);
+private void escv_write_data(gx_device *, int, char *, int, int, int);
+private void escv_write_end(gx_device *, int);
+
+
+/* ---------------- Utilities ---------------- */
+
+/* Put a string on a stream.
+   This function is copy of `pputs' in gdevpstr.c */
+private int
+lputs(stream * s, const char *str)
+{
+    uint	len = strlen(str);
+    uint	used;
+    int		status;
+
+    status = sputs(s, (const byte *)str, len, &used);
+
+    return (status >= 0 && used == len ? 0 : EOF);
+}
+
+/* Write a string on a stream. */
+private void
+put_bytes(stream * s, const byte * data, uint count)
+{
+    uint used;
+
+    sputs(s, data, count, &used);
+}
+
+
+private int
+escv_range_check(gx_device * dev)
+{
+    int width = dev->MediaSize[0];
+    int height = dev->MediaSize[1];
+    int xdpi = dev->x_pixels_per_inch;
+    int ydpi = dev->y_pixels_per_inch;
+
+    /* Paper Size Check */
+    if (width <= height) {	/* portrait */
+      if ((width < ESCPAGE_WIDTH_MIN ||
+	   width > ESCPAGE_WIDTH_MAX ||
+	   height < ESCPAGE_HEIGHT_MIN ||
+	   height > ESCPAGE_HEIGHT_MAX)) {
+	return_error(gs_error_rangecheck);
+      }
+    } else {			/* landscape */
+      if ((width < ESCPAGE_HEIGHT_MIN ||
+	   width > ESCPAGE_HEIGHT_MAX ||
+	   height < ESCPAGE_WIDTH_MIN ||
+	   height > ESCPAGE_WIDTH_MAX )) {
+	return_error(gs_error_rangecheck);
+      }
+    }
+
+    /* Resolution Check */
+    if (xdpi != ydpi) {
+      return_error(gs_error_rangecheck);
+    }
+
+    if ((xdpi < ESCPAGE_DPI_MIN ||
+	 xdpi > ESCPAGE_DPI_MAX)) {
+      return_error(gs_error_rangecheck);
+    }
+
+    return 0;			/* pass */
+}
+
+
+/* ---------------- Vector device implementation ---------------- */
+
+private int
+escv_vector_dopath(gx_device_vector * vdev, const gx_path * ppath,
+		   gx_path_type_t type
+#if ( 6 <= GS_VERSION_MAJOR )
+		   , const gs_matrix *pmat
+#endif
+		   )
+{
+    bool do_close = (type & gx_path_type_stroke) != 0;
+    gs_fixed_rect rect;
+    gs_point scale;
+    double x_start = 0, y_start = 0, x_prev = 0, y_prev = 0;
+    bool first = true;
+    gs_path_enum cenum;
+    int code;
+
+    stream	*s = gdev_vector_stream(vdev);
+    char	obuf[128];
+
+    if (gx_path_is_rectangle(ppath, &rect))
+	return (*vdev_proc(vdev, dorect)) (vdev, rect.p.x, rect.p.y, rect.q.x, rect.q.y, type);
+    scale = vdev->scale;
+    code = (*vdev_proc(vdev, beginpath)) (vdev, type);
+    gx_path_enum_init(&cenum, ppath);
+
+    for (;;) {
+	double	x, y;
+	fixed	vs[6];
+	int	pe_op, cnt;
+	const segment *pseg;
+
+
+	pe_op = gx_path_enum_next(&cenum, (gs_fixed_point *) vs);
+
+      sw:switch (pe_op) {
+	    case 0:		/* done */
+		return (*vdev_proc(vdev, endpath)) (vdev, type);
+
+	    case gs_pe_moveto:
+		x = fixed2float(vs[0]) / scale.x;
+		y = fixed2float(vs[1]) / scale.y;
+
+		/* サブパス開始命令 p1 */
+		(void)sprintf(obuf, ESC_GS "0;%d;%dmvpG", (int)x, (int)y);
+		lputs(s, obuf);
+
+		if (first)
+		    x_start = x, y_start = y, first = false;
+		break;
+
+	    case gs_pe_lineto:
+		cnt = 1;
+		for (pseg = cenum.pseg; pseg != 0 && pseg->type == s_line; cnt++, pseg = pseg->next);
+
+		(void)sprintf(obuf, ESC_GS "0;%d", cnt);
+		lputs(s, obuf);
+
+		do {
+		    (void)sprintf(obuf, ";%d;%d", (int)(fixed2float(vs[0]) / scale.x), (int)(fixed2float(vs[1]) / scale.y));
+		    lputs(s, obuf);
+
+		    pe_op = gx_path_enum_next(&cenum, (gs_fixed_point *) vs);
+		} while (pe_op == gs_pe_lineto);
+
+		/* パス・ポリライン命令 */
+		lputs(s, "lnpG");
+
+		goto sw;
+
+	    case gs_pe_curveto:
+		cnt = 1;
+		for (pseg = cenum.pseg; pseg != 0 && pseg->type == s_curve; cnt++, pseg = pseg->next);
+		(void)sprintf(obuf, ESC_GS "0;%d", cnt * 3);
+		lputs(s, obuf);
+
+		do {
+		    (void)sprintf(obuf, ";%d;%d;%d;%d;%d;%d",
+				  (int)(fixed2float(vs[0]) / scale.x), (int)(fixed2float(vs[1]) / scale.y),
+				  (int)(fixed2float(vs[2]) / scale.x), (int)(fixed2float(vs[3]) / scale.y),
+				  (int)(fixed2float(vs[4]) / scale.x), (int)(fixed2float(vs[5]) / scale.y));
+		    lputs(s, obuf);
+
+		    pe_op = gx_path_enum_next(&cenum, (gs_fixed_point *) vs);
+		} while (pe_op == gs_pe_curveto);
+
+		/* ベジェ曲線 */
+		lputs(s, "bzpG");
+
+		goto sw;
+
+	    case gs_pe_closepath:
+		x = x_start, y = y_start;
+		if (do_close) {
+		    lputs(s, ESC_GS "clpG");
+		    break;
+		}
+
+		pe_op = gx_path_enum_next(&cenum, (gs_fixed_point *) vs);
+		if (pe_op != 0) {
+		    lputs(s, ESC_GS "clpG");
+
+		    if (code < 0)
+			return code;
+		    goto sw;
+		}
+		return (*vdev_proc(vdev, endpath)) (vdev, type);
+	    default:		/* can't happen */
+		return_error(gs_error_unknownerror);
+	}
+	if (code < 0)
+	    return code;
+	x_prev = x, y_prev = y;
+    }
+}
+
+
+private int
+escv_vector_dorect(gx_device_vector * vdev, fixed x0, fixed y0, fixed x1,
+		   fixed y1, gx_path_type_t type)
+{
+    int		code;
+    char	obuf[128];
+    gs_point	scale;
+    stream	*s = gdev_vector_stream(vdev);
+
+    code = (*vdev_proc(vdev, beginpath))(vdev, type);
+    if (code < 0)
+	return code;
+
+    scale = vdev->scale;
+
+    (void)sprintf(obuf, ESC_GS "0;%d;%d;%d;%d;0;0rrpG", (int)(fixed2float(x0) / scale.x), (int)(fixed2float(y0) / scale.y), (int)(fixed2float(x1) / scale.x), (int)(fixed2float(y1) / scale.y));
+    lputs(s, obuf);
+
+#if 0
+    /* Ghostscript 側のバグで closepath を呼んでいないので処理を会わせる。 */
+
+    /* 本来は (*vdev_proc(vdev, closepath))() を呼ぶべき */
+    lputs(s, ESC_GS "clpG");
+#endif
+
+    return (*vdev_proc(vdev, endpath))(vdev, type);
+}
+
+
+/* ---------- */
+
+
+typedef struct {
+    int		width;			/* paper width (unit: point) */
+    int		height;			/* paper height (unit: point) */
+    int		escpage;		/* number of papersize in ESC/PAGE */
+  const char	*name;			/* Paper Name */
+} EPaperTable;
+
+private const EPaperTable ePaperTable[NUM_OF_PAPER_TABLES] =
+{
+    {933, 1369, 72, "A3PLUS"},		/* A3 NOBI */
+    {842, 1191, 13, "A3"},		/* A3 */
+    {595, 842, 14, "A4"},		/* A4 */
+    {420, 595, 15, "A5"},		/* A5 */
+    {709, 1001, 24, "B4"},		/* B4 */
+    {729, 1032, 24, "B4"},		/* B4 JIS */
+    {516, 729, 25, "B5"},		/* B5 JIS */
+    {612, 792, 30, "LT"},		/* Letter */
+    {396, 612, 31, "HLT"},		/* Half Letter */
+    {612, 1008, 32, "LGL"},		/* Legal */
+    {522, 756, 33, "EXE"},		/* Executive */
+    {612, 936, 34, "GLG"},		/* Government Letter */ /* LPD.1. */
+    {576, 756, 35, "GLT"},		/* Government Legal */ /* LPD.1. */
+    {792, 1224, 36, "B"},		/* Ledger */
+    {595, 935, 37, "F4"},		/* F4 */
+    {283, 420, 38, "POSTCARD"},		/* PostCard */
+    {298, 666, 64, "YOU4"},             /* Japanese Envelope You4 */
+    {279, 540, 80, "MON"},		/* Monarch */
+    {297, 684, 81, "C10"},		/* Commercial 10 */
+    {312, 624, 90, "DL"},		/* DL */
+    {459, 649, 91, "C5"},               /* Envelope C5 */
+    {499, 709, 99, "IB5"},              /* Envelope ISO B5 */
+    {0, 0, -1, NULL}			/* Undefined */
+};
+
+typedef struct paper_candidate_s {
+  const EPaperTable *paper;
+  int absw;
+  int absh;
+  int score;
+  bool isfillw;
+  bool isfillh;
+  bool isminw;
+  bool isminh;
+} paper_candidate;
+
+
+private const EPaperTable *
+escv_checkpapersize(gx_device_vector * vdev)
+{
+  gx_device_escv	*const pdev = (gx_device_escv *)vdev;
+  int			devw, devh;
+  paper_candidate	candidate[NUM_OF_PAPER_TABLES];
+  int			num_candidate;
+
+  
+  if (pdev->MediaSize[0] < pdev->MediaSize[1]) {
+    /* portrait */
+    devw = pdev->MediaSize[0];
+    devh = pdev->MediaSize[1];
+  } else {
+    /* landscape */
+    devw = pdev->MediaSize[1];
+    devh = pdev->MediaSize[0];
+  }
+
+  /* pick up papersize candidate */
+  {
+    const EPaperTable *pt;
+    int delta;
+
+    num_candidate = 0;
+
+    for (delta = 0; delta <= MAX_PAPER_SIZE_DELTA; delta++) {
+      for (pt = ePaperTable; 0 <= pt->escpage; pt++) {
+	if ( (pt->width  + delta) >= devw &&
+	     (pt->width  - delta) <= devw &&
+	     (pt->height + delta) >= devh &&
+	     (pt->height - delta) <= devh) {
+
+	  candidate[num_candidate].paper = pt;
+	  candidate[num_candidate].absw = abs(pt->width  - devw);
+	  candidate[num_candidate].absh = abs(pt->height - devh);
+	  candidate[num_candidate].score = 0;
+	  candidate[num_candidate].isfillw = false;
+	  candidate[num_candidate].isfillh = false;
+	  candidate[num_candidate].isminw  = false;
+	  candidate[num_candidate].isminh  = false;
+
+	  if( 0 <= (pt->width - devw) ){
+	    candidate[num_candidate].isfillw = true;
+	  }
+	  if( 0 <= (pt->height - devh) ){
+	    candidate[num_candidate].isfillh = true;
+	  }
+	  num_candidate++;
+	}
+      }
+      if ( 0 < num_candidate ) {
+	break;
+      }
+    }
+  }
+  
+  /* no papersize match, so use default paper size */
+  if ( 0 == num_candidate  ) {
+    return (const EPaperTable *)0;		/* not found */
+  }
+
+  if ( 1 == num_candidate ) {
+    return candidate[0].paper; /* find */
+  }
+
+  /* search abstruct minw & minh */
+  {
+    int absminw;
+    int absminh;
+    int i;
+
+    absminw = candidate[0].absw;
+    absminh = candidate[0].absh;
+    for (i = 1; i < num_candidate; i++) {
+      if (absminw > candidate[i].absw) {
+	absminw = candidate[i].absw;
+      }
+      if (absminh > candidate[i].absh) {
+	absminh = candidate[i].absh;
+      }
+    }
+
+    /* check isminw & isminh flag */
+    for (i = 0; i < num_candidate; i++) {
+      if (absminw == candidate[i].absw) {
+	candidate[i].isminw = true;
+      }
+      if (absminh == candidate[i].absh) {
+	candidate[i].isminh = true;
+      }
+    }
+
+    /* add score */
+    for (i = 0; i < num_candidate; i++) {
+      if (candidate[i].isminw == true) {
+	candidate[i].score += 100;
+      }
+      if (candidate[i].isminh == true) {
+	candidate[i].score += 100;
+      }
+      if (candidate[i].isfillw == true) {
+	candidate[i].score += 10;
+      }
+      if (candidate[i].isfillh == true) {
+	candidate[i].score += 10;
+      }
+      if (absminw < absminh) {
+	if (candidate[i].isminw == true) {
+	  candidate[i].score += 1;
+	}
+      } else {
+	if (candidate[i].isminh == true) {
+	  candidate[i].score += 1;
+	}
+      }
+    }
+  }
+
+  /* select highest score papersize */
+  {
+    int best_candidate;
+    int i;
+
+    best_candidate = 0;
+    for (i = 1; i < num_candidate; i++) {
+      if ( candidate[best_candidate].score <= candidate[i].score ) {
+	best_candidate = i;
+      }
+    }
+    return candidate[best_candidate].paper;
+  }
+}
+
+private int
+escv_beginpage(gx_device_vector * vdev)
+{
+    gx_device_escv	*const pdev = (gx_device_escv *)vdev;
+    /* gdev_vector_stream は使用禁止 */
+    stream		*s = vdev->strm;
+    char		ebuf[1024];
+    int                 MaxRes;
+    int                 Local;
+    int                 Duplex;
+    int                 FaceUp;
+
+    if (pdev -> first_page) {
+
+	if (strcmp(pdev->dname, "lp8000c") == 0 || \
+	    strcmp(pdev->dname, "lp8200c")  == 0 ) {
+	    MaxRes = RES600;
+	    Local  = JPN;
+	    Duplex = FALSE;
+	    FaceUp = TRUE;
+	} else if (strcmp(pdev->dname, "lp8300c") == 0 || \
+	    strcmp(pdev->dname, "lp8500c")  == 0 || \
+	    strcmp(pdev->dname, "lp8800c")  == 0 || \
+	    strcmp(pdev->dname, "lp9500c")  == 0 || \
+	    strcmp(pdev->dname, "lp9800c")  == 0 ) {
+	    MaxRes = RES600;
+	    Local  = JPN;
+	    Duplex = TRUE;
+	    FaceUp = TRUE;
+	} else if (strcmp(pdev->dname, "lp3000c") == 0 || \
+	    strcmp(pdev->dname, "lp9200c")  == 0 || \
+	    strcmp(pdev->dname, "lp9000c")  == 0 ) {
+	    MaxRes = RES600;
+	    Local  = JPN;
+	    Duplex = TRUE;
+	    FaceUp = FALSE;
+	} else if (strcmp(pdev->dname, "alc8500") == 0 || \
+	    strcmp(pdev->dname, "alc8600")  == 0 || \
+	    strcmp(pdev->dname, "alc9100")  == 0 ) {
+	    MaxRes = RES600;
+	    Local  = ENG;
+	    Duplex = TRUE;
+	    FaceUp = TRUE;
+	} else if (strcmp(pdev->dname, "alc2000") == 0 || \
+	    strcmp(pdev->dname, "alc4100")  == 0 ) {
+	    MaxRes = RES600;
+	    Local  = ENG;
+	    Duplex = TRUE;
+	    FaceUp = FALSE;
+	} else if (strcmp(pdev->dname, "alc4000") == 0) {
+	    MaxRes = RES1200;
+	    Local  = ENG;
+	    Duplex = TRUE;
+	    FaceUp = FALSE;
+	} else if (strcmp(pdev->dname, "alc1900") == 0) {
+	    MaxRes = RES600;
+	    Local  = ENG;
+	    Duplex = TRUE;
+	    FaceUp = FALSE;
+	} else {
+	    MaxRes = RES600;
+	    Local  = JPN;
+	    Duplex = FALSE;
+	    FaceUp = FALSE;
+	}
+
+	lputs(s, "\033\001@EJL \012@EJL SJ ID=\"Ghostscript\"\012");
+	lputs(s, "@EJL SE LA=ESC/PAGE\012");
+	lputs(s, "@EJL SET");
+	/* Resolusion */
+	if (vdev->x_pixels_per_inch == 1200){
+	    if (MaxRes == 1200){
+	    	lputs(s, " RS=1200");
+	    } else {
+	    	lputs(s, " RS=FN");
+	    }
+	} else if (vdev->x_pixels_per_inch == 600) {
+	    lputs(s, " RS=FN");
+	} else {
+	    lputs(s, " RS=QK");
+	}
+
+	/* Output Unit */
+	if ((pdev->faceup && FaceUp) || (pdev->MediaType && FaceUp)) {
+	    lputs(s, " OU=FU");
+	} else {
+	    lputs(s, " OU=FD");
+	}
+
+	/* Paper unit */
+        if (pdev->MediaType){
+	    if (Local == ENG){
+		lputs(s, " PU=1");
+	    } else {
+		lputs(s, " PU=15");
+	    }
+	}else{
+	    if (pdev->manualFeed) {
+		if (Local == ENG){
+		    lputs(s, " PU=1");
+		} else {
+	            lputs(s, " PU=15");
+		}
+	    } else if (pdev->cassetFeed) {
+	        (void)sprintf(ebuf, " PU=%d", pdev->cassetFeed);
+	        lputs(s, ebuf);
+	    } else {
+	        lputs(s, " PU=AU");
+	    }
+	}
+
+	if (Duplex && pdev->Duplex) {
+	    /* 両面印刷指定 */
+	    lputs(s, " DX=ON");
+
+	    /* とじ方向 */
+	    if (pdev->Tumble) {
+		lputs(s, " BD=SE");
+	    } else {
+		lputs(s, " BD=LE");
+	    }
+        } else {
+	    /* 両面印刷off */
+	    lputs(s, " DX=OFF");
+	}
+
+	/* 印刷部数 */
+	if (pdev->NumCopies) {
+	    if (pdev->NumCopies >= 1000) {
+		pdev->NumCopies = 999;
+	    }
+
+	    /* lp8000c では QT が使えない */
+	    if (strcmp(pdev->dname, "lp8000c") == 0) {
+		(void)sprintf(ebuf, " QT=1 CO=%d", pdev->NumCopies);
+	    } else {
+                if (pdev->Collate) {
+		    /* QT を指定した場合 CO は 1 */
+		    (void)sprintf(ebuf, " QT=%d CO=1", pdev->NumCopies);
+	        } else {
+		    /* QT を指定しなかった場合 QT は 1 */
+		    (void)sprintf(ebuf, " QT=1 CO=%d", pdev->NumCopies);
+		}
+	    }
+	    lputs(s, ebuf);
+	} else {
+	    lputs(s, " QT=1 CO=1");
+	}
+
+	if (pdev->toner_density) {
+	    (void)sprintf(ebuf, " DL=%d", pdev->toner_density);
+	    lputs(s, ebuf);
+	}
+
+	if (pdev->orientation) {
+	    lputs(s, " OR=LA");
+	}
+
+	if (pdev->toner_saving) {
+	    lputs(s, " SN=ON");
+	}
+
+	if (pdev->RITOff) {
+	    lputs(s, " RI=OFF");
+	} else {
+	    lputs(s, " RI=ON");
+	}
+
+	if (pdev->MediaType == 1) {
+	    lputs(s, " PK=TH");
+	} else if (pdev->MediaType == 2) {
+	    lputs(s, " PK=TR");
+	} else {
+	    lputs(s, " PK=NM");
+	}
+
+	lputs(s, " PS=");
+	{
+	  const EPaperTable *pt;
+
+	  pt = escv_checkpapersize(vdev);
+	  if ( 0 == pt ) {
+	    lputs(s, "A4");
+	  } else {
+	    lputs(s, pt->name);
+	  }
+	}
+
+	lputs(s, " ZO=OFF EC=ON SZ=OFF SL=YES TO=0 LO=0\012");
+	lputs(s, "@EJL EN LA=ESC/PAGE-COLOR\012");
+
+#define	START_CODE1	ESC_GS "1tsE" ESC_GS "0alfP" ESC_GS "0affP" ESC_GS "0;0;0clfP" ESC_GS "0pmP" ESC_GS "1024ibI" ESC_GS "2cmE" ESC_GS "0bcI" ESC_GS "1;10mlG"
+
+#define	LP8000_CODE	ESC_GS "0pddO" ESC_GS "0;0mmE" ESC_GS "2csE" ESC_GS "0;1;3cmmE" ESC_GS "0;1raE" ESC_GS "0;2;4ccmE"
+
+#define	LP8200_CODE	ESC_GS "0pddO" ESC_GS "0;0cmmE" ESC_GS "1;2;3ccmE" ESC_GS "2;2;3ccmE" ESC_GS "3;2;4ccmE" ESC_GS "1;1raE" ESC_GS "2;1raE" ESC_GS "3;1raE"
+
+	lputs(s, ESC_GS "rhE");
+
+	if (strcmp(vdev -> dname, "lp8000c") == 0) {
+	    lputs(s, LP8000_CODE);
+	} else {
+	    lputs(s, LP8200_CODE);
+	}
+
+#if 1	/* default */
+	put_bytes(s, ESC_GS "7;0;2;0cam{E\012\000\000\000\000\000\000", 20);
+	lputs(s, ESC_GS "0;0cmmE" ESC_GS "0;0loE");
+#else	
+	put_bytes(s, ESC_GS "7;0;2;3cam{E\012\000\000\000\000\000\000", 20);
+	lputs(s, ESC_GS "1cmmE" ESC_GS "0;0loE");
+#endif
+        if (vdev->x_pixels_per_inch == 1200) {
+            /* 1200 dpi */
+            lputs(s, ESC_GS "0;0.06muE");
+            lputs(s, ESC_GS "3;1200;1200drE" ESC_GS "2;1200;1200drE" ESC_GS "1;1200;1200drE" ESC_GS "0;1200;1200drE");
+        } else if (vdev->x_pixels_per_inch == 600) {
+	    /* 600 dpi */
+	    lputs(s, ESC_GS "0;0.12muE");
+	    lputs(s, ESC_GS "3;600;600drE" ESC_GS "2;600;600drE" ESC_GS "1;600;600drE" ESC_GS "0;600;600drE");
+	} else {
+	    /* 300 dpi */
+	    lputs(s, ESC_GS "0;0.24muE");
+	    lputs(s, ESC_GS "3;300;300drE" ESC_GS "2;300;300drE" ESC_GS "1;300;300drE" ESC_GS "0;300;300drE");
+	}
+
+	lputs(s, START_CODE1);
+	lputs(s, ESC_GS "8;1;2;2;2plr{E");
+	put_bytes(s, "\377\377\377\377\000\000\000\000", 8);
+
+	lputs(s, ESC_GS "0sarG");		/* 絶対座標指定 */
+	lputs(s, ESC_GS "2;204wfE");		/* rop 指定 */
+    }
+    
+    return 0;
+}
+
+
+private int
+escv_setlinewidth(gx_device_vector * vdev, floatp width)
+{
+    stream			*s = gdev_vector_stream(vdev);
+    gx_device_escv *const	pdev = (gx_device_escv *) vdev;
+    char			obuf[64];
+
+#if GS_VERSION_MAJOR == 5
+    /* Scale を掛けているのは, Ghostscript 5.10/5.50 のバグのため */
+    floatp xscale, yscale;
+
+    xscale = fabs(igs->ctm.xx);
+    yscale = fabs(igs->ctm.xy);
+
+    if (xscale == 0 || yscale > xscale)		/* if portrait */
+	width = ceil(width * yscale);
+    else
+	width = ceil(width * xscale);
+#endif
+
+    if (width < 1) width = 1;
+
+    /* ESC/Page では線幅／終端／接合部の設定は１つのコマンドになっているため保持しておく。 */
+    pdev -> lwidth = width;
+
+    (void)sprintf(obuf, ESC_GS "%d;%d;%dlwG", (int)(pdev -> lwidth), (int)(pdev -> cap), (int)(pdev -> join));
+    lputs(s, obuf);
+
+    return 0;
+}
+
+
+private int
+escv_setlinecap(gx_device_vector * vdev, gs_line_cap cap)
+{
+    stream			*s = gdev_vector_stream(vdev);
+    gx_device_escv *const	pdev = (gx_device_escv *) vdev;
+    char			obuf[64];
+
+    /* ESC/Page では線幅／終端／接合部の設定は１つのコマンドになっているため保持しておく。 */
+    pdev -> cap = cap;
+
+    if (pdev -> cap >= 3) return -1;
+
+    (void)sprintf(obuf, ESC_GS "%d;%d;%dlwG", (int)(pdev -> lwidth), (int)(pdev -> cap), (int)(pdev -> join));
+    lputs(s, obuf);
+
+    return 0;
+}
+
+
+private int
+escv_setlinejoin(gx_device_vector * vdev, gs_line_join join)
+{
+    stream			*s = gdev_vector_stream(vdev);
+    gx_device_escv *const	pdev = (gx_device_escv *) vdev;
+    char			obuf[64];
+
+    /* ESC/Page では線幅／終端／接合部の設定は１つのコマンドになっているため保持しておく。 */
+    switch (join) {
+    case 0:
+	pdev -> join = 3;		/* miter */
+	break;
+    case 1:
+	pdev -> join = 1;		/* round */
+	break;
+    case 2:
+	pdev -> join = 2;		/* bevel */
+	break;
+    default:
+	return -1;
+    }
+
+    (void)sprintf(obuf, ESC_GS "%d;%d;%dlwG", (int)(pdev -> lwidth), (int)(pdev -> cap), (int)(pdev -> join));
+    lputs(s, obuf);
+
+    return 0;
+}
+
+
+private int
+escv_setmiterlimit(gx_device_vector * vdev, floatp limit)
+{
+    stream			*s = gdev_vector_stream(vdev);
+    gx_device_escv *const	pdev = (gx_device_escv *) vdev;
+    char			obuf[128];
+
+    /* マイターリミット値を設定するには lwG にて 接合部指定(n3) が 3 になっている
+    ** 必要がある。
+    */
+    if (pdev -> join != 3) {
+	/* 強制的に接合部指定を行う */
+	pdev -> join = 3;
+	(void)sprintf(obuf, ESC_GS "%d;%d;%dlwG", (int)(pdev -> lwidth), (int)(pdev -> cap), (int)(pdev -> join));
+	lputs(s, obuf);
+    }
+
+    (void)sprintf(obuf, ESC_GS "1;%dmlG", (int)limit);
+    lputs(s, obuf);
+
+    return 0;
+}
+
+
+#if ( 8 <= GS_VERSION_MAJOR )
+private bool
+escv_can_handle_hl_color(gx_device_vector * vdev, const gs_imager_state * pis, 
+                         const gx_drawing_color * pdc)
+{
+    return false;
+}
+#endif
+
+
+private int
+escv_setfillcolor(gx_device_vector * vdev,
+#if ( 8 <= GS_VERSION_MAJOR )
+		  const gs_imager_state * pis,
+#endif
+		  const gx_drawing_color * pdc)
+{
+    stream			*s = gdev_vector_stream(vdev);
+    gx_device_escv *const	pdev = (gx_device_escv *) vdev;
+    gx_color_index		color = gx_dc_pure_color(pdc);
+    char			obuf[64];
+
+    if (!gx_dc_is_pure(pdc)) return_error(gs_error_rangecheck);
+    pdev->current_color = color;
+
+    /* パターンＯＮ指定／ソリッドパターン指定 */
+    (void)sprintf(obuf, ESC_GS "1;2;3;%d;%d;%dfpE",
+		  (unsigned char)(color >> 16 & 0xff),
+		  (unsigned char)(color >> 8 & 0xff),
+		  (unsigned char)(color & 0xff));
+    lputs(s, obuf);
+    lputs(s, ESC_GS "3;2;1;0;0cpE" ESC_GS "1;2;1;0;0cpE" ESC_GS "5;2;1;0;0cpE");
+
+    return 0;
+}
+
+
+private int
+escv_setstrokecolor(gx_device_vector * vdev,
+#if ( 8 <= GS_VERSION_MAJOR )
+		    const gs_imager_state * pis,
+#endif
+		    const gx_drawing_color * pdc)
+{
+    stream			*s = gdev_vector_stream(vdev);
+    gx_device_escv *const	pdev = (gx_device_escv *) vdev;
+    gx_color_index		color = gx_dc_pure_color(pdc);
+    char			obuf[64];
+
+    if (!gx_dc_is_pure(pdc)) return_error(gs_error_rangecheck);
+
+    if (vdev->color_info.depth == 24) {
+
+	pdev->current_color = color;
+	/* パターンＯＮ色指定／ソリッドパターン指定 */
+	(void)sprintf(obuf, ESC_GS "1;2;3;%d;%d;%dfpE" ESC_GS "2;2;1;0;0cpE",
+		      (unsigned char)(color >> 16 & 0xff),
+		      (unsigned char)(color >> 8 & 0xff),
+		      (unsigned char)(color & 0xff));
+	lputs(s, obuf);
+
+    }
+    return 0;
+}
+
+
+/* 線種指定命令 */
+private int
+escv_setdash(gx_device_vector * vdev, const float *pattern, uint count, floatp offset)
+{
+    stream			*s = gdev_vector_stream(vdev);
+    int				i;
+    char			obuf[64];
+
+#if GS_VERSION_MAJOR == 5
+    float			scale, xscale, yscale;
+    /* Scale を掛けているのは, Ghostscript 5.10/5.50 のバグのため */
+    xscale = fabs(igs->ctm.xx);
+    yscale = fabs(igs->ctm.xy);
+
+    if (xscale == 0)		/* if portrait */
+	scale = yscale;
+    else
+	scale = xscale;
+#endif
+
+    if (count == 0){
+	/* 実線 */
+	lputs(s, ESC_GS "0;0lpG");
+	return 0;
+    }
+    
+    /* offset が０以外の場合は描画不可として返却 */
+    if (offset != 0) return -1;
+
+    if (count) {
+	if (count == 1) {
+#if GS_VERSION_MAJOR == 5
+	    (void)sprintf(obuf, ESC_GS "1;%d;%ddlG", 
+			  (int)(pattern[0] * scale / vdev->x_pixels_per_inch + 0.5),
+			  (int)(pattern[0] * scale / vdev->x_pixels_per_inch + 0.5));
+#else
+	    (void)sprintf(obuf, ESC_GS "1;%d;%ddlG", pattern[0], pattern[0]);
+#endif
+	    lputs(s, obuf);
+	} else {
+	    /* pattern に０があった場合は描画不可として返却 */
+	    for (i = 0; i < count; ++i) {
+		if (pattern[i] == 0) return -1;
+	    }
+
+	    lputs(s, ESC_GS "1");
+	    for (i = 0; i < count; ++i) {
+#if GS_VERSION_MAJOR == 5
+		(void)sprintf(obuf, ";%d", (int)(pattern[i] * scale / vdev->x_pixels_per_inch + 0.5));
+
+#else
+		(void)sprintf(obuf, ";%d", pattern[i]);
+#endif
+		lputs(s, obuf);
+	    }
+	    lputs(s, "dlG");
+	}
+	lputs(s, ESC_GS "1;1lpG");
+    }
+    return 0;
+}
+
+
+/* パス平滑度指定 */
+private int
+escv_setflat(gx_device_vector * vdev, floatp flatness)
+{
+    return 0;
+}
+
+
+private int
+escv_setlogop(gx_device_vector * vdev, gs_logical_operation_t lop,
+		gs_logical_operation_t diff)
+{
+/****** SHOULD AT LEAST DETECT SET-0 & SET-1 ******/
+    return 0;
+}
+
+
+private int
+escv_beginpath(gx_device_vector * vdev, gx_path_type_t type)
+{
+    stream		*s = gdev_vector_stream(vdev);
+
+    /* パス構築開始命令 */
+    if (type & gx_path_type_clip) {
+	lputs(s, ESC_GS "1bgpG");		/* クリップ登録 */
+    } else {
+	lputs(s, ESC_GS "0bgpG");		/* 描画登録 */
+    }
+    return 0;
+}
+
+
+private int
+escv_moveto(gx_device_vector * vdev,
+	    floatp x0, floatp y0, floatp x1, floatp y1, gx_path_type_t type)
+{
+    stream	*s = gdev_vector_stream(vdev);
+    char	obuf[64];
+
+    /* サブパス開始命令 */
+    (void)sprintf(obuf, ESC_GS "0;%d;%dmvpG", (int)x1, (int)y1);
+    lputs(s, obuf);
+
+    return 0;
+}
+
+
+private int
+escv_lineto(gx_device_vector * vdev,
+	    floatp x0, floatp y0, floatp x1, floatp y1, gx_path_type_t type)
+{
+    stream	*s = gdev_vector_stream(vdev);
+    char	obuf[64];
+
+    (void)sprintf(obuf, ESC_GS "0;1;%d;%dlnpG", (int)x1, (int)y1);
+    lputs(s, obuf);
+
+    return 0;
+}
+
+
+private int
+escv_curveto(gx_device_vector * vdev, floatp x0, floatp y0,
+	   floatp x1, floatp y1, floatp x2, floatp y2, floatp x3, floatp y3,
+	       gx_path_type_t type)
+{
+    stream	*s = gdev_vector_stream(vdev);
+    char	obuf[128];
+
+    /* ベジェ曲線 */
+    (void)sprintf(obuf, ESC_GS "0;3;%d;%d;%d;%d;%d;%dbzpG",
+		  (int)x1, (int)y1, (int)x2, (int)y2, (int)x3, (int)y3);
+    lputs(s, obuf);
+
+    return 0;
+}
+
+
+private int
+escv_closepath(gx_device_vector * vdev, floatp x, floatp y,
+		 floatp x_start, floatp y_start, gx_path_type_t type)
+{
+    stream	*s = gdev_vector_stream(vdev);
+
+    lputs(s, ESC_GS "clpG");
+    return 0;
+}
+
+
+private int
+escv_endpath(gx_device_vector * vdev, gx_path_type_t type)
+{
+    stream	*s = gdev_vector_stream(vdev);
+
+    if (type & gx_path_type_fill || type & gx_path_type_clip) {
+	/* default で処理されるが出力しておく */
+	lputs(s, ESC_GS "clpG");
+    }
+
+    /* パスクローズ */
+    lputs(s, ESC_GS "enpG");
+
+    /* パス描画 */
+    if (type & gx_path_type_clip) {
+
+	/* クリップ指定
+	** クリップにも gx_path_type_winding_number, gx_path_type_even_odd の判断が
+	** 必要だと思うが gs 側が付加してこない。 
+	** とりあえず gx_path_type_even_odd をデフォルトにする。
+	*/
+	lputs(s, ESC_GS "1;2capG");
+    } else if (type & gx_path_type_fill) {
+
+	/* 塗りつぶし規則設定 */
+	if (type & gx_path_type_even_odd) {
+	    lputs(s, ESC_GS "0;2drpG");		/* 塗りつぶし描画 */
+	} else {
+	    lputs(s, ESC_GS "0;1drpG");		/* 塗りつぶし描画 */
+	}
+    } else {	
+	lputs(s, ESC_GS "0;0drpG");		/* 輪郭線描画 */
+    }
+
+    return 0;
+}
+
+/* ---------------- Driver procedures ---------------- */
+
+/* ------ Open/close/page ------ */
+
+/* Open the device. */
+private int
+escv_open(gx_device * dev)
+{
+    gx_device_vector	*const vdev = (gx_device_vector *) dev;
+    gx_device_escv	*const pdev = (gx_device_escv *) dev;
+    int			code;
+    /*    char		*error, *path;*/
+    float               width, height;
+
+    code = escv_range_check(dev);
+    if (code < 0) return code;
+
+    vdev->v_memory = dev->memory;
+    /****** VERY WRONG ******/
+    vdev->vec_procs = &escv_vector_procs;
+
+    code = gdev_vector_open_file_bbox(vdev, 512, true);
+    if (code < 0) return code;
+
+    gdev_vector_init(vdev);
+    pdev->first_page = true;
+
+    if(pdev->orientation){
+/*    pdev->Margins[1] = pdev->width - pdev->height + dev->HWMargins[0];
+ */
+      pdev->Margins[1] = (pdev->width - pdev->height) * \
+      X_DPI / vdev->x_pixels_per_inch;
+
+      width = dev->MediaSize[0];
+      height  = dev->MediaSize[1];
+      dev->MediaSize[0] = height;
+      dev->MediaSize[1] = width;
+    }
+
+    return 0;
+}
+
+
+/* Wrap up ("output") a page. */
+private int
+escv_output_page(gx_device * dev, int num_copies, int flush)
+{
+    gx_device_vector *const vdev = (gx_device_vector *) dev;
+    gx_device_escv *const pdev = (gx_device_escv *) dev;
+    stream *s = gdev_vector_stream(vdev);
+
+    /* 線幅,終端処理,接合部処理を初期化しておく */
+    lputs(s, ESC_GS "3;0;0lwG" ESC_GS "1;10mlG" ESC_FF);
+
+    sflush(s);
+    vdev->in_page = false;
+    pdev->first_page = false;
+
+    gdev_vector_reset(vdev);
+
+    return 0;
+}
+
+
+private int
+escv_close(gx_device *dev)
+{
+    gx_device_vector	*const vdev = (gx_device_vector *) dev;
+    FILE		*f = vdev->file;
+
+    /* 終了処理コードは決め打ち */
+    (void)fprintf(f, ESC_GS "rhE" "\033\001@EJL \012@EJL EJ \012\033\001@EJL \012");
+
+    gdev_vector_close_file(vdev);
+
+    return 0;
+}
+
+/* Close the device. */
+/* Note that if this is being called as a result of finalization, */
+/* the stream may no longer exist; but the file will still be open. */
+
+/* ---------------- Get/put parameters ---------------- */
+
+/* Get parameters. */
+private int
+escv_get_params(gx_device * dev, gs_param_list * plist)
+{
+    gx_device_escv	*const pdev = (gx_device_escv *) dev;
+    int			code;
+    int			ncode;
+
+    code = gdev_vector_get_params(dev, plist);
+    if (code < 0) return code;
+
+    if ((ncode = param_write_bool(plist, ESCPAGE_OPTION_MANUALFEED, &pdev->manualFeed)) < 0)
+	code = ncode;
+
+    if ((ncode = param_write_int(plist, ESCPAGE_OPTION_CASSETFEED, &pdev->cassetFeed)) < 0)
+	code = ncode;
+
+    if ((ncode = param_write_bool(plist, ESCPAGE_OPTION_RIT, &pdev->RITOff)) < 0)
+	code = ncode;
+
+    if ((ncode = param_write_bool(plist, ESCPAGE_OPTION_COLLATE, &pdev->Collate)) < 0)
+        code = ncode;
+
+    if ((ncode = param_write_int(plist, ESCPAGE_OPTION_TONERDENSITY, &pdev->toner_density)) < 0)
+        code = ncode;
+
+    if ((ncode = param_write_bool(plist, ESCPAGE_OPTION_LANDSCAPE, &pdev->orientation)) < 0)
+        code = ncode;
+
+    if ( param_write_bool(plist, ESCPAGE_OPTION_TONERSAVING, &pdev->toner_saving)< 0)
+        code = ncode;
+
+    if ((ncode = param_write_bool(plist, ESCPAGE_OPTION_DUPLEX, &pdev->Duplex)) < 0)
+	code = ncode;
+
+    if ((ncode = param_write_bool(plist, ESCPAGE_OPTION_DUPLEX_TUMBLE, &pdev->Tumble)) < 0)
+	code = ncode;
+
+    if ((ncode = param_write_bool(plist, ESCPAGE_OPTION_FACEUP, &pdev->faceup)) < 0)
+	code = ncode;
+
+    if ((ncode = param_write_int(plist, ESCPAGE_OPTION_MEDIATYPE, &pdev->MediaType)) < 0)
+	code = ncode;
+
+    return code;
+}
+
+
+/* Put parameters. */
+private int
+escv_put_params(gx_device * dev, gs_param_list * plist)
+{
+    gx_device_escv	*const pdev = (gx_device_escv *) dev;
+    int			ecode = 0;
+    int			code;
+    gs_param_name	param_name;
+    gs_param_string	pmedia;
+    bool		mf = pdev->manualFeed;
+    int			cass = pdev->cassetFeed;
+    bool		tum = pdev->Tumble;
+    bool		collate = pdev->Collate;
+    int			toner_density = pdev->toner_density;
+    bool		toner_saving = pdev->toner_saving;
+    bool		landscape = pdev->orientation;
+    bool		faceup = pdev->faceup;
+    bool		duplex = pdev->Duplex;
+    bool		RITOff = pdev->RITOff;
+    int			old_bpp = dev->color_info.depth;
+    int			bpp = 0;
+
+    if ((code = param_read_bool(plist, (param_name = ESCPAGE_OPTION_MANUALFEED), &mf)) < 0) {
+	param_signal_error(plist, param_name, ecode = code);
+    }
+    switch (code = param_read_int(plist, (param_name = ESCPAGE_OPTION_CASSETFEED), &cass)) {
+	case 0:
+	    if (cass < -1 || cass > 15)
+		ecode = gs_error_limitcheck;
+	    else
+		break;
+	    goto casse;
+	default:
+	    ecode = code;
+	  casse:param_signal_error(plist, param_name, ecode);
+	case 1:
+	    break;
+    }
+
+    if((code = param_read_bool(plist, (param_name = ESCPAGE_OPTION_COLLATE), &collate)) < 0) {
+	param_signal_error(plist, param_name, ecode = code);
+    }
+
+    if ((code = param_read_bool(plist, (param_name = ESCPAGE_OPTION_RIT), &RITOff)) < 0) {
+	param_signal_error(plist, param_name, ecode = code);
+    }
+
+    switch (code = param_read_string(plist, (param_name = ESCPAGE_OPTION_MEDIATYPE), &pmedia)) {
+	case 0:
+	    if (pmedia.size > ESCPAGE_MEDIACHAR_MAX)
+		ecode = gs_error_limitcheck;
+	    else {		/* Check the validity of ``MediaType'' characters */
+
+		if (strcmp(pmedia.data, "TRANS") == 0) {
+		    pdev->MediaType = 2;
+		} else if (strcmp(pmedia.data, "THICK") == 0) {
+		    pdev->MediaType = 1;
+		} else {
+		    ecode = gs_error_rangecheck;
+		    goto pmediae;
+		}
+	    }
+	    break;
+	    goto pmediae;
+	default:
+	    ecode = code;
+	  pmediae:param_signal_error(plist, param_name, ecode);
+	case 1:
+	  if(!pdev->MediaType){
+	    pdev->MediaType = 0;
+	    pmedia.data = 0;
+	  }
+	  break;
+    }
+
+    switch (code = param_read_int(plist,
+                                  (param_name = ESCPAGE_OPTION_TONERDENSITY), &toner_density)) {
+    case 0:
+            if (toner_density < 0 || toner_density > 5)
+                ecode = gs_error_rangecheck;
+            else
+                break;
+            goto tden;
+    default:
+	ecode = code;
+tden:
+	param_signal_error(plist, param_name, ecode);
+    case 1:
+	break;
+    }
+
+    switch (code = param_read_bool(plist, (param_name = ESCPAGE_OPTION_TONERSAVING), &toner_saving)) {
+    case 0:
+	break;
+    default:
+	if ((code = param_read_null(plist, param_name)) == 0) {
+	    break;
+	}
+	ecode = code;
+	param_signal_error(plist, param_name, ecode);
+    case 1:
+	break;   
+    }
+
+    if ((code = param_read_bool(plist, (param_name = ESCPAGE_OPTION_DUPLEX), &duplex)) < 0)
+	param_signal_error(plist, param_name, ecode = code);
+
+    if ((code = param_read_bool(plist, (param_name = ESCPAGE_OPTION_DUPLEX_TUMBLE), &tum)) < 0)
+	param_signal_error(plist, param_name, ecode = code);
+
+    if ((code = param_read_bool(plist, (param_name = ESCPAGE_OPTION_LANDSCAPE), &landscape)) < 0)
+	param_signal_error(plist, param_name, ecode = code);
+
+    if ((code = param_read_bool(plist, (param_name = ESCPAGE_OPTION_FACEUP), &faceup)) < 0) {
+	param_signal_error(plist, param_name, ecode = code);
+    }
+
+
+    switch (code = param_read_int(plist, (param_name = "BitsPerPixel"), &bpp)) {
+	case 0:
+	    if (bpp != 8 && bpp != 24)
+		ecode = gs_error_rangecheck;
+	    else
+		break;
+	    goto bppe;
+	default:
+	    ecode = code;
+	  bppe:param_signal_error(plist, param_name, ecode);
+	case 1:
+	    break;
+    }
+
+    if (bpp != 0) {
+	dev->color_info.depth = bpp;
+	dev->color_info.num_components = ((bpp == 8) ? 1 : 3);
+	dev->color_info.max_gray = (bpp > 8 ? 255 : 1000);
+	dev->color_info.max_color = (bpp > 8 ? 255 : 1000);
+	dev->color_info.dither_grays = (bpp > 8 ? 256 : 5);
+	dev->color_info.dither_colors = (bpp > 8 ? 256 : 2);
+	dev_proc(pdev, map_rgb_color) = ((bpp == 8) ? gx_default_gray_map_rgb_color : gx_default_rgb_map_rgb_color);
+	dev_proc(pdev, map_color_rgb) = ((bpp == 8) ? gx_default_gray_map_color_rgb : gx_default_rgb_map_color_rgb);
+    }
+
+    if (ecode < 0) return ecode;
+    code = gdev_vector_put_params(dev, plist);
+    if (code < 0) return code;
+
+    pdev->manualFeed = mf;
+    pdev->cassetFeed = cass;
+    pdev->faceup = faceup;
+    pdev->RITOff = RITOff;
+    pdev->orientation = landscape;
+    pdev->toner_density = toner_density;
+    pdev->toner_saving = toner_saving;
+    pdev->Collate = collate;
+    pdev->Duplex = duplex;
+    pdev->Tumble = tum;
+
+    if (bpp != 0 && bpp != old_bpp && pdev->is_open)
+	return gs_closedevice(dev);
+
+    return 0;
+}
+
+/* ---------------- Images ---------------- */
+
+
+private int
+escv_copy_mono(gx_device * dev, const byte * data,
+	int data_x, int raster, gx_bitmap_id id, int x, int y, int w, int h,
+	   gx_color_index zero, gx_color_index one)
+{
+    gx_device_escv *const	pdev = (gx_device_escv *) dev;
+    gx_device_vector *const	vdev = (gx_device_vector *) dev;
+    stream			*s = gdev_vector_stream(vdev);
+    gx_drawing_color		color;
+    int				code = 0;
+    gx_color_index		c_color = 0;
+    char			obuf[128];
+    int				depth = 1;
+#if ( 8 <= GS_VERSION_MAJOR )
+    /* FIXME! add for gs815 */
+    const gs_imager_state * pis = (const gs_imager_state *)0;
+#endif
+
+    if (id != gs_no_id && zero == gx_no_color_index && one != gx_no_color_index && data_x == 0) {
+	gx_drawing_color dcolor;
+
+	color_set_pure(&dcolor, one);
+	escv_setfillcolor(vdev,
+#if ( 8 <= GS_VERSION_MAJOR )
+			  pis,
+#endif
+			  &dcolor); /* FIXME! gs815 */
+    }
+
+    if (zero == gx_no_color_index) {
+
+        if (one == gx_no_color_index) return 0;
+	if (pdev->MaskState != 1) {
+	    lputs(s, ESC_GS "2;184wfE" ESC_GS "3;184wfE" ESC_GS "5;184wfE");
+            pdev->MaskState = 1;   
+        }	
+	c_color = one;
+
+    } else if (one == gx_no_color_index)
+	/* 1bit は透明 ビット反転・zero 色に染める */
+    {
+	if (pdev->MaskState != 1) {
+	    lputs(s, ESC_GS "3;184wfE" ESC_GS "5;184wfE");
+	    pdev->MaskState = 1;
+	}
+	c_color = zero;
+    } else if (one == vdev->white) {
+
+	if (pdev->MaskState != 0) {
+	    lputs(s, ESC_GS "3;204wfE" ESC_GS "5;204wfE");
+	    pdev->MaskState = 0;
+	}
+	c_color = zero;
+    } else {
+
+        if (pdev->MaskState != 1) {
+	    lputs(s, ESC_GS "3;184wfE" ESC_GS "5;184wfE");
+            pdev->MaskState = 1;
+        }
+	color_set_pure(&color, one);
+	code = gdev_vector_update_fill_color((gx_device_vector *) pdev,
+#if ( 8 <= GS_VERSION_MAJOR )
+					     pis,
+#endif
+					     &color);
+
+	/* ここを通過したら以下の色設定は無意味？ */
+    }
+    if (code < 0) return 0;
+
+    /* パターンＯＮ指定／ソリッドパターン指定 */
+    (void)sprintf(obuf, ESC_GS "1;2;3;%d;%d;%dfpE",
+		  (unsigned char)(c_color >> 16 & 0xff),
+		  (unsigned char)(c_color >> 8 & 0xff),
+		  (unsigned char)(c_color & 0xff));
+    lputs(s, obuf);
+
+    lputs(s, ESC_GS "5;2;1;0;0cpE");
+
+    escv_write_begin(dev, depth, (int)x, (int)y, w, h, w, h, 0);
+    {
+	int		i, j;
+	uint		width_bytes = (w + 7) >> 3;
+	uint		num_bytes = width_bytes * h; 
+
+	byte *buf = gs_alloc_bytes(vdev->memory, num_bytes, "escv_copy_mono(buf)");
+
+	if (data_x % 8 == 0) {
+	    for (i = 0; i < h; ++i) {
+		memcpy(buf + i * width_bytes, data + (data_x >> 3) + i * raster, width_bytes);
+	    }
+	} else {
+	    for (i = 0; i < h; ++i) {
+		for (j = 0; j < width_bytes; j++) {
+		    *(buf + i * width_bytes + j) =
+			*(data + (data_x >> 3) + i * raster + j) << (data_x % 8) |
+			*(data + (data_x >> 3) + i * raster + j + 1) >> (8 - data_x % 8);
+		}
+	    }
+	}
+
+	escv_write_data(dev, depth, buf, num_bytes, w, h);
+	gs_free_object(vdev->memory, buf, "escv_copy_mono(buf)");
+    }
+    escv_write_end(dev, depth);
+    return 0;
+}
+
+
+/* Copy a color bitmap. */
+private int
+escv_copy_color(gx_device * dev,
+		  const byte * data, int data_x, int raster, gx_bitmap_id id,
+		  int x, int y, int w, int h)
+{
+    gx_device_escv	*const pdev = (gx_device_escv *) dev;
+    gx_device_vector	*const vdev = (gx_device_vector *) dev;
+
+    stream		*s = gdev_vector_stream(vdev);
+    int			depth = dev->color_info.depth;
+    int			num_components = (depth < 24 ? 1 : 3);
+    uint		width_bytes = w * num_components;
+
+    if (pdev->MaskState != 0) {
+	lputs(s, ESC_GS "3;204wfE" ESC_GS "5;204wfE");
+	pdev->MaskState = 0;
+    }
+
+    escv_write_begin(dev, depth, (int)x, (int)y, w, h, w, h, 0);
+
+    {
+	int		i;
+	uint		num_bytes = width_bytes * h;
+	byte		*buf = gs_alloc_bytes(vdev->memory, num_bytes, "escv_copy_color(buf)");
+
+	for (i = 0; i < h; ++i) {
+	    memcpy(buf + i * width_bytes, data + ((data_x * depth) >> 3) + i * raster, width_bytes);
+	}
+
+	escv_write_data(dev, depth, buf, num_bytes, w, h);
+	gs_free_object(vdev->memory, buf, "escv_copy_color(buf)");
+    }
+
+    escv_write_end(dev, depth);
+    return 0;
+}
+
+
+/* Fill a mask. */
+private int
+escv_fill_mask(gx_device * dev,
+		 const byte * data, int data_x, int raster, gx_bitmap_id id,
+		 int x, int y, int w, int h,
+		 const gx_drawing_color * pdcolor, int depth,
+		 gs_logical_operation_t lop, const gx_clip_path * pcpath)
+{
+    gx_device_vector *vdev = (gx_device_vector *) dev;
+    gx_device_escv   *pdev = (gx_device_escv *)   dev;
+    stream           *s    = gdev_vector_stream(vdev);
+#if ( 8 <= GS_VERSION_MAJOR )
+    /* FIXME! add for gs815 */
+    const gs_imager_state * pis = (const gs_imager_state *)0;
+#endif
+
+    if (w <= 0 || h <= 0) return 0;
+    
+    if (depth > 1 ||
+	gdev_vector_update_fill_color(vdev,
+#if ( 8 <= GS_VERSION_MAJOR )
+				      pis,
+#endif
+				      pdcolor) < 0 ||
+	gdev_vector_update_clip_path(vdev, pcpath) < 0 ||
+	gdev_vector_update_log_op(vdev, lop) < 0
+	) 
+	return gx_default_fill_mask(dev, data, data_x, raster, id,
+				    x, y, w, h, pdcolor, depth, lop, pcpath);
+    
+#if 0
+    (*dev_proc(vdev->bbox_device, fill_mask))
+	((gx_device *) vdev->bbox_device, data, data_x, raster, id,
+	 x, y, w, h, pdcolor, depth, lop, pcpath);
+#endif
+
+    if (pdev->MaskState != 1) {
+
+	lputs(s, ESC_GS "3;184wfE" ESC_GS "5;184wfE");
+	pdev->MaskState = 1;
+    }
+
+    if (id != gs_no_id && data_x == 0 && depth == 1) {
+	char		obuf[128];
+	int		i;
+	uint		width_bytes = (w + 7) >> 3;
+	uint		num_bytes = width_bytes * h;
+	byte		*buf;
+
+	if (pdev -> id_cache[id & VCACHE] != id) {
+
+	    buf = gs_alloc_bytes(vdev->memory, num_bytes, "escv_fill_mask(buf)");
+
+	    /* cache entry */
+	    for (i = 0; i < h; ++i) {
+		memcpy(buf + i * width_bytes, data + (data_x >> 3) + i * raster, width_bytes);
+	    }
+
+	    (void)sprintf(obuf, ESC_GS "%d;%d;%d;%d;0db{F", num_bytes, (int)(id & VCACHE), w, h);
+	    lputs(s, obuf);
+	    put_bytes(s, buf, num_bytes);
+
+	    gs_free_object(vdev->memory, buf, "escv_fill_mask(buf)");
+	    pdev -> id_cache[id & VCACHE] = id;
+	}
+
+	(void)sprintf(obuf, ESC_GS "%dX" ESC_GS "%dY", x, y);
+	lputs(s, obuf);
+	(void)sprintf(obuf, ESC_GS "%lddbF", id & VCACHE);
+	lputs(s, obuf);
+
+	return 0;
+    }
+
+    escv_write_begin(dev, depth, (int)x, (int)y, w, h, w, h, 0);
+    {
+	int		i;
+	uint		width_bytes = (w + 7) >> 3;
+	uint		num_bytes = width_bytes * h;
+	byte		*buf = gs_alloc_bytes(vdev->memory, num_bytes, "escv_fill_mask(buf)");
+
+	for (i = 0; i < h; ++i) {
+	    memcpy(buf + i * width_bytes, data + (data_x >> 3) + i * raster, width_bytes);
+	}
+
+	escv_write_data(dev, depth, buf, num_bytes, w, h);
+	escv_write_end(dev, depth);
+	gs_free_object(vdev->memory, buf, "escv_fill_mask(buf)");
+    }
+
+    return 0;
+}
+
+/* ---------------- High-level images ---------------- */
+
+private image_enum_proc_plane_data(escv_image_plane_data);
+private image_enum_proc_end_image(escv_image_end_image);
+private const gx_image_enum_procs_t escv_image_enum_procs =
+{
+    escv_image_plane_data, escv_image_end_image
+};
+
+
+/* Start processing an image. */
+private int
+escv_begin_image(gx_device * dev,
+		 const gs_imager_state * pis, const gs_image_t * pim,
+		 gs_image_format_t format, const gs_int_rect * prect,
+		 const gx_drawing_color * pdcolor, const gx_clip_path * pcpath,
+		 gs_memory_t * mem, gx_image_enum_common_t **pinfo)
+{
+    gx_device_vector *const	vdev = (gx_device_vector *) dev;
+    gx_device_escv *const	pdev = (gx_device_escv *) dev;
+    stream			*s = gdev_vector_stream((gx_device_vector *) pdev);
+    gdev_vector_image_enum_t	*pie = 
+	gs_alloc_struct(mem, gdev_vector_image_enum_t, &st_vector_image_enum, "escv_begin_image");
+    const gs_color_space	*pcs = pim->ColorSpace;
+    gs_color_space_index	index;
+    int				num_components = 1;
+    bool can_do = prect == 0 &&
+      (pim->format == gs_image_format_chunky ||
+       pim->format == gs_image_format_component_planar);
+
+    gs_matrix			imat;
+    int				code;
+    int				ty, bx, by, cx, cy, dx, dy, sx, sy;
+
+    if (pie == 0) return_error(gs_error_VMerror);
+    pie->memory = mem;
+    code = gdev_vector_begin_image(vdev, pis, pim, format, prect,
+				   pdcolor, pcpath, mem, &escv_image_enum_procs, pie);
+    if (code < 0) return code;
+    
+    *pinfo = (gx_image_enum_common_t *) pie;
+
+    if (!pim->ImageMask) {
+	index = gs_color_space_get_index(pcs);
+	num_components = gs_color_space_num_components(pcs);
+
+	if (pim->CombineWithColor) {	    
+	    can_do = false;
+	} else {
+	    switch (index) {
+		case gs_color_space_index_DeviceGray:
+		    if ((pim->Decode[0] != 0 || pim->Decode[1] != 1)
+			&& (pim->Decode[0] != 1 || pim->Decode[1] != 0))
+			can_do = false;
+		    break;
+		case gs_color_space_index_DeviceRGB:
+		    if (pim->Decode[0] != 0 || pim->Decode[1] != 1 ||
+			pim->Decode[2] != 0 || pim->Decode[3] != 1 ||
+			pim->Decode[4] != 0)
+			can_do = false;
+		    break;
+		default:
+		    can_do = false;
+	    }
+	}
+    }
+    if (!can_do) {
+	return gx_default_begin_image(dev, pis, pim, format, prect,
+				      pdcolor, pcpath, mem, &pie->default_info);
+    }
+    
+    if (pim->ImageMask || (pim->BitsPerComponent == 1 && num_components == 1)) {
+	if (pim->Decode[0] > pim->Decode[1]) {
+	    pdev->MaskReverse = 1;
+	} else {
+	    lputs(s, ESC_GS "8;1;2;2;2plr{E");
+	    put_bytes(s, "\000\000\000\000\377\377\377\377", 8);
+	    pdev->MaskReverse = 0;
+	}
+    }
+
+    /* Write the image/colorimage/imagemask preamble. */
+    gs_matrix_invert(&pim->ImageMatrix, &imat);
+    gs_matrix_multiply(&imat, &ctm_only(pis), &imat);
+
+    ty = imat.ty;
+    bx = imat.xx * pim->Width + imat.yx * pim->Height + imat.tx;
+    by = imat.xy * pim->Width + imat.yy * pim->Height + imat.ty;
+    cx = imat.yx * pim->Height + imat.tx;
+    cy = imat.yy * pim->Height + imat.ty;
+    dx = imat.xx * pim->Width + imat.tx;
+    dy = imat.xy * pim->Width + imat.ty;
+
+    sx = bx - (int)imat.tx;
+    sy = by - (int)imat.ty;
+
+    /* とりあえず絵の位置に収まるように強制的に座標を変更する。 */
+    pdev -> roll = 0;
+    pdev -> reverse_x = pdev -> reverse_y = 0;
+    if (imat.tx > bx) {
+	pdev -> reverse_x = 1;
+	sx = -sx;
+	imat.tx = bx;
+    }
+
+    if (imat.ty > by) {
+	pdev -> reverse_y = 1;
+	sy = -sy;
+	imat.ty = by;
+    }
+
+    (void)memcpy(&pdev -> xmat, &imat, sizeof(gs_matrix));
+    pdev -> sx = sx;
+    pdev -> sy = sy;
+    pdev -> h = pim->Height;
+    pdev -> w = pim->Width;
+    pdev -> dd = 0;
+    pdev -> bx = 0;
+    pdev -> by = 0;
+
+    if (ty == cy) {
+	/* 回転時の描画については現在未実装。GS 側の機能を使用する */
+	return -1;
+    }
+
+    if (pim->ImageMask) {
+	pdev->ncomp = 1;
+
+	/* 描画論理設定命令 - 透過 */
+	if (pdev->MaskState != 1) {
+
+	    lputs(s, ESC_GS "3;184wfE" ESC_GS "5;184wfE");
+	    pdev->MaskState = 1;
+	}
+
+    } else {
+
+	/* 描画論理設定命令 - 白塗り */
+	if (pdev->MaskState != 0) {
+
+	    lputs(s, ESC_GS "3;204wfE" ESC_GS "5;204wfE");
+	    pdev->MaskState = 0;
+	}
+	pdev->ncomp = num_components;
+    }
+
+    if (pdev -> reverse_y) return 0;
+
+    escv_write_begin(dev, pie->bits_per_pixel, (int)imat.tx, (int)imat.ty, pie->width, pie->height, sx, sy, pdev -> roll);
+    
+    return 0;
+}
+
+
+/* Process the next piece of an image. */
+private int
+#if GS_VERSION_MAJOR >= 6
+escv_image_plane_data(gx_image_enum_common_t *info, const gx_image_plane_t *planes, int height, int *rows_used)
+#else
+escv_image_plane_data(gx_device *dev, gx_image_enum_common_t *info, const gx_image_plane_t *planes, int height)
+#endif
+{
+#if GS_VERSION_MAJOR >= 6
+    gx_device *dev = info->dev;
+#endif
+    gx_device_vector *const	vdev = (gx_device_vector *) dev;
+    gx_device_escv *const	pdev = (gx_device_escv *) dev;
+    gdev_vector_image_enum_t	*pie = (gdev_vector_image_enum_t *) info;
+
+    int				y;
+    int				plane;
+    int				width_bytes, tbyte;
+    byte			*buf;
+
+    if (pie->default_info) return gx_image_plane_data(pie->default_info, planes, height);
+
+    gx_image_plane_data(pie->bbox_info, planes, height);
+
+    {
+
+#if GS_VERSION_MAJOR >= 6
+	if (height == 260)
+	    height = 1;
+#endif
+	width_bytes = (pie->width * pie->bits_per_pixel / pdev->ncomp + 7) / 8 * pdev->ncomp;
+	tbyte = width_bytes * height;
+	buf = gs_alloc_bytes(vdev->memory, tbyte, "escv_image_data(buf)");
+
+	if (pdev -> reverse_y) {
+
+	    if (pdev -> h == height) {
+#if 1
+		if(tbyte == 1){
+		      pdev->w += pdev->sx / 2048;
+		      height  += pdev->sy / 2048;
+	        }
+#endif
+
+
+		escv_write_begin(dev, pie->bits_per_pixel, (int)pdev -> xmat.tx, (int)pdev -> xmat.ty, pdev -> w, height, (int)pdev -> sx, (int)pdev -> sy, pdev -> roll);
+
+	    } else {
+		float	yy, sy;
+
+		yy = (pdev -> h * pdev->xmat.yy) - (pdev -> dd * pdev -> xmat.yy) - (height * pdev -> xmat.yy);
+		if (yy == 0) {
+		    yy = (pdev -> h * pdev->xmat.yx) - (pdev -> dd * pdev -> xmat.yx) - (height * pdev -> xmat.yx);
+		}
+
+		if (pdev -> by) {
+		    sy = (int)pdev -> xmat.ty - (int)yy;
+		    sy = pdev -> by - (int)sy;
+		} else {
+		    sy = height * pdev -> xmat.yy + 0.5;
+		}
+		if (sy < 0) {
+		    sy = -sy;
+		}
+
+		escv_write_begin(dev, pie->bits_per_pixel, (int)pdev -> xmat.tx, (int)pdev -> xmat.ty - (int)yy, pdev -> w, height, (int)pdev -> sx, (int)sy, pdev -> roll);
+
+		pdev -> by = (int)pdev -> xmat.ty - (int)yy;
+	    }
+	}
+	pdev -> dd += height;
+
+	for (plane = 0; plane < pie->num_planes; ++plane) {
+
+	    for (y = 0; y < height; ++y) {
+
+		int     bit, w;
+		const byte *p;
+		byte *d;
+		byte c;
+
+                p = planes[plane].data + ((planes[plane].data_x * pie->bits_per_pixel) >> 3) + y * planes[plane].raster;
+		if (pdev -> reverse_y) {
+
+		    d = buf + (height - y) * width_bytes;
+
+		    if (!pdev -> reverse_x) {
+			(void)memcpy(buf + (height - y - 1) * width_bytes,
+				     planes[plane].data + ((planes[plane].data_x * pie->bits_per_pixel) >> 3)
+				     + y * planes[plane].raster, width_bytes);
+
+		    }
+
+		} else {
+
+		    d = buf + (y + 1) * width_bytes;
+
+		    if (!pdev -> reverse_x) {
+
+			(void)memcpy(buf + y * width_bytes,
+				     planes[plane].data + ((planes[plane].data_x * pie->bits_per_pixel) >> 3)
+				     + y * planes[plane].raster, width_bytes);
+
+		    }
+		}
+		if (pdev -> reverse_x) {
+		    if (pie->bits_per_pixel == 1) {
+			for (w = 0; w < width_bytes; w++) {
+			    c = 0;
+			    for (bit = 0; bit < 8; bit++) {
+				if (*p & 1 << (7 - bit)) {
+				    c |= 1 << bit;
+				}
+			    }
+			    p++;
+			    *--d = c;
+			}
+		    } else if (pie->bits_per_pixel == 8){
+			for (w = 0; w < width_bytes; w++) {
+			    *--d = *p++;
+			}
+		    } else {
+			for (w = 0; w < width_bytes / 3; w++) {
+			    *--d = *(p + 2);
+			    *--d = *(p + 1);
+			    *--d = *p;
+			    p += 3;
+			}
+		    }
+		}
+	    }
+	}
+
+#if 1
+	if(tbyte == 1){
+	    int t;
+	    gs_free_object(vdev->memory, buf, "esmv_image_data(buf)");
+	    if(pdev->sx > pdev->sy){
+	        tbyte = 1;
+	    } else {
+		if(pdev->sx < pdev->sy){
+	            tbyte = tbyte * height;
+  	        } else {
+	            tbyte = 1;
+	        }
+	    }
+	    buf = gs_alloc_bytes(vdev->memory, tbyte, "esmv_image_data(buf)");
+	    for(t = 0; t < tbyte; t++){
+	        buf[t] = 0x00;
+	    }
+	}
+#endif
+
+	escv_write_data(dev, pie->bits_per_pixel, buf, tbyte, pdev -> w, height);
+
+	if (pdev -> reverse_y) {
+	    escv_write_end(dev, pie->bits_per_pixel);
+	}
+
+	gs_free_object(vdev->memory, buf, "escv_image_data(buf)");
+    }
+    return (pie->y += height) >= pie->height;
+}
+
+
+private int
+#if GS_VERSION_MAJOR >= 6
+escv_image_end_image(gx_image_enum_common_t * info, bool draw_last)
+#else
+escv_image_end_image(gx_device *dev, gx_image_enum_common_t * info, bool draw_last)
+#endif
+{
+#if GS_VERSION_MAJOR >= 6
+    gx_device *dev = info->dev;
+#endif
+    gx_device_vector		*const vdev = (gx_device_vector *) dev;
+    gx_device_escv		*const pdev = (gx_device_escv *) dev;
+    gdev_vector_image_enum_t	*pie = (gdev_vector_image_enum_t *) info;
+    stream			*s = gdev_vector_stream((gx_device_vector *)pdev);
+    int				code;
+
+    if (!(pdev -> reverse_y)) {
+	escv_write_end(dev, pie->bits_per_pixel);
+    }
+
+    pdev->reverse_x = pdev->reverse_y = 0;
+    if (pdev->MaskReverse == 0) {
+	lputs(s, ESC_GS "8;1;2;2;2plr{E");
+	put_bytes(s, "\377\377\377\377\000\000\000\000", 8);
+    }
+    pdev->MaskReverse = -1;
+
+    code = gdev_vector_end_image(vdev, (gdev_vector_image_enum_t *) pie, draw_last, pdev->white);
+    return code;
+}
+
+
+private void escv_write_begin(gx_device *dev, int bits, int x, int y, int sw, int sh, int dw, int dh, int roll)
+{
+    gx_device_vector *const     vdev = (gx_device_vector *) dev;
+    gx_device_escv *const       pdev = (gx_device_escv *)dev;
+    stream			*s = gdev_vector_stream((gx_device_vector *)pdev);
+    char                        obuf[128], *tmp, *p;
+    int				i, comp;
+
+    (void)sprintf(obuf, ESC_GS "%dX" ESC_GS "%dY", x, y);
+    lputs(s, obuf);
+
+    comp = 0;
+
+    if (bits == 1) {
+	(void)sprintf(obuf, ESC_GS "2;201;1;%d;%d;%d;%d;%d;%dscrI", comp, sw, sh, dw, dh, roll);
+    } else if (bits == 4) {
+	if (pdev -> c4map) {
+	    /* カラーマップ登録 */
+	    lputs(s, ESC_GS "64;2;2;16;16plr{E");
+	    p = tmp = gs_alloc_bytes(vdev->memory, 64, "escv_write_begin(tmp4)");
+	    for (i = 0; i < 16; i++) {
+		*p++ = i << 4;
+		*p++ = i << 4;
+		*p++ = i << 4;
+		*p++ = i << 4;
+	    }
+	    put_bytes(s, tmp, 64);
+	    gs_free_object(vdev->memory, tmp, "escv_write_begin(tmp4)");
+	    pdev -> c4map = FALSE;
+	}
+	(void)sprintf(obuf, ESC_GS "2;203;2;%d;%d;%d;%d;%d;%dscrI", comp, sw, sh, dw, dh, roll);
+    } else if (bits == 8) {
+	if (pdev -> c8map) {
+	    /* カラーマップ登録 */
+	    lputs(s, ESC_GS "1024;4;2;256;256plr{E");
+	    p = tmp = gs_alloc_bytes(vdev->memory, 1024, "escv_write_begin(tmp)");
+	    for (i = 0; i < 256; i++) {
+		*p++ = i;
+		*p++ = i;
+		*p++ = i;
+		*p++ = i;
+	    }
+	    put_bytes(s, tmp, 1024);
+	    gs_free_object(vdev->memory, tmp, "escv_write_begin(tmp)");
+	    pdev -> c8map = FALSE;
+	}
+	(void)sprintf(obuf, ESC_GS "2;204;4;%d;%d;%d;%d;%d;%dscrI", comp, sw, sh, dw, dh, roll);
+    } else {
+	/* 24 bit */
+	(void)sprintf(obuf, ESC_GS "2;102;0;%d;%d;%d;%d;%d;%dscrI", comp, sw, sh, dw, dh, roll);
+    }    
+    lputs(s, obuf);
+
+    return;
+}
+
+
+private void escv_write_data(gx_device *dev, int bits, char *buf, int bsize, int w, int ras)
+{
+    gx_device_vector *const     vdev = (gx_device_vector *) dev;
+    gx_device_escv *const       pdev = (gx_device_escv *) dev;
+    stream			*s = gdev_vector_stream((gx_device_vector *)pdev);
+    char                        obuf[128];
+    int				size;
+    char			/**tmp,*/ *tmps, *p, tmp;
+
+    tmps = 0;
+    if (bits == 12) {
+	p = tmps = gs_alloc_bytes(vdev->memory, bsize * 2, "escv_write_data(tmp)");
+#if 0
+	for (size = 0; size < bsize; size++) {
+	    if((buf[size] & 0xF0) == 0xF0){
+	        *p++ = 0xFF;
+	    }else{
+	        *p++ = buf[size] & 0xF0;
+	    }
+	    if((buf[size] << 4 & 0xF0) == 0xF0){
+	        *p++ = 0xFF;
+	    }else{
+	        *p++ = buf[size] << 4;
+	    }
+	}
+#else
+	for (size = 0; size < bsize; size++) {
+	        tmp = buf[size] & 0xF0;
+	        *p++ = (tmp + (tmp >> 4 & 0x0F));
+	        tmp = buf[size] << 4;
+	        *p++ = (tmp + (tmp >> 4 & 0x0F));
+	}
+
+#endif
+	bsize = bsize * 2;
+	buf = tmps;
+    }
+
+    (void)sprintf(obuf, ESC_GS "%d;%dcu{I", bsize, ras);
+    lputs(s, obuf);
+    put_bytes(s, buf, bsize);
+
+    if (bits == 12) {
+      gs_free_object(vdev->memory, tmps, "escv_write_data(tmp)");
+    }
+    return;
+}
+
+
+private void escv_write_end(gx_device *dev, int bits)
+{
+    gx_device_escv *const       pdev = (gx_device_escv *) dev;
+    stream			*s = gdev_vector_stream((gx_device_vector *)pdev);
+
+    lputs(s, ESC_GS "ecrI");
+    return;
+}
+
+/* end of file */
diff -urN -x .svn espgs-8.15rc2/addons/eplaser/gdevescv.h trunk/addons/eplaser/gdevescv.h
--- espgs-8.15rc2/addons/eplaser/gdevescv.h	1970-01-01 01:00:00.000000000 +0100
+++ trunk/addons/eplaser/gdevescv.h	2005-03-14 00:03:53.460725419 +0100
@@ -0,0 +1,114 @@
+/* Copyright (C) EPSON SOFTWARE DEVELOPMENT LABORATORY, INC. 1999,2000.
+   Copyright (C) SEIKO EPSON CORPORATION 2000-2005.
+
+   Ghostscript printer driver for EPSON ESC/Page-Color
+
+   This software is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility
+   to anyone for the consequences of using it or for whether it serves any
+   particular purpose or works at all, unless he says so in writing.  Refer
+   to the GNU General Public License for full details.
+
+   Everyone is granted permission to copy, modify and redistribute
+   this software, but only under the conditions described in the GNU
+   General Public License.  A copy of this license is supposed to have been
+   given to you along with this software so you can know your rights and
+   responsibilities.  It should be in a file named COPYING.  Among other
+   things, the copyright notice and this notice must be preserved on all
+   copies.
+ */
+
+/* Common header file for ESC/Page-Color driver */
+
+#ifndef gdevescv_INCLUDED
+#define gdevescv_INCLUDED
+
+#ifdef  TRUE
+#error "TRUE is already defined."
+#else
+#define TRUE		1
+#endif
+
+#ifdef  FALSE
+#error "FALSE is already defined."
+#else
+#define FALSE		0
+#endif
+
+#define	GS		(0x1d)
+#define	ESC_GS		"\035"
+#define	ESC_FF		"\014"
+#define	ESC_CR		"\015"
+#define	ESC_LF		"\012"
+#define	ESC_BS		"\010"
+
+#define	POINT					72
+#define	MMETER_PER_INCH				25.4
+
+#define	ESCPAGE_DEFAULT_WIDTH			(4840)
+#define	ESCPAGE_DEFAULT_HEIGHT			(6896)
+
+#define	ESCPAGE_LEFT_MARGIN_DEFAULT		5. / (MMETER_PER_INCH / POINT)
+#define	ESCPAGE_BOTTOM_MARGIN_DEFAULT		5. / (MMETER_PER_INCH / POINT)
+#define	ESCPAGE_RIGHT_MARGIN_DEFAULT		5. / (MMETER_PER_INCH / POINT)
+#define	ESCPAGE_TOP_MARGIN_DEFAULT		5. / (MMETER_PER_INCH / POINT)
+
+#define NUM_OF_PAPER_TABLES                     24
+#define MAX_PAPER_SIZE_DELTA                    5
+
+struct node {
+    long		byte;
+    char		*buf;
+    struct node		*next;
+};  
+
+
+#define		BUFCHECK(x)		\
+	if (strlen(obuf) > x) {		\
+	    (void)fprintf(stderr, "overflow %d : LINE %d\n", strlen(obuf), __LINE__); \
+	}
+
+
+#define ESCPAGE_OPTION_MANUALFEED		"ManualFeed"		/* 用紙トレイ */
+#define ESCPAGE_OPTION_CASSETFEED		"Casset"		/* 給紙トレイ */
+#define ESCPAGE_OPTION_FACEUP			"FaceUp"		/* 排紙トレイ */
+#define ESCPAGE_OPTION_DUPLEX			"Duplex"		/* 両面印刷 */
+#define ESCPAGE_OPTION_DUPLEX_TUMBLE		"Tumble"		/* とじ方向 */
+#define ESCPAGE_OPTION_MEDIATYPE		"MediaType"		/* 紙種 */
+#define	ESCPAGE_OPTION_RIT			"RITOff"		/* RIT */
+#define	ESCPAGE_OPTION_LANDSCAPE		"Landscape"		/* LANDSCAPE */
+#define ESCPAGE_OPTION_TONERDENSITY		"TonerDensity"		/* トナー濃度 */
+#define ESCPAGE_OPTION_TONERSAVING		"TonerSaving"		/* トナーセーブ */
+#define ESCPAGE_OPTION_COLLATE			"Collate"		/* 部数印刷 */
+
+#define ESCPAGE_TUMBLE_DEFAULT			FALSE			/* Long age */
+#define ESCPAGE_RIT_DEFAULT			FALSE
+#define ESCPAGE_FACEUP_DEFAULT			FALSE
+#define ESCPAGE_FACEUP_DEFAULT			FALSE
+
+#define ESCPAGE_MEDIATYPE_DEFAULT		0			/* NORMAL */
+#define ESCPAGE_MEDIACHAR_MAX			32
+
+#define ESCPAGE_MANUALFEED_DEFAULT		FALSE
+#define ESCPAGE_CASSETFEED_DEFAULT		0
+
+#define	ESCPAGE_DPI_MIN				60
+#define	ESCPAGE_DPI_MAX				1200
+
+#define ESCPAGE_HEIGHT_MAX			( 1369 + MAX_PAPER_SIZE_DELTA )	/* A3PLUS */
+#define ESCPAGE_WIDTH_MAX			(  933 + MAX_PAPER_SIZE_DELTA )	/* A3PLUS */
+#define ESCPAGE_HEIGHT_MIN			(  419 - MAX_PAPER_SIZE_DELTA )	/* POSTCARD */
+#define ESCPAGE_WIDTH_MIN			(  279 - MAX_PAPER_SIZE_DELTA )	/* MON */
+
+#define EP_COMPRESS5				(5 << 16)
+#define EP_COMPRESS20				(20 << 16)
+#define EP_COMPRESS30				(30 << 16)
+
+#define RES1200					1200
+#define RES600					600
+#define JPN					TRUE
+#define ENG					FALSE
+
+#endif /* gdevescv_INCLUDED */
+
+/* end of file */
diff -urN -x .svn espgs-8.15rc2/addons/eplaser/gdevesmv.c trunk/addons/eplaser/gdevesmv.c
--- espgs-8.15rc2/addons/eplaser/gdevesmv.c	1970-01-01 01:00:00.000000000 +0100
+++ trunk/addons/eplaser/gdevesmv.c	2005-03-14 00:03:53.456725548 +0100
@@ -0,0 +1,2585 @@
+/* Copyright (C) SEIKO EPSON CORPORATION 2000-2005.
+
+   Ghostscript printer driver for EPSON ESC/Page
+
+   This software is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility
+   to anyone for the consequences of using it or for whether it serves any
+   particular purpose or works at all, unless he says so in writing.  Refer
+   to the GNU General Public License for full details.
+
+   Everyone is granted permission to copy, modify and redistribute
+   this software, but only under the conditions described in the GNU
+   General Public License.  A copy of this license is supposed to have been
+   given to you along with this software so you can know your rights and
+   responsibilities.  It should be in a file named COPYING.  Among other
+   things, the copyright notice and this notice must be preserved on all
+   copies.
+ */
+
+/* Vector Version of ESC/Page driver */
+
+/*
+   謝辞：大森紀人氏の gdevl4v.cを参考にさせてもらいました。 
+*/
+/*
+   ○Ghostscript 5.10/5.50 のバグについて
+
+   Ghostscript 5.10/5.50 の Vector driver の setlinewidth 関数には
+   バグがあります。本来スケールが変更されるにしたがって線の太さも変更され
+   なければなりませんが、Ghostscript 5.10/5.50 ではスケールを考慮するのを
+   忘れています。
+   このドライバはそのバグを回避するためにスケールを自分で処理しています。
+
+ */
+
+#if ( 6 > GS_VERSION_MAJOR )
+
+#include <string.h>
+
+#include "math_.h"
+#include "gx.h"
+#include "gserrors.h"
+#include "gsmatrix.h"
+#include "gsparam.h"
+#include "gxdevice.h"
+#include "gscspace.h"
+#include "gsutil.h"
+#include "gdevvec.h"
+#include "gdevpstr.h"
+#include "ghost.h"
+#include "gzstate.h"
+#include "imemory.h"
+#include "igstate.h"
+#include "gdevescv.h"
+#include "gspath.h"
+#include "gzpath.h"
+
+#else /* 6 <= GS_VERSION_MAJOR */
+
+#include <stdlib.h>		/* for abs() */
+#include "math_.h"
+#include "memory_.h"
+#include "gx.h"
+#include "gserrors.h"
+#include "gzpath.h"
+#include "gxdevice.h"
+#include "gdevvec.h"
+#include "gdevescv.h"
+
+#if ( 7 >= GS_VERSION_MAJOR )
+#include "gscspace.h"
+#endif
+
+#endif /* GS_VERSION_MAJOR */
+
+/* ---------------- Device definition ---------------- */
+
+/* Device procedures */
+private dev_proc_open_device(esmv_open);
+private dev_proc_output_page(esmv_output_page);
+private dev_proc_close_device(esmv_close);
+private dev_proc_copy_mono(esmv_copy_mono);
+private dev_proc_copy_color(esmv_copy_color);
+private dev_proc_put_params(esmv_put_params);
+private dev_proc_get_params(esmv_get_params);
+private dev_proc_fill_mask(esmv_fill_mask);
+private dev_proc_begin_image(esmv_begin_image);
+
+
+#define	X_DPI		600
+#define	Y_DPI		600
+
+typedef struct gx_device_esmv_s {
+    gx_device_vector_common;
+
+    bool		manualFeed;			/* Use manual feed */ 
+    int			cassetFeed;			/* Input Casset */ 
+    bool		RITOff;				/* RIT Control */
+    bool		Collate;			/* 印刷部数 */
+    int			toner_density;			/* トナー濃度 */
+    bool		toner_saving;			/* トナーセーブ */
+    int			prev_paper_size;
+    int			prev_paper_width;
+    int			prev_paper_height;
+    int			prev_num_copies;		/* */
+    int			prev_feed_mode;
+    int			orientation;			/* 方向 */
+    bool		faceup;				/* フェイス指定 */
+    int	                MediaType;			/* 紙種 */
+    bool		first_page;
+    bool		Duplex;				/* 両面印刷 */
+    bool		Tumble;				/* とじ方向 */
+    int			ncomp;				/* */
+    int			MaskReverse;			/* 反転処理 */
+    int			MaskState;			/* */
+    bool		c4map;				/* 4bit ColorMap */
+    bool		c8map;				/* 8bit ColorMap */
+    int			prev_x;
+    int			prev_y;
+    gx_color_index	prev_color;
+    gx_color_index	current_color;			/* Current Color */
+    floatp		lwidth;
+    long		cap;
+    long		join;
+    long		reverse_x;
+    long		reverse_y;
+    gs_matrix		xmat;
+    int			bx, by;
+    int			w, h;
+    int			roll;
+    float		sx, sy;
+    long		dd;
+} gx_device_esmv;
+
+
+gs_public_st_suffix_add0_final(st_device_esmv, gx_device_esmv,
+      "gx_device_esmv", device_esmv_enum_ptrs, device_esmv_reloc_ptrs,
+			       gx_device_finalize, st_device_vector);
+
+#define esmv_device_full_body(dtype, pprocs, dname, stype, w, h, xdpi, ydpi, \
+			      ncomp, depth, mg, mc, dg, dc, lm, bm, rm, tm)\
+        std_device_part1_(dtype, pprocs, dname, stype, open_init_closed),\
+        dci_values(ncomp, depth, mg, mc, dg, dc),\
+        std_device_part2_(w, h, xdpi, ydpi),\
+	offset_margin_values(-lm * xdpi / 72.0, -tm * ydpi / 72.0, 5.0 / (MMETER_PER_INCH / POINT), 0, 0, 5.0 / (MMETER_PER_INCH / POINT)), /* LPD.2.  041203 saito */\
+        std_device_part3_()
+
+
+#define esmv_device_body(name)	\
+  esmv_device_full_body(gx_device_esmv, 0, name, \
+				&st_device_esmv,\
+/* width & height */		ESCPAGE_DEFAULT_WIDTH, ESCPAGE_DEFAULT_HEIGHT,\
+/* default resolution */	X_DPI, Y_DPI,\
+/* color info */		1, 8, 255, 255, 256, 256,\
+				ESCPAGE_LEFT_MARGIN_DEFAULT,\
+				ESCPAGE_BOTTOM_MARGIN_DEFAULT,\
+				ESCPAGE_RIGHT_MARGIN_DEFAULT,\
+				ESCPAGE_TOP_MARGIN_DEFAULT)
+
+#define esmv_procs	\
+{\
+	esmv_open,				/* open_device */\
+	gx_default_get_initial_matrix,		/* get_initial_matrix */\
+	NULL,					/* sync_output */\
+	esmv_output_page,			/* output_page */\
+	esmv_close,				/* close_device */\
+/*	gx_default_rgb_map_rgb_color, */	/* map_rgb_color */\
+        gx_default_gray_map_rgb_color,\
+/*      gx_default_rgb_map_color_rgb, */	/* map_color_rgb */\
+	gx_default_gray_map_color_rgb,\
+	gdev_vector_fill_rectangle,		/* fill_rectangle */\
+	NULL,					/* tile_rectangle */\
+	esmv_copy_mono,				/* dev_t_proc_copy_mono */\
+	esmv_copy_color,			/* dev_t_proc_copy_color */\
+	NULL,					/* draw_line */\
+	NULL,					/* get_bits */\
+	esmv_get_params,			/* dev_t_proc_get_params */\
+	esmv_put_params,			/* dev_t_proc_put_params */\
+	NULL,					/* map_cmyk_color */\
+	NULL,					/* get_xfont_procs */\
+	NULL,					/* get_xfont_device */\
+	NULL,					/* map_rgb_alpha_color */\
+	gx_page_device_get_page_device,		/* dev_t_proc_get_page_device */\
+	NULL,					/* get_alpha_bits */\
+	NULL,					/* copy_alpha */\
+	NULL,					/* get_band */\
+	NULL,					/* copy_rop */\
+	gdev_vector_fill_path,			/* fill_path */\
+	gdev_vector_stroke_path,		/* stroke_path */\
+	esmv_fill_mask,				/* fill_mask */\
+	gdev_vector_fill_trapezoid,		/* fill_trapezoid */\
+	gdev_vector_fill_parallelogram,		/* fill_parallelogram */\
+	gdev_vector_fill_triangle,		/* fill_triangle */\
+	NULL,	/****** WRONG ******/		/* draw_thin_line */\
+	esmv_begin_image,			/* begin_image */\
+	NULL,					/* image_data */\
+	NULL,					/* end_image */\
+	NULL,					/* strip_tile_rectangle */\
+	NULL					/******strip_copy_rop******/\
+}
+
+
+#define	esmv_init_code			\
+    vector_initial_values,\
+    ESCPAGE_MANUALFEED_DEFAULT,\
+    ESCPAGE_CASSETFEED_DEFAULT,\
+    ESCPAGE_RIT_DEFAULT,		/* RIT */\
+    FALSE,				/* Collate */\
+    0,					/* toner_density */\
+    FALSE,				/* toner_saving */\
+    0, 0, 0, 0, -1,\
+    0,					/* orientation */\
+    ESCPAGE_FACEUP_DEFAULT,\
+    ESCPAGE_MEDIATYPE_DEFAULT,\
+    0,					/* first_page */\
+    0,					/* Duplex */\
+    ESCPAGE_TUMBLE_DEFAULT,\
+    0,					/* ncomp */\
+    0,					/* MaskReverse */\
+    0,					/* MaskState */\
+    TRUE,				/* 4bits Color Map */\
+    TRUE,				/* 8bits Color Map */\
+    0,					/* prev_x */\
+    0,					/* prev_y */\
+    0,					/* prev_color */\
+    0,					/* current_color */\
+    3,					/* lwidth */\
+    0,					/* cap */\
+    3,					/* join */\
+    0,0,				/* reverse x, y */\
+    {0,}, 				/* matrix */\
+    0,0,				/* x, y */\
+    0,0,				/* width, hight */\
+    0,					/* roll */\
+    0,0,				/* scale x, y */\
+    0					/* */
+
+
+gx_device_esmv far_data gs_lp9200b_device =
+{
+    esmv_device_body("lp9200b"),
+    esmv_procs,
+    esmv_init_code
+};
+
+gx_device_esmv far_data gs_lp9000b_device =
+{
+    esmv_device_body("lp9000b"),
+    esmv_procs,
+    esmv_init_code
+};
+
+gx_device_esmv far_data gs_lp2500_device =
+{
+    esmv_device_body("lp2500"),
+    esmv_procs,
+    esmv_init_code
+};
+
+gx_device_esmv far_data gs_lp9100_device =
+{
+    esmv_device_body("lp9100"),
+    esmv_procs,
+    esmv_init_code
+};
+
+gx_device_esmv far_data gs_lp7900_device =
+{
+    esmv_device_body("lp7900"),
+    esmv_procs,
+    esmv_init_code
+};
+
+gx_device_esmv far_data gs_lp7500_device =
+{
+    esmv_device_body("lp7500"),
+    esmv_procs,
+    esmv_init_code
+};
+
+gx_device_esmv far_data gs_lp2400_device =
+{
+    esmv_device_body("lp2400"),
+    esmv_procs,
+    esmv_init_code
+};
+
+gx_device_esmv far_data gs_lp8900_device =
+{
+    esmv_device_body("lp8900"),
+    esmv_procs,
+    esmv_init_code
+};
+
+gx_device_esmv far_data gs_lp7700_device =
+{
+    esmv_device_body("lp7700"),
+    esmv_procs,
+    esmv_init_code
+};
+
+gx_device_esmv far_data gs_lp2200_device =
+{
+    esmv_device_body("lp2200"),
+    esmv_procs,
+    esmv_init_code
+};
+
+gx_device_esmv far_data gs_lp9400_device =
+{
+    esmv_device_body("lp9400"),
+    esmv_procs,
+    esmv_init_code
+};
+
+gx_device_esmv far_data gs_lp8700_device =
+{
+    esmv_device_body("lp8700"),
+    esmv_procs,
+    esmv_init_code
+};
+
+gx_device_esmv far_data gs_lp8100_device =
+{
+    esmv_device_body("lp8100"),
+    esmv_procs,
+    esmv_init_code
+};
+
+gx_device_esmv far_data gs_lp1800_device =
+{
+    esmv_device_body("lp1800"),
+    esmv_procs,
+    esmv_init_code
+};
+
+gx_device_esmv far_data gs_lp9600_device =
+{
+    esmv_device_body("lp9600"),
+    esmv_procs,
+    esmv_init_code
+};
+
+gx_device_esmv far_data gs_lp9300_device =
+{
+    esmv_device_body("lp9300"),
+    esmv_procs,
+    esmv_init_code
+};
+
+gx_device_esmv far_data gs_lp8600_device =
+{
+    esmv_device_body("lp8600"),
+    esmv_procs,
+    esmv_init_code
+};
+
+gx_device_esmv far_data gs_lp8600f_device =
+{
+    esmv_device_body("lp8600f"),
+    esmv_procs,
+    esmv_init_code
+};
+
+gx_device_esmv far_data gs_lp8400f_device =
+{
+    esmv_device_body("lp8400f"),
+    esmv_procs,
+    esmv_init_code
+};
+
+gx_device_esmv far_data gs_lp8300f_device =
+{
+    esmv_device_body("lp8300f"),
+    esmv_procs,
+    esmv_init_code
+};
+
+gx_device_esmv far_data gs_lp1900_device =
+{
+    esmv_device_body("lp1900"),
+    esmv_procs,
+    esmv_init_code
+};
+
+gx_device_esmv far_data gs_lp9600s_device =
+{
+    esmv_device_body("lp9600s"),
+    esmv_procs,
+    esmv_init_code
+};
+
+gx_device_esmv far_data gs_epl6100_device =
+{
+    esmv_device_body("epl6100"),
+    esmv_procs,
+    esmv_init_code
+};
+
+gx_device_esmv far_data gs_epl6200_device =
+{
+    esmv_device_body("epl6200"),
+    esmv_procs,
+    esmv_init_code
+};
+
+gx_device_esmv far_data gs_epl5900_device =
+{
+    esmv_device_body("epl5900"),
+    esmv_procs,
+    esmv_init_code
+};
+
+gx_device_esmv far_data gs_epl5800_device =
+{
+    esmv_device_body("epl5800"),
+    esmv_procs,
+    esmv_init_code
+};
+
+gx_device_esmv far_data gs_epl2050_device =
+{
+    esmv_device_body("epl2050"),
+    esmv_procs,
+    esmv_init_code
+};
+
+gx_device_esmv far_data gs_epl2050p_device =
+{
+    esmv_device_body("epl2050p"),
+    esmv_procs,
+    esmv_init_code
+};
+
+gx_device_esmv far_data gs_epl2120_device =
+{
+    esmv_device_body("epl2120"),
+    esmv_procs,
+    esmv_init_code
+};
+
+gx_device_esmv far_data gs_epl2500_device =
+{
+    esmv_device_body("epl2500"),
+    esmv_procs,
+    esmv_init_code
+};
+
+gx_device_esmv far_data gs_epl2750_device =
+{
+    esmv_device_body("epl2750"),
+    esmv_procs,
+    esmv_init_code
+};
+
+
+#if ( 6 > GS_VERSION_MAJOR )
+/* Vector device implementation */
+private int esmv_beginpage(P1(gx_device_vector * vdev));
+private int esmv_setfillcolor(P2(gx_device_vector * vdev, const gx_drawing_color * pdc));
+private int esmv_setstrokecolor(P2(gx_device_vector * vdev, const gx_drawing_color * pdc));
+private int esmv_setdash(P4(gx_device_vector * vdev, const float *pattern, 
+			      uint count, floatp offset));
+private int esmv_setflat(P2(gx_device_vector * vdev, floatp flatness));
+private int esmv_setlogop(P3(gx_device_vector * vdev, gs_logical_operation_t lop, 
+			       gs_logical_operation_t diff));
+private int esmv_vector_dorect(gx_device_vector * vdev, fixed x0, fixed y0, fixed x1,
+			       fixed y1, gx_path_type_t type);
+private int esmv_vector_dopath(gx_device_vector * vdev, const gx_path * ppath,
+			       gx_path_type_t type);
+private int esmv_beginpath(P2(gx_device_vector * vdev, gx_path_type_t type));
+private int esmv_moveto(P6(gx_device_vector * vdev, floatp x0, floatp y0,
+			   floatp x, floatp y, gx_path_type_t type));
+private int esmv_lineto(P6(gx_device_vector * vdev, floatp x0, floatp y0,
+			   floatp x, floatp y, gx_path_type_t type));
+private int esmv_curveto(P10(gx_device_vector * vdev, floatp x0, floatp y0,
+			       floatp x1, floatp y1, floatp x2, floatp y2,
+			       floatp x3, floatp y3, gx_path_type_t type));
+private int esmv_closepath(P6(gx_device_vector * vdev, floatp x, floatp y,
+				floatp x_start, floatp y_start, gx_path_type_t type));
+
+private int esmv_endpath(P2(gx_device_vector * vdev, gx_path_type_t type));
+private int esmv_setlinewidth(gx_device_vector * vdev, floatp width);
+private int esmv_setlinecap(gx_device_vector * vdev, gs_line_cap cap);
+private int esmv_setlinejoin(gx_device_vector * vdev, gs_line_join join);
+private int esmv_setmiterlimit(gx_device_vector * vdev, floatp limit);
+
+#else /* 6 <= GS_VERSION_MAJOR */
+
+/* Page management */
+private int esmv_beginpage (gx_device_vector * vdev);
+/* Imager state */
+private int esmv_setlinewidth (gx_device_vector * vdev, floatp width);
+private int esmv_setlinecap (gx_device_vector * vdev, gs_line_cap cap);
+private int esmv_setlinejoin (gx_device_vector * vdev, gs_line_join join);
+private int esmv_setmiterlimit (gx_device_vector * vdev, floatp limit);
+private int esmv_setdash (gx_device_vector * vdev, const float *pattern,
+		    uint count, floatp offset);
+private int esmv_setflat (gx_device_vector * vdev, floatp flatness);
+private int esmv_setlogop (gx_device_vector * vdev, gs_logical_operation_t lop,
+		     gs_logical_operation_t diff);
+/* Other state */
+#if ( 8 <= GS_VERSION_MAJOR )
+private bool esmv_can_handle_hl_color (gx_device_vector * vdev, const gs_imager_state * pis,
+                         const gx_drawing_color * pdc);
+private int esmv_setfillcolor (gx_device_vector * vdev, const gs_imager_state * pis, 
+                         const gx_drawing_color * pdc);
+private int esmv_setstrokecolor (gx_device_vector * vdev, const gs_imager_state * pis,
+                           const gx_drawing_color * pdc);
+#else
+private int esmv_setfillcolor (gx_device_vector * vdev, const gx_drawing_color * pdc);
+private int esmv_setstrokecolor (gx_device_vector * vdev, const gx_drawing_color * pdc);
+#endif
+/* Paths */
+/* dopath and dorect are normally defaulted */
+private int esmv_vector_dopath (gx_device_vector * vdev, const gx_path * ppath,
+		   gx_path_type_t type, const gs_matrix *pmat);
+private int esmv_vector_dorect (gx_device_vector * vdev, fixed x0, fixed y0, fixed x1,
+		   fixed y1, gx_path_type_t type);
+private int esmv_beginpath (gx_device_vector * vdev, gx_path_type_t type);
+private int esmv_moveto (gx_device_vector * vdev, floatp x0, floatp y0,
+		   floatp x, floatp y, gx_path_type_t type);
+private int esmv_lineto (gx_device_vector * vdev, floatp x0, floatp y0,
+		   floatp x, floatp y, gx_path_type_t type);
+private int esmv_curveto (gx_device_vector * vdev, floatp x0, floatp y0,
+		    floatp x1, floatp y1, floatp x2, floatp y2,
+		    floatp x3, floatp y3, gx_path_type_t type);
+private int esmv_closepath (gx_device_vector * vdev, floatp x0, floatp y0,
+		      floatp x_start, floatp y_start, gx_path_type_t type);
+private int esmv_endpath (gx_device_vector * vdev, gx_path_type_t type);
+
+#endif /* GS_VERSION_MAJOR */
+
+private const gx_device_vector_procs esmv_vector_procs =
+{
+	/* Page management */
+    esmv_beginpage,
+	/* Imager state */
+    esmv_setlinewidth,
+    esmv_setlinecap,
+    esmv_setlinejoin,
+    esmv_setmiterlimit,
+    esmv_setdash,
+    esmv_setflat,
+    esmv_setlogop,
+	/* Other state */
+#if ( 8 <= GS_VERSION_MAJOR )
+    esmv_can_handle_hl_color,	/* add gs815 */
+#endif
+    esmv_setfillcolor,	/* fill & stroke colors are the same */
+    esmv_setstrokecolor,
+	/* Paths */
+    esmv_vector_dopath,
+    esmv_vector_dorect,
+    esmv_beginpath,
+    esmv_moveto,
+    esmv_lineto,
+    esmv_curveto,
+    esmv_closepath,
+    esmv_endpath
+};
+
+private void esmv_write_begin(gx_device *, int, int, int, int, int, int, int, int);
+private void esmv_write_data(gx_device *, int, char *, int, int, int);
+private void esmv_write_end(gx_device *, int);
+
+
+/* ---------------- Utilities ---------------- */
+
+/* Put a string on a stream.
+   This function is copy of `pputs' in gdevpstr.c */
+private int
+lputs(stream * s, const char *str)
+{
+    uint	len = strlen(str);
+    uint	used;
+    int		status;
+
+    status = sputs(s, (const byte *)str, len, &used);
+
+    return (status >= 0 && used == len ? 0 : EOF);
+}
+
+/* Write a string on a stream. */
+private void
+put_bytes(stream * s, const byte * data, uint count)
+{
+    uint used;
+
+    sputs(s, data, count, &used);
+}
+
+
+private int
+esmv_range_check(gx_device * dev)
+{
+    int width = dev->MediaSize[0];
+    int height = dev->MediaSize[1];
+    int xdpi = dev->x_pixels_per_inch;
+    int ydpi = dev->y_pixels_per_inch;
+
+    /* Paper Size Check */
+    if (width <= height) {	/* portrait */
+      if ((width < ESCPAGE_WIDTH_MIN ||
+	   width > ESCPAGE_WIDTH_MAX ||
+	   height < ESCPAGE_HEIGHT_MIN ||
+	   height > ESCPAGE_HEIGHT_MAX)) {
+	return_error(gs_error_rangecheck);
+      }
+    } else {			/* landscape */
+      if ((width < ESCPAGE_HEIGHT_MIN ||
+	   width > ESCPAGE_HEIGHT_MAX ||
+	   height < ESCPAGE_WIDTH_MIN ||
+	   height > ESCPAGE_WIDTH_MAX )) {
+	return_error(gs_error_rangecheck);
+      }
+    }
+
+    /* Resolution Check */
+    if (xdpi != ydpi) {
+      return_error(gs_error_rangecheck);
+    }
+
+    if ((xdpi < ESCPAGE_DPI_MIN ||
+	 xdpi > ESCPAGE_DPI_MAX)) {
+      return_error(gs_error_rangecheck);
+    }
+
+    return 0;			/* pass */
+}
+
+
+/* ---------------- Vector device implementation ---------------- */
+
+private int
+esmv_vector_dopath(gx_device_vector * vdev, const gx_path * ppath,
+		   gx_path_type_t type
+#if ( 6 <= GS_VERSION_MAJOR )
+		   , const gs_matrix *pmat
+#endif
+		   )
+{
+    bool do_close = (type & gx_path_type_stroke) != 0;
+    gs_fixed_rect rect;
+    gs_point scale;
+    double x_start = 0, y_start = 0, x_prev = 0, y_prev = 0;
+    bool first = true;
+    gs_path_enum cenum;
+    int code;
+
+    stream	*s = gdev_vector_stream(vdev);
+    char	obuf[128];
+
+    if (gx_path_is_rectangle(ppath, &rect))
+	return (*vdev_proc(vdev, dorect)) (vdev, rect.p.x, rect.p.y, rect.q.x, rect.q.y, type);
+    scale = vdev->scale;
+    code = (*vdev_proc(vdev, beginpath)) (vdev, type);
+    gx_path_enum_init(&cenum, ppath);
+
+    for (;;) {
+	double	x, y;
+	fixed	vs[6];
+	int	pe_op, cnt;
+	const segment *pseg;
+
+
+	pe_op = gx_path_enum_next(&cenum, (gs_fixed_point *) vs);
+
+      sw:switch (pe_op) {
+	    case 0:		/* done */
+		return (*vdev_proc(vdev, endpath)) (vdev, type);
+
+	    case gs_pe_moveto:
+		x = fixed2float(vs[0]) / scale.x;
+		y = fixed2float(vs[1]) / scale.y;
+
+		/* サブパス開始命令 p1 */
+		(void)sprintf(obuf, ESC_GS "0;%d;%dmvpG", (int)x, (int)y);
+		lputs(s, obuf);
+
+		if (first)
+		    x_start = x, y_start = y, first = false;
+		break;
+
+	    case gs_pe_lineto:
+		cnt = 1;
+		for (pseg = cenum.pseg; pseg != 0 && pseg->type == s_line; cnt++, pseg = pseg->next);
+
+		(void)sprintf(obuf, ESC_GS "0;%d", cnt);
+		lputs(s, obuf);
+
+		do {
+		    (void)sprintf(obuf, ";%d;%d", (int)(fixed2float(vs[0]) / scale.x), (int)(fixed2float(vs[1]) / scale.y));
+		    lputs(s, obuf);
+
+		    pe_op = gx_path_enum_next(&cenum, (gs_fixed_point *) vs);
+		} while (pe_op == gs_pe_lineto);
+
+		/* パス・ポリライン命令 */
+		lputs(s, "lnpG");
+
+		goto sw;
+
+	    case gs_pe_curveto:
+		cnt = 1;
+		for (pseg = cenum.pseg; pseg != 0 && pseg->type == s_curve; cnt++, pseg = pseg->next);
+		(void)sprintf(obuf, ESC_GS "0;%d", cnt * 3);
+		lputs(s, obuf);
+
+		do {
+		    (void)sprintf(obuf, ";%d;%d;%d;%d;%d;%d",
+				  (int)(fixed2float(vs[0]) / scale.x), (int)(fixed2float(vs[1]) / scale.y),
+				  (int)(fixed2float(vs[2]) / scale.x), (int)(fixed2float(vs[3]) / scale.y),
+				  (int)(fixed2float(vs[4]) / scale.x), (int)(fixed2float(vs[5]) / scale.y));
+		    lputs(s, obuf);
+
+		    pe_op = gx_path_enum_next(&cenum, (gs_fixed_point *) vs);
+		} while (pe_op == gs_pe_curveto);
+
+		/* ベジェ曲線 */
+		lputs(s, "bzpG");
+
+		goto sw;
+
+	    case gs_pe_closepath:
+		x = x_start, y = y_start;
+		if (do_close) {
+		    lputs(s, ESC_GS "clpG");
+		    break;
+		}
+
+		pe_op = gx_path_enum_next(&cenum, (gs_fixed_point *) vs);
+		if (pe_op != 0) {
+		    lputs(s, ESC_GS "clpG");
+
+		    if (code < 0)
+			return code;
+		    goto sw;
+		}
+		return (*vdev_proc(vdev, endpath)) (vdev, type);
+	    default:		/* can't happen */
+		return_error(gs_error_unknownerror);
+	}
+	if (code < 0)
+	    return code;
+	x_prev = x, y_prev = y;
+    }
+}
+
+
+private int
+esmv_vector_dorect(gx_device_vector * vdev, fixed x0, fixed y0, fixed x1,
+		   fixed y1, gx_path_type_t type)
+{
+    int		code;
+    char	obuf[128];
+    gs_point	scale;
+    stream	*s = gdev_vector_stream(vdev);
+
+    code = (*vdev_proc(vdev, beginpath))(vdev, type);
+    if (code < 0)
+	return code;
+
+    scale = vdev->scale;
+
+    (void)sprintf(obuf, ESC_GS "0;%d;%d;%d;%d;0;0rrpG", (int)(fixed2float(x0) / scale.x), (int)(fixed2float(y0) / scale.y), (int)(fixed2float(x1) / scale.x), (int)(fixed2float(y1) / scale.y));
+    lputs(s, obuf);
+
+#if 0
+    /* Ghostscript 側のバグで closepath を呼んでいないので処理を会わせる。 */
+
+    /* 本来は (*vdev_proc(vdev, closepath))() を呼ぶべき */
+    lputs(s, ESC_GS "clpG");
+#endif
+
+    return (*vdev_proc(vdev, endpath))(vdev, type);
+}
+
+
+/* ---------- */
+
+
+typedef struct {
+    int		width;			/* paper width (unit: point) */
+    int		height;			/* paper height (unit: point) */
+    int		escpage;		/* number of papersize in ESC/PAGE */
+  const char	*name;			/* Paper Name */
+} EPaperTable;
+
+private const EPaperTable ePaperTable[NUM_OF_PAPER_TABLES] =
+{
+    {933, 1369, 72, "A3PLUS"},		/* A3 NOBI */
+    {842, 1191, 13, "A3"},		/* A3 */
+    {595, 842, 14, "A4"},		/* A4 */
+    {420, 595, 15, "A5"},		/* A5 */
+    {709, 1001, 24, "B4"},		/* B4 */
+    {729, 1032, 24, "B4"},		/* B4 JIS */
+    {516, 729, 25, "B5"},		/* B5 JIS */
+    {612, 792, 30, "LT"},		/* Letter */
+    {396, 612, 31, "HLT"},		/* Half Letter */
+    {612, 1008, 32, "LGL"},		/* Legal */
+    {522, 756, 33, "EXE"},		/* Executive */
+    {612, 936, 34, "GLG"},		/* Government Letter */ /* LPD.1. */
+    {576, 756, 35, "GLT"},		/* Government Legal */ /* LPD.1. */
+    {792, 1224, 36, "B"},		/* Ledger */
+    {593, 935, 37, "F4"},		/* F4 */
+    {284, 419, 38, "POSTCARD"},		/* PostCard */
+    {298, 666, 64, "YOU4"},             /* Japanese Envelope You4 */
+    {279, 540, 80, "MON"},		/* Monarch */
+    {297, 684, 81, "C10"},		/* Commercial 10 */
+    {312, 624, 90, "DL"},		/* DL */
+    {459, 649, 91, "C5"},               /* Envelope C5 */
+    {499, 709, 99, "IB5"},              /* Envelope ISO B5 */
+    {0, 0, -1, NULL}			/* Undefined */
+};
+
+typedef struct paper_candidate_s {
+  const EPaperTable *paper;
+  int absw;
+  int absh;
+  int score;
+  bool isfillw;
+  bool isfillh;
+  bool isminw;
+  bool isminh;
+} paper_candidate;
+
+
+private const EPaperTable *
+esmv_checkpapersize(gx_device_vector * vdev)
+{
+  gx_device_esmv	*const pdev = (gx_device_esmv *)vdev;
+  int			devw, devh;
+  paper_candidate	candidate[NUM_OF_PAPER_TABLES];
+  int			num_candidate;
+
+  
+  if (pdev->MediaSize[0] < pdev->MediaSize[1]) {
+    /* portrait */
+    devw = pdev->MediaSize[0];
+    devh = pdev->MediaSize[1];
+  } else {
+    /* landscape */
+    devw = pdev->MediaSize[1];
+    devh = pdev->MediaSize[0];
+  }
+
+  /* pick up papersize candidate */
+  {
+    const EPaperTable *pt;
+    int delta;
+
+    num_candidate = 0;
+
+    for (delta = 0; delta <= MAX_PAPER_SIZE_DELTA; delta++) {
+      for (pt = ePaperTable; 0 <= pt->escpage; pt++) {
+	if ( (pt->width  + delta) >= devw &&
+	     (pt->width  - delta) <= devw &&
+	     (pt->height + delta) >= devh &&
+	     (pt->height - delta) <= devh) {
+
+	  candidate[num_candidate].paper = pt;
+	  candidate[num_candidate].absw = abs(pt->width  - devw);
+	  candidate[num_candidate].absh = abs(pt->height - devh);
+	  candidate[num_candidate].score = 0;
+	  candidate[num_candidate].isfillw = false;
+	  candidate[num_candidate].isfillh = false;
+	  candidate[num_candidate].isminw  = false;
+	  candidate[num_candidate].isminh  = false;
+
+	  if( 0 <= (pt->width - devw) ){
+	    candidate[num_candidate].isfillw = true;
+	  }
+	  if( 0 <= (pt->height - devh) ){
+	    candidate[num_candidate].isfillh = true;
+	  }
+	  num_candidate++;
+	}
+      }
+      if ( 0 < num_candidate ) {
+	break;
+      }
+    }
+  }
+  
+  /* no papersize match, so use default paper size */
+  if ( 0 == num_candidate  ) {
+    return (const EPaperTable *)0;		/* not found */
+  }
+
+  if ( 1 == num_candidate ) {
+    return candidate[0].paper; /* find */
+  }
+
+  /* search abstruct minw & minh */
+  {
+    int absminw;
+    int absminh;
+    int i;
+
+    absminw = candidate[0].absw;
+    absminh = candidate[0].absh;
+    for (i = 1; i < num_candidate; i++) {
+      if (absminw > candidate[i].absw) {
+	absminw = candidate[i].absw;
+      }
+      if (absminh > candidate[i].absh) {
+	absminh = candidate[i].absh;
+      }
+    }
+
+    /* check isminw & isminh flag */
+    for (i = 0; i < num_candidate; i++) {
+      if (absminw == candidate[i].absw) {
+	candidate[i].isminw = true;
+      }
+      if (absminh == candidate[i].absh) {
+	candidate[i].isminh = true;
+      }
+    }
+
+    /* add score */
+    for (i = 0; i < num_candidate; i++) {
+      if (candidate[i].isminw == true) {
+	candidate[i].score += 100;
+      }
+      if (candidate[i].isminh == true) {
+	candidate[i].score += 100;
+      }
+      if (candidate[i].isfillw == true) {
+	candidate[i].score += 10;
+      }
+      if (candidate[i].isfillh == true) {
+	candidate[i].score += 10;
+      }
+      if (absminw < absminh) {
+	if (candidate[i].isminw == true) {
+	  candidate[i].score += 1;
+	}
+      } else {
+	if (candidate[i].isminh == true) {
+	  candidate[i].score += 1;
+	}
+      }
+    }
+  }
+
+  /* select highest score papersize */
+  {
+    int best_candidate;
+    int i;
+
+    best_candidate = 0;
+    for (i = 1; i < num_candidate; i++) {
+      if ( candidate[best_candidate].score <= candidate[i].score ) {
+	best_candidate = i;
+      }
+    }
+    return candidate[best_candidate].paper;
+  }
+}
+
+private int
+esmv_beginpage(gx_device_vector * vdev)
+{
+    gx_device_esmv	*const pdev = (gx_device_esmv *)vdev;
+    /* gdev_vector_stream は使用禁止 */
+    stream		*s = vdev->strm;
+    char		ebuf[1024];
+    int			MaxRes;
+    int			Local;
+    int			Duplex;
+    int			FaceUp;
+
+    if (pdev -> first_page) {
+
+	if (strcmp(pdev->dname, "lp9600s") == 0 || \
+	    strcmp(pdev->dname, "lp9600")  == 0 || \
+	    strcmp(pdev->dname, "lp9400")  == 0 || \
+	    strcmp(pdev->dname, "lp9300")  == 0 || \
+	    strcmp(pdev->dname, "lp9100")  == 0 || \
+	    strcmp(pdev->dname, "lp9200b")  == 0 || \
+	    strcmp(pdev->dname, "lp9000b")  == 0 || \
+	    strcmp(pdev->dname, "lp8900")  == 0 || \
+	    strcmp(pdev->dname, "lp8600f") == 0 || \
+	    strcmp(pdev->dname, "lp8600")  == 0 || \
+	    strcmp(pdev->dname, "lp8400f") == 0 || \
+	    strcmp(pdev->dname, "lp8300f") == 0 || \
+	    strcmp(pdev->dname, "lp8100")  == 0 || \
+	    strcmp(pdev->dname, "lp7900")  == 0 || \
+	    strcmp(pdev->dname, "lp7700")  == 0 || \
+	    strcmp(pdev->dname, "lp7500")  == 0) {
+	    MaxRes = RES600;
+	    Local  = JPN;
+	    Duplex = TRUE;
+	    FaceUp = FALSE;
+	} else if (strcmp(pdev->dname, "lp1800") == 0) {
+	    MaxRes = RES600;
+	    Local  = JPN;
+	    Duplex = FALSE;
+	    FaceUp = FALSE;
+	} else if (strcmp(pdev->dname, "lp8700") == 0) {
+	    MaxRes = RES1200;
+	    Local  = JPN;
+	    Duplex = TRUE;
+	    FaceUp = FALSE;
+	} else if (strcmp(pdev->dname, "lp2200") == 0 || \
+	    strcmp(pdev->dname, "lp2500") == 0 || \
+	    strcmp(pdev->dname, "lp2400") == 0 || \
+	    strcmp(pdev->dname, "lp1900") == 0) {
+	    MaxRes = RES1200;
+	    Local  = JPN;
+	    Duplex = FALSE;
+	    FaceUp = FALSE;
+	} else if (strcmp(pdev->dname, "epl5900") == 0 || \
+	    strcmp(pdev->dname, "epl6100") == 0 || \
+	    strcmp(pdev->dname, "epl5800") == 0) {
+	    MaxRes = RES1200;
+	    Local  = ENG;
+	    Duplex = FALSE;
+	    FaceUp = FALSE;
+	} else if (strcmp(pdev->dname, "epl2050") == 0 || \
+	    strcmp(pdev->dname, "epl2050p") == 0 || \
+	    strcmp(pdev->dname, "epl2120") == 0) {
+	    MaxRes = RES1200;
+	    Local  = ENG;
+	    Duplex = TRUE;
+	    FaceUp = FALSE;
+	} else if (strcmp(pdev->dname, "epl2750") == 0 || \
+	    strcmp(pdev->dname, "epl2500") == 0) {
+	    MaxRes = RES600;
+	    Local  = ENG;
+	    Duplex = TRUE;
+	    FaceUp = FALSE;
+	} else {
+	    MaxRes = RES600;
+	    Local  = JPN;
+	    Duplex = FALSE;
+	    FaceUp = FALSE;
+	}
+
+	lputs(s, "\033\001@EJL \012@EJL SJ ID=\"Ghostscript\"\012");
+
+	lputs(s, "@EJL SE LA=ESC/PAGE\012");
+
+	lputs(s, "@EJL SET");
+
+	/* Resolusion */
+	if (vdev->x_pixels_per_inch == 1200){
+	    if (MaxRes == 1200){
+	    	lputs(s, " RS=1200");
+	    } else {
+	        lputs(s, " RS=FN");
+	    }
+	} else if (vdev->x_pixels_per_inch == 600) {
+	    lputs(s, " RS=FN");
+	} else {
+	    lputs(s, " RS=QK");
+	}
+
+	/* Output Unit */
+        if ((pdev->faceup && FaceUp) || (pdev->MediaType && FaceUp)) {
+            lputs(s, " OU=FU");
+        } else {
+            lputs(s, " OU=FD");
+        }
+
+	/* Paper unit */
+        if (pdev->MediaType){
+	    if (Local == ENG){
+		lputs(s, " PU=1");
+	    } else {
+		lputs(s, " PU=15");
+	    }
+	}else{
+	    if (pdev->manualFeed) {
+		if (Local == ENG){
+		    lputs(s, " PU=1");
+		} else {
+	            lputs(s, " PU=15");
+		}
+	    } else if (pdev->cassetFeed) {
+	        (void)sprintf(ebuf, " PU=%d", pdev->cassetFeed);
+	        lputs(s, ebuf);
+	    } else {
+	        lputs(s, " PU=AU");
+	    }
+	}
+
+	if (Duplex && pdev->Duplex) {
+	    /* 両面印刷指定 */
+	    lputs(s, " DX=ON");
+
+	    /* とじ方向 */
+	    if (pdev->Tumble) {
+		lputs(s, " BD=SE");
+	    } else {
+		lputs(s, " BD=LE");
+	    }
+	} else {
+	    /* 両面印刷off */
+	    lputs(s, " DX=OFF");
+	}
+
+	/* 印刷部数 */
+	if (pdev->NumCopies) {
+	    if (pdev->NumCopies >= 1000) {
+		pdev->NumCopies = 999;
+	    }
+
+	    if (pdev->Collate) {
+	      /* QT を指定した場合 CO は 1 */
+	      (void)sprintf(ebuf, " QT=%d CO=1", pdev->NumCopies);
+	    } else {
+	      /* QT を指定しなかった場合 QT は 1 */
+	      (void)sprintf(ebuf, " QT=1 CO=%d", pdev->NumCopies);
+	    }
+
+	    lputs(s, ebuf);
+	} else {
+	    lputs(s, " QT=1 CO=1");
+	}
+
+	if (pdev->toner_density) {
+	    (void)sprintf(ebuf, " DL=%d", pdev->toner_density);
+	    lputs(s, ebuf);
+	}
+
+	if (pdev->orientation) {
+	    lputs(s, " OR=LA");
+	}
+
+	if (pdev->toner_saving) {
+	    lputs(s, " SN=ON");
+	}
+
+	if (pdev->RITOff) {
+	    lputs(s, " RI=OFF");
+	} else {
+	    lputs(s, " RI=ON");
+	}
+
+	if (pdev->MediaType == 1) {
+	    lputs(s, " PK=TH");
+	} else if (pdev->MediaType == 2) {
+	    lputs(s, " PK=TR");
+	} else {
+	    lputs(s, " PK=NM");
+	}
+
+	lputs(s, " PS=");
+	{
+	  const EPaperTable *pt;
+
+	  pt = esmv_checkpapersize(vdev);
+	  if ( 0 == pt ) {
+	    lputs(s, "A4");
+	  } else {
+	    lputs(s, pt->name);
+	  }
+	}
+
+	lputs(s, " ZO=OFF EC=ON SZ=OFF SL=YES TO=0.0MM LO=0.0MM\012");
+	lputs(s, "@EJL EN LA=ESC/PAGE\012");
+
+#define	START_CODE1	ESC_GS "1tsE" ESC_GS "1owE" ESC_GS "0alfP" ESC_GS "0affP" ESC_GS "0;0;0clfP" ESC_GS "0pmP" ESC_GS "1024ibI" ESC_GS "2cmE" ESC_GS "0bcI" ESC_GS "1;10mlG"
+
+#define	STRAT_CODE	ESC_GS "1mmE" ESC_GS "1csE"
+
+	lputs(s, ESC_GS "rhE");
+
+	lputs(s, STRAT_CODE);
+
+	if (vdev->x_pixels_per_inch == 1200) {
+	    /* 1200 dpi */
+	    lputs(s, ESC_GS "0;0.06muE");
+	    lputs(s, ESC_GS "1;45;156htmE");
+	    lputs(s, ESC_GS "9;1200;1200drE" ESC_GS "2;1200;1200drE" ESC_GS "1;1200;1200drE" ESC_GS "0;1200;1200drE");
+	    lputs(s, ESC_GS "1;1;raE");
+	} else if (vdev->x_pixels_per_inch == 600) {
+	    /* 600 dpi */
+	    lputs(s, ESC_GS "0;0.12muE");
+	    lputs(s, ESC_GS "1;45;106htmE");
+	    lputs(s, ESC_GS "9;600;600drE" ESC_GS "2;600;600drE" ESC_GS "1;600;600drE" ESC_GS "0;600;600drE");
+	} else {
+	    /* 300 dpi */
+	    lputs(s, ESC_GS "0;0.24muE");
+	    lputs(s, ESC_GS "1;45;71htmE");
+	    lputs(s, ESC_GS "9;300;300drE" ESC_GS "2;300;300drE" ESC_GS "1;300;300drE" ESC_GS "0;300;300drE");
+	}
+
+	lputs(s, START_CODE1);
+
+	lputs(s, ESC_GS "0sarG");		/* 絶対座標指定 */
+	/*	lputs(s, ESC_GS "1owE");*/
+    }
+    
+    return 0;
+}
+
+
+private int
+esmv_setlinewidth(gx_device_vector * vdev, floatp width)
+{
+    stream			*s = gdev_vector_stream(vdev);
+    gx_device_esmv *const	pdev = (gx_device_esmv *) vdev;
+    char			obuf[64];
+
+#if GS_VERSION_MAJOR == 5
+    /* Scale を掛けているのは, Ghostscript 5.10/5.50 のバグのため */
+    floatp xscale, yscale;
+
+    xscale = fabs(igs->ctm.xx);
+    yscale = fabs(igs->ctm.xy);
+
+    if (xscale == 0 || yscale > xscale)		/* if portrait */
+	width = ceil(width * yscale);
+    else
+	width = ceil(width * xscale);
+#endif
+
+    if (width < 1) width = 1;
+
+    /* ESC/Page では線幅／終端／接合部の設定は１つのコマンドになっているため保持しておく。 */
+    pdev -> lwidth = width;
+
+    (void)sprintf(obuf, ESC_GS "%d;%d;%dlwG", (int)(pdev -> lwidth), (int)(pdev -> cap), (int)(pdev -> join));
+    lputs(s, obuf);
+
+    return 0;
+}
+
+
+private int
+esmv_setlinecap(gx_device_vector * vdev, gs_line_cap cap)
+{
+    stream			*s = gdev_vector_stream(vdev);
+    gx_device_esmv *const	pdev = (gx_device_esmv *) vdev;
+    char			obuf[64];
+
+    /* ESC/Page では線幅／終端／接合部の設定は１つのコマンドになっているため保持しておく。 */
+    pdev -> cap = cap;
+
+    if (pdev -> cap >= 3) return -1;
+
+    (void)sprintf(obuf, ESC_GS "%d;%d;%dlwG", (int)(pdev -> lwidth), (int)(pdev -> cap), (int)(pdev -> join));
+    lputs(s, obuf);
+
+    return 0;
+}
+
+
+private int
+esmv_setlinejoin(gx_device_vector * vdev, gs_line_join join)
+{
+    stream			*s = gdev_vector_stream(vdev);
+    gx_device_esmv *const	pdev = (gx_device_esmv *) vdev;
+    char			obuf[64];
+
+    /* ESC/Page では線幅／終端／接合部の設定は１つのコマンドになっているため保持しておく。 */
+    switch (join) {
+    case 0:
+	pdev -> join = 3;		/* miter */
+	break;
+    case 1:
+	pdev -> join = 1;		/* round */
+	break;
+    case 2:
+	pdev -> join = 2;		/* bevel */
+	break;
+    default:
+	return -1;
+    }
+
+    (void)sprintf(obuf, ESC_GS "%d;%d;%dlwG", (int)(pdev -> lwidth), (int)(pdev -> cap), (int)(pdev -> join));
+    lputs(s, obuf);
+
+    return 0;
+}
+
+
+private int
+esmv_setmiterlimit(gx_device_vector * vdev, floatp limit)
+{
+    stream			*s = gdev_vector_stream(vdev);
+    gx_device_esmv *const	pdev = (gx_device_esmv *) vdev;
+    char			obuf[128];
+
+    /* マイターリミット値を設定するには lwG にて 接合部指定(n3) が 3 になっている
+    ** 必要がある。
+    */
+    if (pdev -> join != 3) {
+	/* 強制的に接合部指定を行う */
+	pdev -> join = 3;
+	(void)sprintf(obuf, ESC_GS "%d;%d;%dlwG", (int)(pdev -> lwidth), (int)(pdev -> cap), (int)(pdev -> join));
+	lputs(s, obuf);
+    }
+
+    (void)sprintf(obuf, ESC_GS "1;%dmlG", (int)limit);
+    lputs(s, obuf);
+
+    return 0;
+}
+
+
+#if ( 8 <= GS_VERSION_MAJOR )
+private bool
+esmv_can_handle_hl_color(gx_device_vector * vdev, const gs_imager_state * pis, 
+                         const gx_drawing_color * pdc)
+{
+    return false;
+}
+#endif
+
+
+private int
+esmv_setfillcolor(gx_device_vector * vdev,
+#if ( 8 <= GS_VERSION_MAJOR )
+		  const gs_imager_state * pis,
+#endif
+		  const gx_drawing_color * pdc)
+{
+    stream			*s = gdev_vector_stream(vdev);
+    gx_device_esmv *const	pdev = (gx_device_esmv *) vdev;
+    gx_color_index		color = gx_dc_pure_color(pdc);
+    char			obuf[64];
+
+    if (!gx_dc_is_pure(pdc)) return_error(gs_error_rangecheck);
+    pdev->current_color = color;
+
+    (void)sprintf(obuf, /*ESC_GS "1owE"*/ ESC_GS "0;0;100spE" ESC_GS "1;0;%ldccE" ,color);
+    lputs(s, obuf);
+
+    if (vdev->x_pixels_per_inch == 1200) {
+      lputs(s, ESC_GS "1;45;156htmE");
+    } else if (vdev->x_pixels_per_inch == 600) {
+      lputs(s, ESC_GS "1;45;106htmE");
+    } else {
+      lputs(s, ESC_GS "1;45;71htmE");
+    }
+    
+    return 0;
+}
+
+
+private int
+esmv_setstrokecolor(gx_device_vector * vdev,
+#if ( 8 <= GS_VERSION_MAJOR )
+		    const gs_imager_state * pis,
+#endif
+		    const gx_drawing_color * pdc)
+{
+    stream			*s = gdev_vector_stream(vdev);
+    gx_device_esmv *const	pdev = (gx_device_esmv *) vdev;
+    gx_color_index		color = gx_dc_pure_color(pdc);
+    char			obuf[64];
+
+    if (!gx_dc_is_pure(pdc)) return_error(gs_error_rangecheck);
+
+  /*    if (vdev->color_info.depth == 24) {*/
+
+	pdev->current_color = color;
+
+	(void)sprintf(obuf, /*ESC_GS "1owE"*/ ESC_GS "0;0;100spE" ESC_GS "1;1;%ldccE" , color);
+	lputs(s, obuf);
+
+	if (vdev->x_pixels_per_inch == 1200) {
+	  lputs(s, ESC_GS "1;45;156htmE");
+	} else if (vdev->x_pixels_per_inch == 600) {
+	  lputs(s, ESC_GS "1;45;106htmE");
+	} else {
+	  lputs(s, ESC_GS "1;45;71htmE");
+	}
+
+    return 0;
+}
+
+
+/* 線種指定命令 */
+private int
+esmv_setdash(gx_device_vector * vdev, const float *pattern, uint count, floatp offset)
+{
+    stream			*s = gdev_vector_stream(vdev);
+    int				i;
+    char			obuf[64];
+
+#if GS_VERSION_MAJOR == 5
+    float			scale, xscale, yscale;
+    /* Scale を掛けているのは, Ghostscript 5.10/5.50 のバグのため */
+    xscale = fabs(igs->ctm.xx);
+    yscale = fabs(igs->ctm.xy);
+
+    if (xscale == 0)		/* if portrait */
+	scale = yscale;
+    else
+	scale = xscale;
+#endif
+
+    if (count == 0){
+	/* 実線 */
+	lputs(s, ESC_GS "0;0lpG");
+	return 0;
+    }
+    
+    /* offset が０以外の場合は描画不可として返却 */
+    if (offset != 0) return -1;
+
+    if (count) {
+	if (count == 1) {
+#if GS_VERSION_MAJOR == 5
+	    (void)sprintf(obuf, ESC_GS "1;%d;%ddlG", 
+			  (int)(pattern[0] * scale / vdev->x_pixels_per_inch + 0.5),
+			  (int)(pattern[0] * scale / vdev->x_pixels_per_inch + 0.5));
+#else
+	    (void)sprintf(obuf, ESC_GS "1;%d;%ddlG", pattern[0], pattern[0]);
+#endif
+	    lputs(s, obuf);
+	} else {
+	    /* pattern に０があった場合は描画不可として返却 */
+	    for (i = 0; i < count; ++i) {
+		if (pattern[i] == 0) return -1;
+	    }
+
+	    lputs(s, ESC_GS "1");
+	    for (i = 0; i < count; ++i) {
+#if GS_VERSION_MAJOR == 5
+		(void)sprintf(obuf, ";%d", (int)(pattern[i] * scale / vdev->x_pixels_per_inch + 0.5));
+
+#else
+		(void)sprintf(obuf, ";%d", pattern[i]);
+#endif
+		lputs(s, obuf);
+	    }
+	    lputs(s, "dlG");
+	}
+	lputs(s, ESC_GS "1;1lpG");
+    }
+    return 0;
+}
+
+
+/* パス平滑度指定 */
+private int
+esmv_setflat(gx_device_vector * vdev, floatp flatness)
+{
+    return 0;
+}
+
+
+private int
+esmv_setlogop(gx_device_vector * vdev, gs_logical_operation_t lop,
+		gs_logical_operation_t diff)
+{
+/****** SHOULD AT LEAST DETECT SET-0 & SET-1 ******/
+    return 0;
+}
+
+
+private int
+esmv_beginpath(gx_device_vector * vdev, gx_path_type_t type)
+{
+    stream		*s = gdev_vector_stream(vdev);
+
+    /* パス構築開始命令 */
+    if (type & gx_path_type_clip) {
+	lputs(s, ESC_GS "1bgpG");		/* クリップ登録 */
+    } else {
+	lputs(s, ESC_GS "0bgpG");		/* 描画登録 */
+    }
+    return 0;
+}
+
+
+private int
+esmv_moveto(gx_device_vector * vdev,
+	    floatp x0, floatp y0, floatp x1, floatp y1, gx_path_type_t type)
+{
+    stream	*s = gdev_vector_stream(vdev);
+    char	obuf[64];
+
+    /* サブパス開始命令 */
+    (void)sprintf(obuf, ESC_GS "0;%d;%dmvpG", (int)x1, (int)y1);
+    lputs(s, obuf);
+
+    return 0;
+}
+
+
+private int
+esmv_lineto(gx_device_vector * vdev,
+	    floatp x0, floatp y0, floatp x1, floatp y1, gx_path_type_t type)
+{
+    stream	*s = gdev_vector_stream(vdev);
+    char	obuf[64];
+
+    (void)sprintf(obuf, ESC_GS "0;1;%d;%dlnpG", (int)x1, (int)y1);
+    lputs(s, obuf);
+
+    return 0;
+}
+
+
+private int
+esmv_curveto(gx_device_vector * vdev, floatp x0, floatp y0,
+	   floatp x1, floatp y1, floatp x2, floatp y2, floatp x3, floatp y3,
+	       gx_path_type_t type)
+{
+    stream	*s = gdev_vector_stream(vdev);
+    char	obuf[128];
+
+    /* ベジェ曲線 */
+    (void)sprintf(obuf, ESC_GS "0;3;%d;%d;%d;%d;%d;%dbzpG",
+		  (int)x1, (int)y1, (int)x2, (int)y2, (int)x3, (int)y3);
+    lputs(s, obuf);
+
+    return 0;
+}
+
+
+private int
+esmv_closepath(gx_device_vector * vdev, floatp x, floatp y,
+		 floatp x_start, floatp y_start, gx_path_type_t type)
+{
+    stream	*s = gdev_vector_stream(vdev);
+
+    lputs(s, ESC_GS "clpG");
+    return 0;
+}
+
+
+private int
+esmv_endpath(gx_device_vector * vdev, gx_path_type_t type)
+{
+    stream	*s = gdev_vector_stream(vdev);
+
+    if (type & gx_path_type_fill || type & gx_path_type_clip) {
+	/* default で処理されるが出力しておく */
+	lputs(s, ESC_GS "clpG");
+    }
+
+    /* パスクローズ */
+    lputs(s, ESC_GS "enpG");
+
+    /* パス描画 */
+    if (type & gx_path_type_clip) {
+
+	/* クリップ指定
+	** クリップにも gx_path_type_winding_number, gx_path_type_even_odd の判断が
+	** 必要だと思うが gs 側が付加してこない。 
+	** とりあえず gx_path_type_even_odd をデフォルトにする。
+	*/
+	lputs(s, ESC_GS "1;2capG");
+    } else if (type & gx_path_type_fill) {
+
+	/* 塗りつぶし規則設定 */
+	if (type & gx_path_type_even_odd) {
+/*	    lputs(s, ESC_GS "0;0;100spE");*/
+	    lputs(s, ESC_GS "0;2drpG");		/* 塗りつぶし描画 */
+	} else {
+/*	    lputs(s, ESC_GS "0;0;100spE");*/
+	    lputs(s, ESC_GS "0;1drpG");		/* 塗りつぶし描画 */
+	}
+    } else {	
+	lputs(s, ESC_GS "0;0drpG");		/* 輪郭線描画 */
+    }
+
+    return 0;
+}
+
+/* ---------------- Driver procedures ---------------- */
+
+/* ------ Open/close/page ------ */
+
+/* Open the device. */
+private int
+esmv_open(gx_device * dev)
+{
+    gx_device_vector	*const vdev = (gx_device_vector *) dev;
+    gx_device_esmv	*const pdev = (gx_device_esmv *) dev;
+    int			code;
+    /*    char		*error, *path;*/
+    float               width, height;
+
+    code = esmv_range_check(dev);
+    if (code < 0) return code;
+
+    vdev->v_memory = dev->memory;
+    /****** VERY WRONG ******/
+    vdev->vec_procs = &esmv_vector_procs;
+
+    code = gdev_vector_open_file_bbox(vdev, 512, true);
+    if (code < 0) return code;
+
+    gdev_vector_init(vdev);
+    pdev->first_page = true;
+
+    if(pdev->orientation){
+      pdev->Margins[1] = (pdev->width - pdev->height - \
+      ESCPAGE_LEFT_MARGIN_DEFAULT * vdev->x_pixels_per_inch / 72.0) * \
+      X_DPI / vdev->x_pixels_per_inch;
+
+      width = dev->MediaSize[0];
+      height  = dev->MediaSize[1];
+      dev->MediaSize[0] = height;
+      dev->MediaSize[1] = width;
+    }
+
+    return 0;
+}
+
+
+/* Wrap up ("output") a page. */
+private int
+esmv_output_page(gx_device * dev, int num_copies, int flush)
+{
+    gx_device_vector *const vdev = (gx_device_vector *) dev;
+    gx_device_esmv *const pdev = (gx_device_esmv *) dev;
+    stream *s = gdev_vector_stream(vdev);
+
+    /* 線幅,終端処理,接合部処理を初期化しておく */
+    lputs(s, ESC_GS "3;0;0lwG" ESC_GS "1;10mlG" ESC_FF);
+
+    sflush(s);
+    vdev->in_page = false;
+    pdev->first_page = false;
+
+    gdev_vector_reset(vdev);
+
+    return 0;
+}
+
+
+private int
+esmv_close(gx_device *dev)
+{
+    gx_device_vector	*const vdev = (gx_device_vector *) dev;
+    FILE		*f = vdev->file;
+
+    /* 終了処理コードは決め打ち */
+    (void)fprintf(f, ESC_GS "rhE" "\033\001@EJL \012@EJL EJ \012\033\001@EJL \012");
+
+    gdev_vector_close_file(vdev);
+
+    return 0;
+}
+
+/* Close the device. */
+/* Note that if this is being called as a result of finalization, */
+/* the stream may no longer exist; but the file will still be open. */
+
+/* ---------------- Get/put parameters ---------------- */
+
+/* Get parameters. */
+private int
+esmv_get_params(gx_device * dev, gs_param_list * plist)
+{
+    gx_device_esmv	*const pdev = (gx_device_esmv *) dev;
+    int			code;
+    int			ncode;
+
+    code = gdev_vector_get_params(dev, plist);
+    if (code < 0) return code;
+
+    if ((ncode = param_write_bool(plist, ESCPAGE_OPTION_MANUALFEED, &pdev->manualFeed)) < 0)
+	code = ncode;
+
+    if ((ncode = param_write_int(plist, ESCPAGE_OPTION_CASSETFEED, &pdev->cassetFeed)) < 0)
+	code = ncode;
+
+    if ((ncode = param_write_bool(plist, ESCPAGE_OPTION_RIT, &pdev->RITOff)) < 0)
+	code = ncode;
+
+    if ((ncode = param_write_bool(plist, ESCPAGE_OPTION_COLLATE, &pdev->Collate)) < 0)
+        code = ncode;
+
+    if ((ncode = param_write_int(plist, ESCPAGE_OPTION_TONERDENSITY, &pdev->toner_density)) < 0)
+        code = ncode;
+
+    if ((ncode = param_write_bool(plist, ESCPAGE_OPTION_LANDSCAPE, &pdev->orientation)) < 0)
+        code = ncode;
+
+    if ( param_write_bool(plist, ESCPAGE_OPTION_TONERSAVING, &pdev->toner_saving)< 0)
+        code = ncode;
+
+    if ((ncode = param_write_bool(plist, ESCPAGE_OPTION_DUPLEX, &pdev->Duplex)) < 0)
+	code = ncode;
+
+    if ((ncode = param_write_bool(plist, ESCPAGE_OPTION_DUPLEX_TUMBLE, &pdev->Tumble)) < 0)
+	code = ncode;
+
+    if ((ncode = param_write_bool(plist, ESCPAGE_OPTION_FACEUP, &pdev->faceup)) < 0)
+	code = ncode;
+
+    if ((ncode = param_write_int(plist, ESCPAGE_OPTION_MEDIATYPE, &pdev->MediaType)) < 0)
+	code = ncode;
+
+    return code;
+}
+
+
+/* Put parameters. */
+private int
+esmv_put_params(gx_device * dev, gs_param_list * plist)
+{
+    gx_device_esmv	*const pdev = (gx_device_esmv *) dev;
+    int			ecode = 0;
+    int			code;
+    /*    gs_param_string     pmedia;*/
+    gs_param_name	param_name;
+    gs_param_string	pmedia;
+    bool		mf = pdev->manualFeed;
+    int			cass = pdev->cassetFeed;
+    bool		tum = pdev->Tumble;
+    bool		collate = pdev->Collate;
+    int			toner_density = pdev->toner_density;
+    bool		toner_saving = pdev->toner_saving;
+    bool		landscape = pdev->orientation;
+    bool		faceup = pdev->faceup;
+    bool		duplex = pdev->Duplex;
+    bool		RITOff = pdev->RITOff;
+    int			old_bpp = dev->color_info.depth;
+    int			bpp = 0;
+
+    if ((code = param_read_bool(plist, (param_name = ESCPAGE_OPTION_MANUALFEED), &mf)) < 0) {
+	param_signal_error(plist, param_name, ecode = code);
+    }
+    switch (code = param_read_int(plist, (param_name = ESCPAGE_OPTION_CASSETFEED), &cass)) {
+	case 0:
+	    if (cass < -1 || cass > 15)
+		ecode = gs_error_limitcheck;
+	    else
+		break;
+	    goto casse;
+	default:
+	    ecode = code;
+	  casse:param_signal_error(plist, param_name, ecode);
+	case 1:
+	    break;
+    }
+
+    if((code = param_read_bool(plist, (param_name = ESCPAGE_OPTION_COLLATE), &collate)) < 0) {
+	param_signal_error(plist, param_name, ecode = code);
+    }
+
+    if ((code = param_read_bool(plist, (param_name = ESCPAGE_OPTION_RIT), &RITOff)) < 0) {
+	param_signal_error(plist, param_name, ecode = code);
+    }
+
+
+    switch (code = param_read_string(plist, (param_name = ESCPAGE_OPTION_MEDIATYPE), &pmedia)) {
+      case 0:
+	    if (pmedia.size > ESCPAGE_MEDIACHAR_MAX)
+		ecode = gs_error_limitcheck;
+	    else {		/* Check the validity of ``MediaType'' characters */
+
+		if (strcmp(pmedia.data, "TRANS") == 0) {
+		    pdev->MediaType = 2;
+		} else if (strcmp(pmedia.data, "THICK") == 0) {
+		    pdev->MediaType = 1;
+		} else {
+		    ecode = gs_error_rangecheck;
+		    goto pmediae;
+		}
+	    }
+	    break;
+	    goto pmediae;
+	default:
+	    ecode = code;
+	  pmediae:param_signal_error(plist, param_name, ecode);
+	case 1:
+	  if(!pdev->MediaType){
+	    pdev->MediaType = 0;
+	    pmedia.data = 0;
+	  }
+	  break;
+    }
+
+    switch (code = param_read_int(plist,
+                                  (param_name = ESCPAGE_OPTION_TONERDENSITY), &toner_density)) {
+    case 0:
+            if (toner_density < 0 || toner_density > 5)
+                ecode = gs_error_rangecheck;
+            else
+                break;
+            goto tden;
+    default:
+	ecode = code;
+tden:
+	param_signal_error(plist, param_name, ecode);
+    case 1:
+	break;
+    }
+
+    switch (code = param_read_bool(plist, (param_name = ESCPAGE_OPTION_TONERSAVING), &toner_saving)) {
+    case 0:
+	break;
+    default:
+	if ((code = param_read_null(plist, param_name)) == 0) {
+	    break;
+	}
+	ecode = code;
+	param_signal_error(plist, param_name, ecode);
+    case 1:
+	break;   
+    }
+
+    if ((code = param_read_bool(plist, (param_name = ESCPAGE_OPTION_DUPLEX), &duplex)) < 0)
+	param_signal_error(plist, param_name, ecode = code);
+
+    if ((code = param_read_bool(plist, (param_name = ESCPAGE_OPTION_DUPLEX_TUMBLE), &tum)) < 0)
+	param_signal_error(plist, param_name, ecode = code);
+
+    if ((code = param_read_bool(plist, (param_name = ESCPAGE_OPTION_LANDSCAPE), &landscape)) < 0)
+	param_signal_error(plist, param_name, ecode = code);
+
+    if ((code = param_read_bool(plist, (param_name = ESCPAGE_OPTION_FACEUP), &faceup)) < 0) {
+	param_signal_error(plist, param_name, ecode = code);
+    }
+
+
+    switch (code = param_read_int(plist, (param_name = "BitsPerPixel"), &bpp)) {
+	case 0:
+	    if (bpp != 8 && bpp != 24)
+		ecode = gs_error_rangecheck;
+	    else
+		break;
+	    goto bppe;
+	default:
+	    ecode = code;
+	  bppe:param_signal_error(plist, param_name, ecode);
+	case 1:
+	    break;
+    }
+
+    if (bpp != 0) {
+	dev->color_info.depth = bpp;
+	dev->color_info.num_components = ((bpp == 8) ? 1 : 3);
+	dev->color_info.max_gray = (bpp > 8 ? 255 : 1000);
+	dev->color_info.max_color = (bpp > 8 ? 255 : 1000);
+	dev->color_info.dither_grays = (bpp > 8 ? 256 : 5);
+	dev->color_info.dither_colors = (bpp > 8 ? 256 : 2);
+	dev_proc(pdev, map_rgb_color) = ((bpp == 8) ? gx_default_gray_map_rgb_color : gx_default_rgb_map_rgb_color);
+	dev_proc(pdev, map_color_rgb) = ((bpp == 8) ? gx_default_gray_map_color_rgb : gx_default_rgb_map_color_rgb);
+    }
+
+    if (ecode < 0) return ecode;
+    code = gdev_vector_put_params(dev, plist);
+    if (code < 0) return code;
+
+    pdev->manualFeed = mf;
+    pdev->cassetFeed = cass;
+    pdev->faceup = faceup;
+    pdev->RITOff = RITOff;
+    pdev->orientation = landscape;
+    pdev->toner_density = toner_density;
+    pdev->toner_saving = toner_saving;
+    pdev->Collate = collate;
+    pdev->Duplex = duplex;
+    pdev->Tumble = tum;
+
+    if (bpp != 0 && bpp != old_bpp && pdev->is_open)
+	return gs_closedevice(dev);
+
+    return 0;
+}
+
+/* ---------------- Images ---------------- */
+
+
+private int
+esmv_copy_mono(gx_device * dev, const byte * data,
+	int data_x, int raster, gx_bitmap_id id, int x, int y, int w, int h,
+	   gx_color_index zero, gx_color_index one)
+{
+    gx_device_esmv *const	pdev = (gx_device_esmv *) dev;
+    gx_device_vector *const	vdev = (gx_device_vector *) dev;
+    stream			*s = gdev_vector_stream(vdev);
+    gx_drawing_color		color;
+    int				code = 0;
+    gx_color_index		c_color = 0;
+    char			obuf[128];
+    int				depth = 1;
+#if ( 8 <= GS_VERSION_MAJOR )
+    /* FIXME! add for gs815 */
+    const gs_imager_state * pis = (const gs_imager_state *)0;
+#endif
+
+    if (id != gs_no_id && zero == gx_no_color_index && one != gx_no_color_index && data_x == 0) {
+	gx_drawing_color dcolor;
+
+	color_set_pure(&dcolor, one);
+	esmv_setfillcolor(vdev,
+#if ( 8 <= GS_VERSION_MAJOR )
+			  pis,
+#endif
+			  &dcolor);
+    }
+
+    if (zero == gx_no_color_index) {
+
+        if (one == gx_no_color_index) return 0;
+	if (pdev->MaskState != 1) {
+	  /*	    lputs(s, ESC_GS "1owE");*/
+	    (void)sprintf(obuf, ESC_GS "1;1;%ldccE", c_color);
+	    lputs(s, obuf);
+
+	    if (vdev->x_pixels_per_inch == 1200) {
+	      lputs(s, ESC_GS "1;45;156htmE");
+	    } else if (vdev->x_pixels_per_inch == 600) {
+	      lputs(s, ESC_GS "1;45;106htmE");
+	    } else {
+	      lputs(s, ESC_GS "1;45;71htmE");
+	    }
+            pdev->MaskState = 1;   
+        }	
+	c_color = one;
+
+    } else if (one == gx_no_color_index)
+	/* 1bit は透明 ビット反転・zero 色に染める */
+    {
+	if (pdev->MaskState != 1) {
+	  /*	    lputs(s, ESC_GS "1owE");*/
+	    pdev->MaskState = 1;
+	}
+	c_color = zero;
+    } else if (one == vdev->white) {
+
+	if (pdev->MaskState != 0) {
+	  /*	    lputs(s, ESC_GS "1owE");*/
+	    pdev->MaskState = 0;
+	}
+	c_color = zero;
+    } else {
+
+        if (pdev->MaskState != 1) {
+	  /*	    lputs(s, ESC_GS "1owE");*/
+            pdev->MaskState = 1;
+        }
+	color_set_pure(&color, one);
+	code = gdev_vector_update_fill_color((gx_device_vector *) pdev,
+#if ( 8 <= GS_VERSION_MAJOR )
+					     pis,
+#endif
+					     &color);
+
+	/* ここを通過したら以下の色設定は無意味？ */
+    }
+    if (code < 0) return 0;
+
+    esmv_write_begin(dev, depth, (int)x, (int)y, w, h, w, h, 0);
+    {
+	int		i, j;
+	uint		width_bytes = (w + 7) >> 3;
+	uint		num_bytes = width_bytes * h; 
+
+	byte *buf = gs_alloc_bytes(vdev->memory, num_bytes, "esmv_copy_mono(buf)");
+
+	if (data_x % 8 == 0) {
+	    for (i = 0; i < h; ++i) {
+		memcpy(buf + i * width_bytes, data + (data_x >> 3) + i * raster, width_bytes);
+	    }
+	} else {
+	    for (i = 0; i < h; ++i) {
+		for (j = 0; j < width_bytes; j++) {
+		    *(buf + i * width_bytes + j) =
+			*(data + (data_x >> 3) + i * raster + j) << (data_x % 8) |
+			*(data + (data_x >> 3) + i * raster + j + 1) >> (8 - data_x % 8);
+		}
+	    }
+	}
+
+	esmv_write_data(dev, depth, buf, num_bytes, w, h);
+	gs_free_object(vdev->memory, buf, "esmv_copy_mono(buf)");
+    }
+    esmv_write_end(dev, depth);
+    return 0;
+}
+
+
+/* Copy a color bitmap. */
+private int
+esmv_copy_color(gx_device * dev,
+		  const byte * data, int data_x, int raster, gx_bitmap_id id,
+		  int x, int y, int w, int h)
+{
+    gx_device_esmv	*const pdev = (gx_device_esmv *) dev;
+    gx_device_vector	*const vdev = (gx_device_vector *) dev;
+
+    int			depth = dev->color_info.depth;
+    int			num_components = (depth < 24 ? 1 : 3);
+    uint		width_bytes = w * num_components;
+
+    if (pdev->MaskState != 0) {
+      /*	lputs(s, ESC_GS "1owE");*/
+	pdev->MaskState = 0;
+    }
+
+    esmv_write_begin(dev, depth, (int)x, (int)y, w, h, w, h, 0);
+
+    {
+	int		i;
+	uint		num_bytes = width_bytes * h;
+	byte		*buf = gs_alloc_bytes(vdev->memory, num_bytes, "esmv_copy_color(buf)");
+
+	for (i = 0; i < h; ++i) {
+	    memcpy(buf + i * width_bytes, data + ((data_x * depth) >> 3) + i * raster, width_bytes);
+	}
+
+	esmv_write_data(dev, depth, buf, num_bytes, w, h);
+	gs_free_object(vdev->memory, buf, "esmv_copy_color(buf)");
+    }
+
+    esmv_write_end(dev, depth);
+    return 0;
+}
+
+
+/* Fill a mask. */
+private int
+esmv_fill_mask(gx_device * dev,
+		 const byte * data, int data_x, int raster, gx_bitmap_id id,
+		 int x, int y, int w, int h,
+		 const gx_drawing_color * pdcolor, int depth,
+		 gs_logical_operation_t lop, const gx_clip_path * pcpath)
+{
+    gx_device_esmv	*const pdev = (gx_device_esmv *) dev;
+    gx_device_vector	*const vdev = (gx_device_vector *) dev;
+
+    stream		*s = gdev_vector_stream(vdev);
+    gx_color_index		color = gx_dc_pure_color(pdcolor);
+    char			obuf[64];
+#if ( 8 <= GS_VERSION_MAJOR )
+    /* FIXME! add for gs815 */
+    const gs_imager_state * pis = (const gs_imager_state *)0;
+#endif
+
+    if (w <= 0 || h <= 0) return 0;
+    
+    if (depth > 1 ||
+	gdev_vector_update_fill_color(vdev,
+#if ( 8 <= GS_VERSION_MAJOR )
+				      pis,
+#endif
+				      pdcolor) < 0 ||
+	gdev_vector_update_clip_path(vdev, pcpath) < 0 ||
+	gdev_vector_update_log_op(vdev, lop) < 0
+	) 
+	return gx_default_fill_mask(dev, data, data_x, raster, id,
+				    x, y, w, h, pdcolor, depth, lop, pcpath);
+    
+#if 0
+    (*dev_proc(vdev->bbox_device, fill_mask))
+	((gx_device *) vdev->bbox_device, data, data_x, raster, id,
+	 x, y, w, h, pdcolor, depth, lop, pcpath);
+#endif
+
+    if (!gx_dc_is_pure(pdcolor)) return_error(gs_error_rangecheck);
+    pdev->current_color = color;
+
+    (void)sprintf(obuf, ESC_GS "0;0;100spE" ESC_GS "1;1;%ldccE" ,color);
+    lputs(s, obuf);
+
+
+    if (vdev->x_pixels_per_inch == 1200) {
+      lputs(s, ESC_GS "1;45;156htmE");
+    } else if (vdev->x_pixels_per_inch == 600) {
+      lputs(s, ESC_GS "1;45;106htmE");
+    } else {
+      lputs(s, ESC_GS "1;45;71htmE");
+    }
+
+    if(pdev->MaskState != 1) {
+      /*      lputs(s, ESC_GS "1owE");*/
+	pdev->MaskState = 1;
+    }
+
+    esmv_write_begin(dev, depth, (int)x, (int)y, w, h, w, h, 0);
+    {
+	int		i;
+	uint		width_bytes = (w + 7) >> 3;
+	uint		num_bytes = width_bytes * h;
+	byte		*buf = gs_alloc_bytes(vdev->memory, num_bytes, "esmv_fill_mask(buf)");
+
+	for (i = 0; i < h; ++i) {
+	    memcpy(buf + i * width_bytes, data + (data_x >> 3) + i * raster, width_bytes);
+	}
+
+	esmv_write_data(dev, depth, buf, num_bytes, w, h);
+	esmv_write_end(dev, depth);
+	gs_free_object(vdev->memory, buf, "esmv_fill_mask(buf)");
+    }
+
+    return 0;
+}
+
+/* ---------------- High-level images ---------------- */
+
+private image_enum_proc_plane_data(esmv_image_plane_data);
+private image_enum_proc_end_image(esmv_image_end_image);
+private const gx_image_enum_procs_t esmv_image_enum_procs =
+{
+    esmv_image_plane_data, esmv_image_end_image
+};
+
+
+/* Start processing an image. */
+private int
+esmv_begin_image(gx_device * dev,
+		 const gs_imager_state * pis, const gs_image_t * pim,
+		 gs_image_format_t format, const gs_int_rect * prect,
+		 const gx_drawing_color * pdcolor, const gx_clip_path * pcpath,
+		 gs_memory_t * mem, gx_image_enum_common_t **pinfo)
+{
+    gx_device_vector *const	vdev = (gx_device_vector *) dev;
+    gx_device_esmv *const	pdev = (gx_device_esmv *) dev;
+    stream			*s = gdev_vector_stream((gx_device_vector *) pdev);
+    gdev_vector_image_enum_t	*pie = 
+	gs_alloc_struct(mem, gdev_vector_image_enum_t, &st_vector_image_enum, "esmv_begin_image");
+    const gs_color_space	*pcs = pim->ColorSpace;
+    gx_color_index		color = gx_dc_pure_color(pdcolor);
+    gs_color_space_index	index;
+    int				num_components = 1;
+    bool can_do = prect == 0 &&
+      (pim->format == gs_image_format_chunky ||
+       pim->format == gs_image_format_component_planar);
+
+    gs_matrix			imat;
+    int				code;
+    int				ty, bx, by, cx, cy, dx, dy, sx, sy;
+    char		        obuf[128];
+
+    if (pie == 0) return_error(gs_error_VMerror);
+    pie->memory = mem;
+    code = gdev_vector_begin_image(vdev, pis, pim, format, prect,
+				   pdcolor, pcpath, mem, &esmv_image_enum_procs, pie);
+    if (code < 0) return code;
+    
+    *pinfo = (gx_image_enum_common_t *) pie;
+
+    if (!pim->ImageMask) {
+	index = gs_color_space_get_index(pcs);
+	num_components = gs_color_space_num_components(pcs);
+
+	if (pim->CombineWithColor) {	    
+	    can_do = false;
+	} else {
+	    switch (index) {
+		case gs_color_space_index_DeviceGray:
+		    if ((pim->Decode[0] != 0 || pim->Decode[1] != 1)
+			&& (pim->Decode[0] != 1 || pim->Decode[1] != 0))
+			can_do = false;
+		    break;
+		case gs_color_space_index_DeviceRGB:
+		    if (pim->Decode[0] != 0 || pim->Decode[1] != 1 ||
+			pim->Decode[2] != 0 || pim->Decode[3] != 1 ||
+			pim->Decode[4] != 0)
+			can_do = false;
+		    break;
+		default:
+		    can_do = false;
+	    }
+	}
+    }
+    if (!can_do) {
+	return gx_default_begin_image(dev, pis, pim, format, prect,
+				      pdcolor, pcpath, mem, &pie->default_info);
+    }
+    
+    if (pim->ImageMask || (pim->BitsPerComponent == 1 && num_components == 1)) {
+	if (pim->Decode[0] > pim->Decode[1]) {
+	    pdev->MaskReverse = 1;
+	} else {
+	    pdev->MaskReverse = 0;
+	}
+    }
+
+    /* Write the image/colorimage/imagemask preamble. */
+    gs_matrix_invert(&pim->ImageMatrix, &imat);
+    gs_matrix_multiply(&imat, &ctm_only(pis), &imat);
+
+    ty = imat.ty;
+    bx = imat.xx * pim->Width + imat.yx * pim->Height + imat.tx;
+    by = imat.xy * pim->Width + imat.yy * pim->Height + imat.ty;
+    cx = imat.yx * pim->Height + imat.tx;
+    cy = imat.yy * pim->Height + imat.ty;
+    dx = imat.xx * pim->Width + imat.tx;
+    dy = imat.xy * pim->Width + imat.ty;
+
+    sx = bx - (int)imat.tx;
+    sy = by - (int)imat.ty;
+
+    /* とりあえず絵の位置に収まるように強制的に座標を変更する。 */
+    pdev -> roll = 0;
+    pdev -> reverse_x = pdev -> reverse_y = 0;
+    if (imat.tx > bx) {
+	pdev -> reverse_x = 1;
+	sx = -sx;
+	imat.tx = bx;
+    }
+
+    if (imat.ty > by) {
+	pdev -> reverse_y = 1;
+	sy = -sy;
+	imat.ty = by;
+    }
+
+    (void)memcpy(&pdev -> xmat, &imat, sizeof(gs_matrix));
+    pdev -> sx = sx;
+    pdev -> sy = sy;
+    pdev -> h = pim->Height;
+    pdev -> w = pim->Width;
+    pdev -> dd = 0;
+    pdev -> bx = 0;
+    pdev -> by = 0;
+
+    if (ty == cy) {
+	/* 回転時の描画については現在未実装。GS 側の機能を使用する */
+	return -1;
+    }
+
+    if (pim->ImageMask) {
+	pdev->ncomp = 1;
+
+	/* 描画論理設定命令 - 透過 */
+	if (pdev->MaskState != 1) {
+
+	  /*	    lputs(s, ESC_GS "1owE");*/
+	    (void)sprintf(obuf, ESC_GS "1;1;%ldccE", color);
+	    lputs(s, obuf);
+
+	    if (vdev->x_pixels_per_inch == 1200) {
+	      lputs(s, ESC_GS "1;45;156htmE");
+	    } else if (vdev->x_pixels_per_inch == 600) {
+	      lputs(s, ESC_GS "1;45;106htmE");
+	    } else {
+	      lputs(s, ESC_GS "1;45;71htmE");
+	    }
+
+
+	}
+
+    } else {
+
+	/* 描画論理設定命令 - 白塗り */
+	if (pdev->MaskState != 0) {
+
+	  /*	  lputs(s, ESC_GS "1owE");*/ /* 184->204 */
+	    pdev->MaskState = 0;
+	}
+	pdev->ncomp = num_components;
+    }
+
+    if (pdev -> reverse_y) return 0;
+
+    esmv_write_begin(dev, pie->bits_per_pixel, (int)imat.tx, (int)imat.ty, pie->width, pie->height, sx, sy, pdev -> roll);
+    
+    return 0;
+}
+
+
+/* Process the next piece of an image. */
+private int
+#if GS_VERSION_MAJOR >= 6
+esmv_image_plane_data(gx_image_enum_common_t *info, const gx_image_plane_t *planes, int height, int *rows_used)
+#else
+esmv_image_plane_data(gx_device *dev, gx_image_enum_common_t *info, const gx_image_plane_t *planes, int height)
+#endif
+{
+#if GS_VERSION_MAJOR >= 6
+    gx_device *dev = info->dev;
+#endif
+    gx_device_vector *const	vdev = (gx_device_vector *) dev;
+    gx_device_esmv *const	pdev = (gx_device_esmv *) dev;
+    gdev_vector_image_enum_t	*pie = (gdev_vector_image_enum_t *) info;
+
+    int				y;
+    int				plane;
+    int				width_bytes, tbyte;
+    byte			*buf;
+
+    if (pie->default_info) return gx_image_plane_data(pie->default_info, planes, height);
+
+    gx_image_plane_data(pie->bbox_info, planes, height);
+
+    {
+
+#if GS_VERSION_MAJOR >= 6
+	if (height == 260)
+	    height = 1;
+#endif
+        width_bytes = (pie->width * pie->bits_per_pixel / pdev->ncomp + 7) / 8 * pdev->ncomp;
+	tbyte = width_bytes * height;
+	buf = gs_alloc_bytes(vdev->memory, tbyte, "esmv_image_data(buf)");
+
+	if (pdev -> reverse_y) {
+
+	    if (pdev -> h == height) {
+
+#if 1
+		if(tbyte == 1){
+		    if(strcmp(pdev->dname, "lp1800") != 0 &&
+		       strcmp(pdev->dname, "lp9600") != 0) {
+		      pdev->w += pdev->sx / 2048;
+		      height  += pdev->sy / 2048;
+		    }
+	        }
+#endif
+	      esmv_write_begin(dev, pie->bits_per_pixel, (int)pdev -> xmat.tx, (int)pdev -> xmat.ty, pdev -> w, height, (int)pdev -> sx, (int)pdev -> sy, pdev -> roll);
+
+	    } else {
+		float	yy, sy;
+
+		yy = (pdev -> h * pdev->xmat.yy) - (pdev -> dd * pdev -> xmat.yy) - (height * pdev -> xmat.yy);
+		if (yy == 0) {
+		    yy = (pdev -> h * pdev->xmat.yx) - (pdev -> dd * pdev -> xmat.yx) - (height * pdev -> xmat.yx);
+		}
+
+		if (pdev -> by) {
+		    sy = (int)pdev -> xmat.ty - (int)yy;
+		    sy = pdev -> by - (int)sy;
+		} else {
+		    sy = height * pdev -> xmat.yy + 0.5;
+		}
+		if (sy < 0) {
+		    sy = -sy;
+		}
+
+		esmv_write_begin(dev, pie->bits_per_pixel, (int)pdev -> xmat.tx, (int)pdev -> xmat.ty - (int)yy, pdev -> w, height, (int)pdev -> sx, (int)sy, pdev -> roll);
+
+		pdev -> by = (int)pdev -> xmat.ty - (int)yy;
+	    }
+	}
+	pdev -> dd += height;
+
+	for (plane = 0; plane < pie->num_planes; ++plane) {
+
+	    for (y = 0; y < height; ++y) {
+
+		int     bit, w;
+		const byte *p;
+		byte *d;
+		byte c;
+
+                p = planes[plane].data + ((planes[plane].data_x * pie->bits_per_pixel) >> 3) + y * planes[plane].raster;
+		if (pdev -> reverse_y) {
+
+		    d = buf + (height - y) * width_bytes;
+
+		    if (!pdev -> reverse_x) {
+			(void)memcpy(buf + (height - y - 1) * width_bytes,
+				     planes[plane].data + ((planes[plane].data_x * pie->bits_per_pixel) >> 3)
+				     + y * planes[plane].raster, width_bytes);
+
+		    }
+
+		} else {
+
+		    d = buf + (y + 1) * width_bytes;
+
+		    if (!pdev -> reverse_x) {
+
+			(void)memcpy(buf + y * width_bytes,
+				     planes[plane].data + ((planes[plane].data_x * pie->bits_per_pixel) >> 3)
+				     + y * planes[plane].raster, width_bytes);
+
+		    }
+		}
+		if (pdev -> reverse_x) {
+		    if (pie->bits_per_pixel == 1) {
+			for (w = 0; w < width_bytes; w++) {
+			    c = 0;
+			    for (bit = 0; bit < 8; bit++) {
+				if (*p & 1 << (7 - bit)) {
+				    c |= 1 << bit;
+				}
+			    }
+			    p++;
+			    *--d = c;
+			}
+		    } else if (pie->bits_per_pixel == 8){
+			for (w = 0; w < width_bytes; w++) {
+			    *--d = *p++;
+			}
+		    } else {
+			for (w = 0; w < width_bytes / 3; w++) {
+			    *--d = *(p + 2);
+			    *--d = *(p + 1);
+			    *--d = *p;
+			    p += 3;
+			}
+		    }
+		}
+	    }
+	}
+
+#if 1
+	if(tbyte == 1){
+	    int t;
+	    gs_free_object(vdev->memory, buf, "esmv_image_data(buf)");
+	    if(strcmp(pdev->dname, "lp1800") == 0 ||
+	       strcmp(pdev->dname, "lp9600") == 0) {
+		if(pdev->sx > pdev->sy){
+	            height  = pdev->sy;
+	            pdev->w = pdev->sx; 
+	            tbyte = ((pdev->sx + 7) / 8) * pdev->sy;
+	        } else {
+		    if(pdev->sx < pdev->sy){
+	                height  = pdev->sy;
+	                pdev->w = pdev->sx; 
+	                tbyte = ((pdev->sx + 7) / 8) * pdev->sy;
+  	            } else {
+	                tbyte = 1;
+	            }
+                }
+
+	    } else {
+	        if(pdev->sx > pdev->sy){
+	            tbyte = 1;
+	        } else {
+		    if(pdev->sx < pdev->sy){
+	                tbyte = tbyte * height;
+  	            } else {
+	                tbyte = 1;
+	            }
+	        }
+	    }
+	    buf = gs_alloc_bytes(vdev->memory, tbyte, "esmv_image_data(buf)");
+	    for(t = 0; t < tbyte; t++){
+	        buf[t] = 0xff;
+	    }
+	}
+#endif
+	esmv_write_data(dev, pie->bits_per_pixel, buf, tbyte, pdev -> w, height);
+
+	if (pdev -> reverse_y) {
+	    esmv_write_end(dev, pie->bits_per_pixel);
+	}
+
+	gs_free_object(vdev->memory, buf, "esmv_image_data(buf)");
+    }
+    return (pie->y += height) >= pie->height;
+}
+
+
+private int
+#if GS_VERSION_MAJOR >= 6
+esmv_image_end_image(gx_image_enum_common_t * info, bool draw_last)
+#else
+esmv_image_end_image(gx_device * dev, gx_image_enum_common_t * info, bool draw_last)
+#endif
+{
+#if GS_VERSION_MAJOR >= 6
+    gx_device *dev = info->dev;
+#endif
+    gx_device_vector		*const vdev = (gx_device_vector *) dev;
+    gx_device_esmv		*const pdev = (gx_device_esmv *) dev;
+    gdev_vector_image_enum_t	*pie = (gdev_vector_image_enum_t *) info;
+    int				code;
+
+    if (!(pdev -> reverse_y)) {
+	esmv_write_end(dev, pie->bits_per_pixel);
+    }
+
+    pdev->reverse_x = pdev->reverse_y = 0;
+    if (pdev->MaskReverse == 0) {
+      ;
+    }
+    pdev->MaskReverse = -1;
+
+    code = gdev_vector_end_image(vdev, (gdev_vector_image_enum_t *) pie, draw_last, pdev->white);
+    return code;
+}
+
+
+private void esmv_write_begin(gx_device *dev, int bits, int x, int y, int sw, int sh, int dw, int dh, int roll)
+{
+    gx_device_esmv *const       pdev = (gx_device_esmv *)dev;
+    stream			*s = gdev_vector_stream((gx_device_vector *)pdev);
+    char                        obuf[128];
+    int				comp;
+
+    (void)sprintf(obuf, ESC_GS "%dX" ESC_GS "%dY", x, y);
+    lputs(s, obuf);
+
+    comp = 10;
+
+    if (bits == 1) {
+      if (strcmp(pdev->dname, "lp1800") == 0 ||
+          strcmp(pdev->dname, "lp9600") == 0) {
+	(void)sprintf(obuf, ESC_GS "0bcI");
+      }else{
+	(void)sprintf(obuf, ESC_GS "5;%d;%d;%d;%d;%dsrI",  sw, sh, dw, dh, roll);
+      }
+    } else if (bits == 4) {
+	if (pdev -> c4map) {
+	    pdev -> c4map = FALSE;
+	}
+	(void)sprintf(obuf, ESC_GS "1;1;1;0;%d;%d;%d;%d;%d;%dscrI", comp, sw, sh, dw, dh, roll);
+    } else if (bits == 8) {
+	if (pdev -> c8map) {
+	    pdev -> c8map = FALSE;
+	}
+	(void)sprintf(obuf, ESC_GS "1;1;1;0;%d;%d;%d;%d;%d;%dscrI", comp, sw, sh, dw, dh, roll);
+    } else {
+	/* 24 bit */
+	(void)sprintf(obuf, ESC_GS "1;1;1;0;%d;%d;%d;%d;%d;%dscrI", comp, sw, sh, dw, dh, roll);
+    }    
+    lputs(s, obuf);
+
+    return;
+}
+
+
+private void esmv_write_data(gx_device *dev, int bits, char *buf, int bsize, int w, int ras)
+{
+    gx_device_vector *const     vdev = (gx_device_vector *) dev;
+    gx_device_esmv *const       pdev = (gx_device_esmv *) dev;
+    stream			*s = gdev_vector_stream((gx_device_vector *)pdev);
+    char                        obuf[128];
+    int				size;
+    char			*tmps, *p;
+
+    tmps = 0;
+
+    if (bits == 12) {
+      p = tmps = gs_alloc_bytes(vdev->memory, bsize * 2, "esmv_write_data(tmp)");
+	for (size = 0; size < bsize; size++) {
+	    *p++ = buf[size] & 0xF0;
+	    *p++ = buf[size] << 4;
+	}
+	bsize = bsize * 2;
+	buf = tmps;
+    }
+
+    if(bits == 4) {
+      p = tmps = gs_alloc_bytes(vdev->memory, bsize * 2, "esmv_write_data(tmp)");
+	for (size = 0; size < bsize; size++) {
+	    *p++ = ((buf[size] & 0xF0) * 0xFF / 0xF0);
+	    *p++ = ((buf[size] << 4 & 0xF0) * 0xFF / 0xF0);
+	}
+	bsize = bsize * 2;
+	buf = tmps;
+    }
+
+
+    if(bits == 1){
+      if (strcmp(pdev->dname, "lp1800") == 0 || \
+	  strcmp(pdev->dname, "lp9600") == 0) {
+	(void)sprintf(obuf, ESC_GS "%d;1;%d;%d;0db{I", bsize, w, ras);
+      }else{
+	(void)sprintf(obuf, ESC_GS "%d;%du{I", bsize, ras);
+      }
+    }else{
+      (void)sprintf(obuf, ESC_GS "%d;%dcu{I", bsize, ras);
+    }
+    lputs(s, obuf);
+
+    put_bytes(s, buf, bsize);
+
+    if (bits == 12 || bits == 4) {
+      gs_free_object(vdev->memory, tmps, "esmv_write_data(tmp)");
+    }
+
+    return;
+}
+
+
+private void esmv_write_end(gx_device *dev, int bits)
+{
+    gx_device_esmv *const       pdev = (gx_device_esmv *) dev;
+    stream			*s = gdev_vector_stream((gx_device_vector *)pdev);
+
+    if(bits == 1){
+      if (strcmp(pdev->dname, "lp1800") == 0 || \
+	  strcmp(pdev->dname, "lp9600") == 0) {
+	lputs(s, ESC_GS "1dbI");
+      } else {
+	lputs(s, ESC_GS "erI");
+      }
+    }else{
+      lputs(s, ESC_GS "ecrI");
+    }
+    return;
+}
+
diff -urN -x .svn espgs-8.15rc2/addons/gdevlx50.c trunk/addons/gdevlx50.c
--- espgs-8.15rc2/addons/gdevlx50.c	2005-01-22 01:26:52.000000000 +0100
+++ trunk/addons/gdevlx50.c	2005-03-14 00:04:03.651395939 +0100
@@ -2608,9 +2608,7 @@
 {
     int bpc = dev->color_info.depth / 4;
     int drop = sizeof(gx_color_value) * 8 - bpc;
-    gx_color_value cyan, magenta, yellow, black;
-
-    cyan = cv[0]; magenta = cv[1]; yellow = cv[2]; black = cv[3];
+    gx_color_value cyan = cv[0], magenta = cv[1], yellow = cv[2], black = cv[3];
     gx_color_index color =
     ((((((cyan >> drop) << bpc) +
 	(magenta >> drop)) << bpc) +
diff -urN -x .svn espgs-8.15rc2/addons/gdevmd2k.c trunk/addons/gdevmd2k.c
--- espgs-8.15rc2/addons/gdevmd2k.c	2005-01-22 05:05:08.000000000 +0100
+++ trunk/addons/gdevmd2k.c	2005-03-14 00:04:03.660395648 +0100
@@ -680,9 +680,7 @@
 		   const gx_color_value cv[])
 {
     int nbits = pdev->color_info.depth;
-    gx_color_value c, m, y, k;
-
-    c = cv[0]; m = cv[1]; y = cv[2]; k = cv[3];
+    gx_color_value c = cv[0], m = cv[1], y = cv[2], k = cv[3];
     ulong weight = ((gx_max_color_value - k) << 10) / gx_max_color_value;
     c = ((c * weight) >> 10) + k;
     m = ((m * weight) >> 10) + k;
diff -urN -x .svn espgs-8.15rc2/addons/japanese/dmp_init.ps trunk/addons/japanese/dmp_init.ps
--- espgs-8.15rc2/addons/japanese/dmp_init.ps	1970-01-01 01:00:00.000000000 +0100
+++ trunk/addons/japanese/dmp_init.ps	2005-03-14 00:03:52.413759268 +0100
@@ -0,0 +1,206 @@
+%!
+%    Copyright (C) 1989, 1992, 1993 Aladdin Enterprises.  All rights reserved.
+%
+% This file is part of Ghostscript.
+%
+% Ghostscript is distributed in the hope that it will be useful, but
+% WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility
+% to anyone for the consequences of using it or for whether it serves any
+% particular purpose or works at all, unless he says so in writing.  Refer
+% to the Ghostscript General Public License for full details.
+%
+% Everyone is granted permission to copy, modify and redistribute
+% Ghostscript, but only under the conditions described in the Ghostscript
+% General Public License.  A copy of this license is supposed to have been
+% given to you along with Ghostscript so you can know your rights and
+% responsibilities.  It should be in a file named COPYING.  Among other
+% things, the copyright notice and this notice must be preserved on all
+% copies.
+
+% dmp_init.ps
+%   Initialization file for `dmprt' device driver.
+%
+%   Written initial version by...         ASAYAMA Kazunori  1993 Nov.
+%   Modified for Ghostscript 4.03 by ...  ASAYAMA Kazunori  1997 May.
+
+%%%%%                        check version                         %%%%%
+
+201 % version of this initialization file.
+
+/dmprt finddevice { /DmprtParams gsgetdeviceprop /Version get }
+  stopped { pop pop 0 } if
+2 copy ne {
+  (\ndmprt: driver version\() print
+  dup 0 eq {pop (unknown) print }{==only}ifelse
+  (\) does not match dmp_init.ps version\() print
+  ==only (\).\n) print
+  flush 1 .quit
+} { pop pop } ifelse
+
+%%%%%                            BODY                              %%%%%
+
+40 dict begin         % .WorkDict .UserParams
+                      % .DmprtDevice
+                      % .GetDmprtParam .SetDmprtParam
+                      % .DmprtParams .Xdpi .Ydpi .Xdot .Ydot
+                      %
+                      % in cm mm pt bp dot
+                      % BeginMode EndMode
+                      % .ModeDataBase .CurrentMode
+                      % BeginConfig EndConfig
+                      % BeginPrinterProps EndPrinterProps
+
+/.WorkDict currentdict def
+/.ModeDataBase 10 dict def
+/.dicttomark {
+  counttomark 2 idiv dup dict begin { def } repeat pop currentdict end
+} bind def
+
+%%%%%                utilities for user customization.             %%%%%
+
+/in { } bind def
+/cm { 2.54 div } bind def
+/mm { 25.4 div } bind def
+/pt { 72.27 div } bind def
+/bp { 72.0 div } bind def
+/dot { [ exch truncate cvi ] } bind def
+
+% the database of user customizations. (not implemented yet.)
+/BeginMode { % <name> -> <name> mark
+  mark
+} bind def
+/EndMode { % <name> mark <item1> <value1> ... <itemN> <valueN> -> --
+  .dicttomark .ModeDataBase
+  dup dup maxlength exch length eq {
+    % Expand capacity of database dictionaly.
+    dup maxlength 10 add dict copy dup /.ModeDataBase exch def
+  } if
+  3 1 roll put
+} bind def
+
+% these procedures are undocumented in the user's manual.
+% these are used in order to specify the propaties directly.
+/BeginPrinterProps { [ } bind def
+/EndPrinterProps { ] /printer exch } bind def
+
+%%%%%                run the user customization file.              %%%%%
+
+/BeginConfig mark def
+/EndConfig { .dicttomark /.UserParams exch def } bind def
+systemdict /DMPCONFIG 2 copy known
+{ get run }    % -sDMPCONFIG=<filename>
+{ pop pop (dmp_site.ps) findlibfile { closefile run } if } ifelse
+
+%%%%%                        refer database                        %%%%%
+
+/.UsedMode .ModeDataBase length dict def
+/.ExpandUserParams { % <dict> -> <param1> <value1> ... <paramN> <valueN>
+  /.InheritMode null def
+  { 1 index /inherit eq {
+      exch pop dup .UsedMode exch known { % check recursive reference.
+        /.ExpandUserParams /rangecheck signalerror
+      } if
+      /.InheritMode exch def
+    } if } forall
+  .InheritMode type /nametype eq {
+    .UsedMode .InheritMode true put
+    .ModeDataBase .InheritMode get .ExpandUserParams
+  } if
+} bind def
+
+systemdict /DMPMODE 2 copy known
+  {get .ModeDataBase exch get} {pop pop .UserParams} ifelse
+mark exch .ExpandUserParams .dicttomark /.UserParams exch def
+
+%%%%%                Local variables and procedures.               %%%%%
+/.DmprtDevice /dmprt finddevice def
+/.SetDmprtParam {   % <key> <value> -> --
+  .DmprtParams 3 1 roll put
+} bind def
+/.SetLocalParam { .LocalParams 3 1 roll put } bind def
+/.GetDmprtParam {   % <key> -> <value>
+  .DmprtParams exch get
+} bind def
+/.GetUserParam {       % <key> <default-value> -> <value>
+  .UserParams 3 -1 roll 2 copy known {get exch pop}{pop pop} ifelse
+} bind def
+/.SetUserParam { % <prop-name> <key> <default-value> -> --
+  .GetUserParam .SetDmprtParam
+} bind def
+
+%%%%%                     dviprt proparties                        %%%%%
+
+mark
+.UserParams /printer 2 copy known {
+  get dup type /dicttype ne { mark /FileName 3 -1 roll .dicttomark } if
+}
+{ pop pop % Default printer is `ESC/P 24 pins'.
+    mark
+    /Name          (ESC/P 24 pins)
+    /Transpose     true
+    /Reverse       false
+    /NonMoving     false
+    /Encoding      (Null)
+    /HDpi           180
+    /VDpi           180
+    /Pins          24
+    /MinimalUnit   1
+    /MaximalUnit   180
+    /Constant      1
+    /BitImageMode  (\007\0333\030\033?Z\047)
+    /NormalMode    (\004\015\014\0332)
+    /SendBitImage  (\002\033Z\002\001\200)
+    /SkipSpaces    (\002\033\\\002\001\200)
+    /LineFeed      (\002\015\012)
+    /FormFeed      (\002\015\014)
+    /AfterBitImage ()
+    /BitRowHeader  ()
+    .dicttomark
+} ifelse
+/DviprtParams exch .DmprtDevice putdeviceprops
+
+getdeviceprops .dicttomark /.DmprtParams exch def
+.DmprtParams /DviprtParams get /.DviprtParams exch def
+.DmprtParams /DmprtParams get /.LocalParams exch def
+
+% calcurate resolutions and define operators converting
+% from user-coordination to device-coordination(count by dots).
+/resolution [ .DviprtParams dup /HDpi get exch /VDpi get ]
+  .GetUserParam {} forall /.Ydpi exch def /.Xdpi exch def
+/.Xdot { dup type /arraytype eq { 0 get } { .Xdpi mul truncate cvi } ifelse
+} bind def
+/.Ydot { dup type /arraytype eq { 0 get } { .Ydpi mul truncate cvi } ifelse
+} bind def
+
+%%%%%           Standard Ghostscript device propaties.             %%%%%
+
+/HWSize  % default is A4.
+  /defaultsize [8.3 11.7] .GetUserParam
+  [ exch dup 0 get .Xdot exch 1 get .Ydot ] .SetDmprtParam
+
+%%%%%                   dmprt device propaties.                    %%%%%
+
+/MaxSize
+  /maxsize [0.0 0.0] .GetUserParam [ exch dup 0 get .Xdot exch 1 get .Ydot ]
+  .SetLocalParam
+/Margins /margin [0.0 0.0 0.0 0.0] .GetUserParam
+  [ exch dup 0 get .Xdot exch dup 1 get .Ydot
+    exch dup 2 get .Xdot exch     3 get .Ydot ] .SetLocalParam
+/Verbose QUIET {false}
+  {/verbose false .GetUserParam} ifelse .SetLocalParam
+/Debug /debug false .GetUserParam .SetLocalParam
+
+%%%%%                   Page device propaties.                     %%%%%
+%%%%%         See PostScript Reference Manual 2nd edition.         %%%%%
+
+/HWResolution [ .Xdpi .Ydpi ] .SetDmprtParam
+/Offsets
+  /offset [0.0 0.0] .GetUserParam [ exch dup 0 get .Xdot exch 1 get .Ydot ]
+  .SetLocalParam
+
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+
+mark .DmprtParams {} forall .DmprtDevice putdeviceprops pop
+
+end
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%   End of file   %%%%%%%%%%%%%%%%%%%%%%%%%%%
diff -urN -x .svn espgs-8.15rc2/addons/japanese/dmp_site.ps trunk/addons/japanese/dmp_site.ps
--- espgs-8.15rc2/addons/japanese/dmp_site.ps	1970-01-01 01:00:00.000000000 +0100
+++ trunk/addons/japanese/dmp_site.ps	2005-03-14 00:03:52.420759042 +0100
@@ -0,0 +1,14 @@
+%!
+BeginConfig
+%%%%%%%%%%%%%%%%%%%%%% Standard user cusomizations %%%%%%%%%%%%%%%%%%%%%
+/printer      (escp_24.src)
+%               horizontal / vertical
+% /resolution   [ 180.0 180.0 ]
+%               horizontal / vertical
+% /offset       [ 0.0 0.0 ]
+%               width / height
+% /defaultsize  [ 8.0 in 11.0 in ]
+%               width / height
+% /maxsize      [ 8.0 -1 ]
+%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
+EndConfig
diff -urN -x .svn espgs-8.15rc2/addons/japanese/doc/cdj880.txt trunk/addons/japanese/doc/cdj880.txt
--- espgs-8.15rc2/addons/japanese/doc/cdj880.txt	1970-01-01 01:00:00.000000000 +0100
+++ trunk/addons/japanese/doc/cdj880.txt	2005-03-14 00:03:52.042771263 +0100
@@ -0,0 +1,120 @@
+Patched Ghostscript driver for HP DeskJet 880C/882C and 895C printers.
+
+Matthew J. Gelhaus (mgelhaus@proaxis.com)
+Updated March 30, 1999
+
+****************************************************
+* 注意:                                            *
+* cdj880 についてのみ次のような変更をしてあります。*
+* 1. Time out Error が出ないようした。             *
+* 2. -r オプションで解像度が変更できるようにした。 *
+* (よって -dQuality オプションは使用できません。)  *
+*                                                  *
+* 大森紀人 <ohmori@p.chiba-u.ac.jp>                *
+****************************************************
+
+This package is based very heavily on the work of Uli Wortmann
+(uli@bonk.ethz.ch), and I do not claim to be the original author of very
+much of this code.  Uli has done a tremendous amount of excellent work, and
+this package is a modification to his driver by me to add the ability to print
+to the DeskJet 880C, 882C, and 895C printers.  Under the terms of the GNU
+General Public License (see LICENSING TERMS below), I am distributing this
+package under the same license.
+
+Please also see the file readme.hp8 for Uli's notes about the package.
+
+It is my intent to submit this work as a patch to Uli Wortmann for inclusion
+in the original HP850C driver package.
+
+LICENSING TERMS:
+
+    Copyright (C) 1999  <Matthew J. Gelhaus mgelhaus@proaxis.com>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+    
+    To view the General Public License in its entirety, check the file
+    LICENSE.
+
+DISCLAIMER:
+
+This is a work still under development, and as such I do not guarantee
+it will work (see LICENSING TERMS above).  However, please send bug
+reports to me (mgelhaus@proaxis.com), along with as much information
+as you can.
+
+SYSTEM REQUIREMENTS:
+
+This package is designed to work with Aladdin Ghostscript 5.50 (available
+from ftp://ftp.cs.wisc.edu/ghost/aladdin/gs550/).  It may work with earlier
+versions of Ghostscript, but I have not tested it.  You can follow the
+directions included to compile Ghostscript, but here are is a condensed
+version that worked for me:
+
+INSTALLATION INSTRUCTIONS:
+
+1.  Obtain the files 
+       
+       ghostscript-5.50.tar.gz            2826251 bytes 
+       jpegsrc.v6b.tar.gz                  613261 bytes 
+       libpng-1.0.2.tar.gz                 225386 bytes 
+       zlib-1.1.3.tar.gz                   168463 bytes
+       ghostscript-fonts-std-5.50.tar.gz  1444863 bytes 
+       
+2.  Create a directory to perform the build in, for example,
+    /usr/local/src/gs.  Unpack each of the files into this directory:
+    
+    $ cd /usr/local/src
+    $ mkdir gs ; cd gs
+    $ tar zxvf $HOME/ghostscript-5.50.tar.gz
+    $ tar zxvf $HOME/jpegsrc.v6b.tar.gz
+    $ tar zxvf $HOME/libpng-1.0.2.tar.gz
+    $ tar zxvf $HOME/zlib-1.1.3.tar.gz
+    
+3.  Copy all the files from this driver package into the ghostscript
+    directory.  For example,
+    
+    $ cp $HOME/hp850C-880p/* /usr/local/src/gs/gs5.50/
+    
+    This will overwrite the files contrib.mak and makefile.  This is OK.
+
+4.  If desired, edit the makefile.  This should only be necessary if you
+    want to build a ghostscript binary that uses your existing PNG and
+    ZLIB libraries dynamically.  Normally ghostscript compiles these in
+    statically.  Note that you still need to download the sources to those
+    libraries (as listed in step 1) even if you want to link dynamically.
+    
+5.  There is a bug (I think) in the ghostscript source.  If during the make
+    it fails to build due to a missing "arch.h" in the file std.h, you can
+    fix it by changing line 28 of std.h from
+    
+        #include "arch.h"
+        
+    to
+    
+        #include "obj/arch.h"
+
+6.  Type 'make'.
+
+7.  Type 'make install' (as root).
+
+7.  To specify the 880C/882C/895C driver, use -sDEVICE=cdj880:
+
+    $ gs test.ps -sDEVICE=cdj880 -dNOPAUSE -dSAFER -sOutputFile=- | lpr
+    
+
+Please, please, please report any bugs to me at mgelhaus@proaxis.com.  This
+includes installation instruction bugs, because I was doing this from
+memory!
+
diff -urN -x .svn espgs-8.15rc2/addons/japanese/doc/dj505j.txt trunk/addons/japanese/doc/dj505j.txt
--- espgs-8.15rc2/addons/japanese/doc/dj505j.txt	1970-01-01 01:00:00.000000000 +0100
+++ trunk/addons/japanese/doc/dj505j.txt	2005-03-14 00:03:51.621784873 +0100
@@ -0,0 +1,62 @@
+■                                                                    ■
+■                         Ghostscript 5.10                           ■
+■                       DeskJet 505J ドライバ                        ■
+■                                                                    ■
+
+                                                                大森紀人
+                                                  ohmori@p.chiba-u.ac.jp
+
+※ほとんどこのドキュメントはオリジナルのままです。
+
+           オリジナル(Ghostscript 2.6.1 DeskJet 505J ドライバ)の作者さん
+                                                               淺山 和典
+                                                    TPM03937@pcvan.or.jp
+                                               GHF01532@niftyserve.or.jp
+
+
+========================================================================
+● １． はじめに
+========================================================================
+
+  Ghostscript 5.10 に付属の DeskJet 用ドライバ (gdevcdj.c) に手を加えて
+Hewlett Packard 社の DeskJet 505J (Plus) 用のドライバを追加したものです。
+カラー印刷も可能です。
+
+========================================================================
+● ２． 組込み
+========================================================================
+
+  次の手順で組み込みます。
+
+(1) gdevcdj.c にパッチ gdevcdj.dif を当てる。
+(2) gdev505j.mak を makefile に追加する。
+(3) makefile の DEVICE_DEVS(または DEVICE_DEVS1〜DEVICE_DEVS9 の何れか)
+    に dj505j.dev を追加する。
+(4) make を実行する。
+
+========================================================================
+● ３． 使い方
+========================================================================
+
+  モノクロ印字の場合は他のドライバと同様です。オプション
+"-sDEVICE=dj505j" 付きで gs を起動してください。
+
+  カラー印字は、gs の起動オプションに "-dBitsPerPixel=3" を追加します。
+
+  詳しくは Ghostscript 5.10 の配布に含まれる devices.txt の DeskJet 系
+ドライバの使い方の説明をご覧ください。
+
+========================================================================
+● ４． 備考
+========================================================================
+
+  カラー印刷の場合、全体的に色が緑がかりますが、これは DeskJet のカラー
+インクの特性です。DeskJet 505J は CMY による 3 色刷りです。このため CMYK
+の 4 色刷りに比べて黒がきれいに出ません。
+
+  カラー印刷は多くのメモリを必要とします。1 pixel 当たり 1byte のフレー
+ムバッファを確保するためですが、このドライバに必要なメモリの他に gs 本体
+の動作に必要なメモリもありますから、A4 サイズの出力を行うためには 10 数
+MB のメモリが必要です。
+
+=========================== End of document ============================
diff -urN -x .svn espgs-8.15rc2/addons/japanese/doc/djgpp.txt trunk/addons/japanese/doc/djgpp.txt
--- espgs-8.15rc2/addons/japanese/doc/djgpp.txt	1970-01-01 01:00:00.000000000 +0100
+++ trunk/addons/japanese/doc/djgpp.txt	2005-03-14 00:03:51.676783095 +0100
@@ -0,0 +1,510 @@
+■                                                                    ■
+■              Ghostscript 2.6.1 DJ's GPP 化パッケージ               ■
+■                            version 1.3                             ■
+■                                                                    ■
+■                  Copyright (C) 1993,1994 淺山和典                  ■
+■                        TPM03937@pcvan.or.jp                        ■
+■                     GHF01532@niftyserve.or.jp                      ■
+■                                                                    ■
+
+========================================================================
+● １． パッケージ内容
+========================================================================
+
+  このパッケージには以下のファイル、ディレクトリが含まれています。これら
+の中には、機種・OS に依存せずに使えるファイルも含まれています (後述)。
+
+ COPYING         ・GNU General Public License (GNU GPL)
+ djgpp.sj        ・このファイル
+ djgpp.mak       ・Makefile
+ djgpp.dif       ・Ghostscript 2.6.1オリジナルのコードに対する差分
+ gp_djgpp.c      ・DJ's GPP環境依存のコード
+ djgpp.h         ・同上
+ gp_djgpp.h      ・同上
+ gp_pc98.c       ・NEC PC-9801/PC-H98依存のコード
+ gp_pcat.c       ・IBM PC/AT互換機依存のコード
+ gs_djgpp.tr     ・リンカ用のレスポンスファイル
+ gp_djgpp.ps     ・DJ's GPP環境の初期化PSファイル
+ gp_site.ps      ・DJ's GPP環境の環境設定ファイル
+ gssetdjg.bat    ・Makefile から呼び出すバッチファイル
+ gdevgppr.h      ・プリンタドライバをDJ's GPP対応するためのヘッダ
+ zkfpc98.c       ・NEC PC-9801/PC-H98 漢字ROMフォントドライバのソース
+ zkfvflib.c      ・VFlibを使用するフォントドライバ
+ zkfvflib.mak    ・同上
+ kfvflib.sj      ・VFlib使用のフォントドライバのドキュメント
+ drivers/        ・各種デバイスドライバがあるディレクトリ
+  |---gdev10v/     ・日本語化パッケージ付属の Canon BJ10V ドライバへの
+  |                  差分
+  |---gdev98hf/    ・デジタルアーツ社 Hyper-Frame+ 用フルカラー・ディス
+  |                  プレイドライバ
+  |---gdevcdj/     ・オリジナルパッケージに付属の HP DeskJetシリーズ用
+  |                  のドライバを DeskJet 505J に対応させるための差分
+  |---gdevdjgp/    ・IBM PC / AT互換機 のディスプレイドライバ
+  |---gdevdmpr/    ・汎用プリンタドライバ
+  |---gdevlips/    ・日本語化パッケージ付属の LIPS プリンタドライバへの
+  |                  差分
+  |---gdevmag/     ・鮪フォーマットの画像データを出力するためのドライバ
+  |---gdevp201/    ・日本語化パッケージ付属の NEC PC-PR 201 ドライバを
+  |                  PC-PR 150 / PC-PR 1000 / PC-PR 1000/4 に対応させる
+  |                  ための差分
+  +---gdevpc98/    ・NEC PC-9801 / H98 のディスプレイドライバ
+ kanji/          ・DJ's GPP版固有の漢字初期化ファイルがあるディレクトリ
+
+
+========================================================================
+● ２． はじめに
+========================================================================
+
+  このパッケージは Ghostscript version 2.6.1 を DJ's GPP でコンパイルし、
+NEC PC-9801/PC-H98、IBM PC/AT 互換機で利用できるようにするためのパッケー
+ジです。
+
+  作成されるバイナリは全機種共通です。機種は自動判別されます (ユーザが直
+接機種を指定することも可能です)。
+
+  また片山紀生さんによる日本語化パッケージ 1.0 と併用することを前提とし
+ていますが、Makefile を書き換えれば日本語化されていないものもコンパイル
+可能です。
+
+
+========================================================================
+● ３． 機種・OS依存性に関して
+========================================================================
+
+  このパッケージに含まれているもののうち、以下のものを除いて機種や OS に
+関係なくそのまま使用することが出来ます。
+
+ ・ gp_djgpp.c gp_pc98.c gp_pcat.c gp_djgpp.h djgpp.h
+      これはプラットフォーム依存のコード (ここでは DJ's GPP+GO32 用) を
+    定義したファイルです。Ghostscript のオリジナルパッケージには各環境用
+    のものが用意されていますので、GO32 環境以外のかたはそちらを利用して
+    ください。
+ ・ djgpp.mak djgpp.dif
+      DJ's GPP でコンパイルするための差分と makefile です。
+ ・ gp_djgpp.ps gp_site.ps
+      このパッケージを使って DJ's GPP でコンパイルした実行形式のための初
+    期化ファイルです。
+ ・ gdevdjgp/ gdevpc98/ gdev98hf/
+      ディスプレイドライバ各種。機種依存です。
+
+
+========================================================================
+● ４． コンパイルの方法
+========================================================================
+
+  次の手順でコンパイルしてください。
+
+(1) オリジナルのソースのアーカイブを展開する。以下の作業は、この作業によ
+    って作られる./gs261 というディレクトリに移って行います。
+
+(2) バグフィクス差分を当てます。
+
+(3) このパッケージに含まれているファイル及び日本語化パッケージのファイル
+    をこのディレクトリにコピーします。
+
+(4) パッチ djgpp.dif、及び日本語化差分をあてます (順序は問わない)。
+    djgpp.dif は genconf.c および ps2epsi.ps に対する差分です。
+
+    日本語化を行わない場合には djgpp.dif だけを適用してください。
+
+      patch < gs261j.dif
+      patch < djgpp.dif
+
+
+        ※パッチがうまく当たらない場合。
+
+          Ghostscript オリジナルのファイル (バグ修正差分を含む)、日本語
+          化パッチ (gs261j.diff)、DJ's GPP 対応パッチ (djgpp.dif)、は全
+          て UN*X 形式の改行コード (Line Feed のみ) です。MS-DOS 版の
+          patch.exe では、そのポーティングによってはうまくパッチが当たら
+          ないことがあるかもしれません。
+
+          このような場合は、総てのファイルの改行コードを MS-DOS 形式
+          (Carriage Return + Line Feed) に変更してから patch.exe を使う
+          か、あるいは UN*X 上でパッチを当てるところまでの作業を行ってそ
+          れから MS-DOS 上にファイルを持ってきて以下の作業を行なってくだ
+          さい。
+
+(5) 日本語化パッケージ、またはこのパッケージに付属しているデバイスドライ
+    バを組み込む場合には、それをカレントディレクトリにコピーする (これら
+    のデバイスドライバはディレクトリ drivers にあります)。
+
+    日本語化パッケージに付属のプリンタドライバのなかにはさらに差分を当て
+    る必要があるものがあります。またオリジナルのパッケージに付属のプリン
+    タドライバを組み込むためには前処理が必要です。
+
+    詳しくはこのドキュメントの「プリンタドライバの組込み」をご覧ください。
+
+    なおこのパッケージに付属のプリンタドライバ・ディスプレイドライバは前
+    処理なしでそのまま組み込めます。
+
+(6) djgpp.mak を編集する。
+
+    DJ's gpp 環境の Makefile は djgpp.mak というファイルです。この中の以
+    下のマクロを書き換えます。
+
+    (A)
+        DJGPP_PLATFORMS= ...
+
+        プリンタ出力ルーチンなどの機種依存コードをどの機種用のものを組み
+        込むかを指定します。主にプリンタ出力関係のコードです。ディスプレ
+        イ出力に関してはこれとは別に DEVICE_DEVS で指定します。NEC
+        PC-9801、IBM PC/AT 互換機用のプリンタ出力ルーチンが用意されてい
+        ます。
+
+        pc98_、pcat_ から選びます。両方を指定することも可能です。このパ
+        ッケージに含まれている djgpp.mak では両方を組み込むようにしてあ
+        ります。
+
+        この指定を空にしておくと機種依存コードを組み込まず全てのプリンタ
+        コードは標準プリンタ出力 ("PRN") 経由で出力されるようになります。
+
+    (B)
+        FEATURE_DEVS= ...
+
+        漢字フォントドライバを追加したい場合にはここに書き加えます。
+
+        このパッケージに含まれる djgpp.mak では、書体倶楽部フォント、JG
+        フォント、NEC PC-9801 ROM フォント、を利用する漢字フォントドライ
+        バを組み込むようになっています。
+
+        VFlib ver 2.13 以降と併用することにより漢字 TrueType フォントを
+        利用できるようになります。詳しくは kfvflib.sj をご覧ください。
+
+        また、日本語化を行わない場合には、kanji.dev 以降行末までを削除し
+        てください。
+
+    (C)
+        DEVICE_DEVS= ...
+        DEVICE_DEVS1=
+         :
+         :
+        DEVICE_DEVS9=
+
+        プレビューア、プリンタドライバなどの出力ドライバをここに空白文字
+        で区切ってならべます。
+
+        DEVICE_DEVS、DEVICE_DEVS1〜DEVICE_DEVS9 の 10 個のマクロに分けて
+        あるのは MS-DOS のコマンドライン長の制限のためです。たくさんのデ
+        バイスドライバを組み込む場合には、一つのマクロの定義が長くなりす
+        ぎないように 10 個に適当に振り分けてください。
+
+        このパッケージに含まれている djgpp.mak では何も組み込まないよう
+        になっています。
+
+        通常はディスプレイドライバは組み込む必要があります。
+
+         機種           デバイス名 ソースコードがあるディレクトリ
+         PC-9801/PC-H98 pc98.dev   drivers/gdevpc98/
+         IBM PC/AT      djgpp.dev  drivers/gdevdjgp/
+
+        日本語化パッケージ、及びこのパッケージに付属のデバイスドライバを
+        組み込む場合には、それぞれのソースプログラムを他の Ghostscript
+        のソースプログラムのあるディレクトリにコピーし、さらにそれぞれの
+        ドライバに付属の Makefile の内容を djgpp.mak に追加、または
+        !include " ファイル名 " として取り込んでください。
+
+    DJ's GPP の 1.12 以降を使う場合には、djgpp.mak 内のマクロ AOUT2EXE
+    の定義を 'coff2exe' に書き換えてください。デフォルトでは 'aout2exe'
+    になっています。
+
+(7) djgpp.mak を Makefile として make を実行する。
+
+      make -f djgpp.mak
+
+      djgpp.mak は Borland make 用です。その他の make を使う場合には、こ
+    のパッケージに付属の tarcat.pl を使って 「!include " ファイル名 "」
+    の部分をその中味で置き換えて、それを Makefile として使ってください。
+    perl スクリプトです。以下のようにして使います。このスクリプトでは
+    !include は入れ子になっていても処理できます。
+
+      jperl tarcat.pl djgpp.mak > merged.mak
+
+      make 用のバッチファイル (gsaddmod.bat など) はオリジナルのパッケー
+    ジに含まれる Turbo C++/Borland C++ 用のものをそのまま用います。この
+    パッケージではさらにオリジナルのパッケージのものに加えて
+    gssetdjg.bat というバッチファイルが追加されています。カレントディレ
+    クトリ (gs261) にこれらのバッチファイルがあることを確認してください。
+
+      このパッケージに含まれていないデバイスドライバを PC-9801 や PC/AT
+    互換機に対応させるための方法は本ドキュメントの最後に記してあります。
+
+
+========================================================================
+● ５． 使用法
+========================================================================
+
+  ここでは、DJ's GPP 版特有のことについてのみ述べます。Ghostscript 一般
+の設定作業、使用法についてはオリジナルのドキュメントをご覧ください。
+
+-----------
+★ 5.1 設定
+-----------
+
+(1) このパッケージの kanji ディレクトリにある PostScript ファイルを日本
+    語化パッケージの kanji ディレクトリ下のファイルと同じディレクトリに
+    コピーする。
+
+(2) このパッケージに含まれる gp_djgpp.ps と gp_site.ps を Ghostscript の
+    ライブラリを置くディレクトリ (gs_init.ps などを置くディレクトリ) に
+    コピーする。
+
+(3) 必要であれば gp_site.ps の機種指定部分などを編集する。
+
+      本バージョンでは機種 (98/PC/ その他) は自動判別します。したがって、
+    運がよければ特に設定を行なう必要はなく、そのまま使えます。
+
+      が、場合によっては判定を誤るかもしれません。その場合には、
+    gp_site.ps を以下のように編集して「明示的に」機種を指定してください。
+
+      具体的には、付属の gp_site.ps には可能な設定がコメント ('%' 以降改
+    行まで) 化されていますので、それらのうちひとつを Uncomment してくだ
+    さい。
+
+    % /Name (PC-AT)      % ...
+    % /Name (PC-9801)    % ...
+    % /Name (OTHER)      % ...
+
+    の行頭の '%' のうちひとつを取り除きます。
+
+      なお、自動判別を行なった場合には、自動的にその機種に /Name が設定
+    されます。
+
+
+      以下はオプショナルな設定なので通常は必要ありません。デフォルトの設
+    定でうまくいかない場合やデフォルトの設定で不満なときにこれらの設定を
+    行なってください。
+
+(4) プリンタ出力の方法の指定 (/PrintTarget)
+(5) プリンタ出力バッファのサイズの指定 (/PrintBufferSize)
+(6) プリンタ出力の速さの指定 (/PrintWait)
+(7) デフォルトのデバイスドライバの指定 (/DefaultDevice)
+
+  /Name の設定を行うと、
+
+ ・ プリンタ出力の方法 (/PrintTarget など)
+ ・ デフォルトのデバイスドライバ (/DefaultDevice)
+
+が、各機種にあったものに自動的に設定されます。
+
+  ここで、各設定の意味は以下のようになっています。
+
+ ・ /PrintTarget
+      プリンタ出力を、プリンタポート、プリンタ BIOS、標準プリンタ出力、
+    のうちのどれを用いて行うかを設定します。
+      (PORT),(PORT1),(PORT2),(PORT3),(BIOS),(STDPRN) のどれかの値をとり
+    ます。(PORT) と (PORT1) は等価です。
+
+      デフォルトは PC-9801、IBM PC/AT 互換機では (BIOS)、それ以外では
+    (STDPRN) です。
+
+ ・ /PrintBufferSize
+      プリンタ出力用のバッファのバイト数です。プリンタに送られるデータは
+    一旦このバッファに貯えられ、バッファがいっぱいになったときにまとめて
+    プリンタに送信されます。64 以上 32767 以下の整数です。デフォルトでは
+    1024(bytes) です。
+
+ ・ /PrintWait
+      プリンタ出力時の「待ち」です。この設定値が大きいほどゆっくりと出力
+    されます。「待ち」は /PrintBufferSize ぶんのデータを出力するごとに入
+    り、待ち時間は設定値の二乗にほぼ比例します。
+
+      LAN 環境やプリンタスプーラでプリンタ BIOS をフックしている場合にプ
+    リンタコードをとりこぼしてしまうようなときにはこの値を大きく設定する
+    か、この値をある程度の大きさに設定しておいて /PrintBufferSize の値を
+    小さくします。
+
+      /PrintBufferSize の値が小さいほど頻繁に「待ち」が発生することにな
+    り、/PrintWait の値が大きいほど一回あたりの「待ち」が長くなることに
+    なります。
+
+      設定できる値は 0 以上 2048 以下の整数です。デフォルトでは 0(待ちな
+    し) です。
+
+ ・ /DefaultDevice
+      Ghostscript を -sDEVICE=<driver> オプションを指定せずに、かつ環境
+    変数 GS_DEVICE を設定せずに立ち上げた場合に使用するデバイスドライバ
+    です。通常は機種にあったディスプレイドライバを指定しておきます。
+
+      コマンドラインで
+
+      gs -h
+
+    と Ghostscript を立ち上げたときに、
+
+      Available devices:
+
+    という部分に出力されるもの中から選びます。
+
+  /Name 毎の各デフォルト値は、
+
+         +---------+-----------------------------------------+
+         |/Name    |/PrintTarget     /DefaultDevice          |
+         +---------+-----------------------------------------+
+         |(PC-AT)  |ポート1番        (djgpp)  -sDEVICE=djgpp |
+         |(PC-9801)|ポート           (pc98)  -sDEVICE=pc98   |
+         |(OTHER)  |標準プリンタ出力 nulldevice  -dNODISPLAY |
+         +---------+-----------------------------------------+
+
+で、/Name がいずれの場合も /PrintWait は 0、/PrintBufferSize は 1024 で
+す。
+
+  これらはユーザが gp_site.ps 中で /PrintTarget、/DefaultDevice などを明
+示的に指定することによって変更することが出来ます。
+
+  指定の方法は、
+
+  /DefaultDevice (pc98)
+
+のように、
+
+  /指定項目 値
+
+とします。gp_site.ps に設定例をコメントとして記述してありますので参考に
+してください。
+
+    ※  '%' 以降、行末まではコメントです。
+
+  /Name に (OTHER) を指定したときには、機種依存の動作を全く行いません。
+NEC PC-9801 や IBM PC/AT 互換機以外の機種で利用する場合にはこれを指定し
+てください。プリンタ出力は標準プリンタ出力を使い、デフォルトのデバイスは
+nulldevice (グラフィック画面への出力を一切行わないデバイス。コマンドライ
+ンで -dNODISPLAY を指定した場合と等価) になります。
+
+
+========================================================================
+● ６． プリンタドライバの組込み
+========================================================================
+-----------------------------------------
+★ 6.1 本パッケージ付属のプリンタドライバ
+-----------------------------------------
+
+  各プリンタドライバのドキュメントにしたがって組み込んでください。
+
+
+-----------------------------------------------
+★ 6.2 日本語化パッケージ付属のプリンタドライバ
+-----------------------------------------------
+
+  drivers ディレクトリの下の各サブディレクトリに拡張子.dif のファイルが
+ある場合には、それは gs 2.6.1 日本語化パッケージに付属のプリンタドライバ
+に対する差分です。この差分をあてることにより日本語化パッケージに付属のプ
+リンタドライバが使えるようになります。
+
+  日本語化差分に付属のプリンタドライバははじめから NEC PC-9801 に対応し
+ている場合もありますが、NEC PC-H98 や IBM PC/AT 互換機に対応させるために
+はこのパッケージに付属の差分をあててください。PC-9801 で使用する場合にも、
+BIOS 出力などの機能を使うには差分をあてる必要があります。
+
+  また、日本語化パッケージに付属のプリンタドライバの中でこのパッケージに
+特に対応差分が含まれていないものは次の説明にしたがって作業することによっ
+て PC-9801 や PC/AT で利用できるようになります。
+
+
+-------------------------------
+★ 6.3 その他のプリンタドライバ
+-------------------------------
+
+  今バージョンではプリンタ出力のためのルーチンを全て gp_djgpp.c で用意し
+ています。このためデバイスドライバのソース内で読み込むヘッダファイルを一
+つ追加するだけでこれまで PC-9801 などに対応していなかったプリンタドライ
+バも利用することが出来るようになります。
+
+  この方法で対応できるプリンタドライバは、コードの出力を
+putc(),fputc(),fputs(),fwrite(),fprintf(),vfprintf(),fflush() のストリー
+ム出力関数を使って行なっているものです。write() などの低水準出力関数を使
+うものは対応できません。
+
+  また、プリンタのオープンに gp_printer_open()、クローズに
+gp_printer_close() を使っていなければなりません。gdevprn.c で定義されて
+いる関数を利用しているドライバ (gdevprn.h を取り込んでいるドライバ) であ
+れば間違いなくこの条件を満たしています。
+
+  以下の手順で (再) コンパイルしてください。
+
+(1) このパッケージに付属の gdevgppr.h をドライバのソースファイルでインク
+    ルードする。
+
+    #include "gdevgppr.h"
+
+(2) (再) コンパイルする。
+
+
+========================================================================
+● ７． 前バージョンからの変更点
+========================================================================
+
+  DJ's GPP 対応パッケージの前バージョン (1.2) から以下の点が変更されてい
+ます。
+
+ ・ 不具合の修正
+     ‐ ユーティリティ ps2epsi が正常に動作しなかった不具合を修正。
+     ‐ VFlib 漢字ドライバで、カレントディレクトリに vfontcap があると正
+        常に動作しなかった不具合を修正。
+     ‐ dmprt ドライバで一部のプリンタで正常に動作しなかった不具合を修正。
+ ・ 出力方法に関する機能拡張・変更
+     ‐ IBM PC/AT 互換機のプリンタ BIOS 経由の出力に対応。
+     ‐ プリンタ出力のデフォルトを BIOS に変更。
+     ‐ プリンタ出力の速度を調節できるように変更。
+     ‐ プリンタ出力バッファのサイズを調節できるように変更。
+ ・ デバイスドライバの機能拡張
+     ‐ dmprt ドライバを dviprt 2.42 以降のプリンタ定義ファイルに対応。
+ ・ デバイスドライバの追加
+     ‐ HP DeskJet 505J
+     ‐ Hyper-Frame+
+     ‐ 鮪 フォーマットデータ
+ ・ その他
+     ‐ 機種を自動判別するようにした。
+     ‐ PC-9801, IBM PC/AT 互換機 に対応していないプリンタドライバの組み
+        込みかたを変更 (djdriver.pl と gp_print.h を削除。gdevgppr.h を
+        追加。)
+     ‐ 初期化ファイル gp_djgpp.ps から、ユーザが編集する部分を別ファイ
+        ル gp_site.ps に分離。書式も若干変更。
+
+
+========================================================================
+● ８． 謝辞
+========================================================================
+GO32 版のパッケージを作成するにあたり、大変多くの方にお世話になりました。
+
+ ・ 東京大学の片山紀生さんには、たくさんのご助言やβテスト版からの日本語
+    化パッケージの提供をしていただきました。
+
+ ・ PC-VAN SSCIENCE のとがしさんには、IBM PC/AT 互換機での動作確認、テス
+    トバイナリの作成など大変お世話になりました。
+
+ ・ PC-VAN SSCIENCE の OkI さんには、NEC H98 対応、動作確認等大変お世話
+    になりました。
+
+ ・ PC-VAN SSCIENCE の SOLITON さんは、IBM PC/AT 互換機用のディスプレイ
+    ドライバを公開してくださいました。また、ドライバの修正にあたって多く
+    のご助言をいただきました。
+
+ ・ Nifty Serve FLABO の KEN さんには IBM PC/AT 互換機用のディスプレイド
+    ライバの不具合修正にあたって、貴重なご助言をいただきました。
+
+ ・ hero.h さんには、IBM PC/AT 互換機用のプリンタ出力コードを作成してい
+    ただきました。
+
+ ・ VFlib のアウトライン取得関数の実装のおかげで漢字 TrueType フォントを
+    サポートすることができました。VFlib の作者である広島大学の角川裕次さ
+    ん、VFlib の漢字 TrueType 対応を行ってくださった PC-VAN SSCIENCE の
+    松田一郎さんを始めとする VFlib 開発にかかわっていらっしゃる方々に感
+    謝します。
+
+ ・ 最後になりますが、Louis IX さんを始めとする PC-VAN SSCIENCE のみなさ
+    んには幾度にも渡る動作テスト・報告、を行っていただきました。ありがと
+    うございました。
+
+
+========================================================================
+● ９． 再配布・保証
+========================================================================
+
+  DJ's GPP 対応部分に関しては GNU General Public License (GPL) に従いま
+す。GNU GPL については COPYING というファイルに記されています。
+
+  各種デバイスドライバ、フォントドライバについてはそれぞれのドキュメント、
+ソースファイルに記してある条件に従います。
+
+=========================== End of Document ============================
diff -urN -x .svn espgs-8.15rc2/addons/japanese/doc/gdev10v.txt trunk/addons/japanese/doc/gdev10v.txt
--- espgs-8.15rc2/addons/japanese/doc/gdev10v.txt	1970-01-01 01:00:00.000000000 +0100
+++ trunk/addons/japanese/doc/gdev10v.txt	2005-03-14 00:03:52.027771748 +0100
@@ -0,0 +1,52 @@
+
+	gdev10v.c  -  BJ10v用デバイスドライバ
+
+
+○インストール方法
+
+1. gdev10v.c を gs261 のソースプログラムがあるディレクトリにコピーし
+   て下さい。
+
+2. Makefile に gdev10v.mak を追加して下さい。 このとき、もしPC9801上の
+   MS-DOSでお使いなら、-DPC9801を加えてコンパイルするようにして下さい
+   (gdev10v.mak参照)。
+
+3. Makefile の DEVICE_DEVS に bj10v.dev, bj10vh.dev を加えて下さい。
+
+    例) DEVICE_DEVS=pc98.dev bj10v.dev bj10vh.dev
+			     ^^^^^^^^^ ^^^^^^^^^^
+
+4. make コマンドで gs をコンパイルし、インストールして下さい。
+
+
+○使い方
+
+＊ 2つのデバイスを用意したのは BJ10v の DIP スイッチ 4 番(上マージン)
+   の設定によって印字領域のサイズが異なるためで、以下のように対応して
+   います。
+
+   デバイス名  DIPスイッチ4       意味
+   ----------------------------------------------------------------
+   bj10vh       ON	     上マージン 8.5mm, 印字高 10.8 インチ
+   bj10v        OFF	     上マージン 22mm,  印字高 10.3 インチ
+
+   お使いの DIP スイッチ設定に合わせたデバイス名を選んで下さい。 なお、
+   BJ10v の出荷時の設定では DIP スイッチ 4 番は OFF になっています。
+
+
+＊デバイスの選択は -sDEVICE オプションによって行ないます。
+
+    例) gs -sDEVICE=bj10v   		(bj10vを指定)
+
+＊解像度の選択は -r オプションによって行ないます。
+
+    例) gs -sDEVICE=bj10v -r360x180	(360x180dpiを指定)
+
+    対応している解像度は 360x360 (デフォルト), 360x180, 180x180の3種類
+    です。
+
+
+
+				岩井輝男 (oteru@nak.math.keio.ac.jp)
+				前田敦司 (mad@nak.math.keio.ac.jp)
+				松井孝雄 (mat@slis.flet.mita.keio.ac.jp)
diff -urN -x .svn espgs-8.15rc2/addons/japanese/doc/gdevalps.txt trunk/addons/japanese/doc/gdevalps.txt
--- espgs-8.15rc2/addons/japanese/doc/gdevalps.txt	1970-01-01 01:00:00.000000000 +0100
+++ trunk/addons/japanese/doc/gdevalps.txt	2005-03-14 00:03:51.677783063 +0100
@@ -0,0 +1,50 @@
+
+配布物件
+
+   gdevalps-0.2.tar.gz 
+
+     README.gdevalps        このファイル
+     gdevalps.c             ドライバソース
+     gdevalps.mak           ghostscript-5.10 用 Makefile 追加部分
+     gdevalps.mak-5.50      ghostscript-5.50 用 Makefile 追加部分
+
+説明
+
+   ghostscript-5.10/ghostscript-5.50 用の ALPS MDシリーズのモノクロ 600x600dpi
+   対応のドライバです。MDシリーズ汎用(?)モノクロモード、MD5000専用モノクロモー
+   ドでの印刷をサポートします。MD5000ではエコブラックインクの選択も可能です。
+   -sDEVICE オプションで下記3種類のモードを指定する事が可能です。
+
+     md50Mono  旧バージョン同様の MD5000 でのモノクロ印刷モード。
+     md50Eco   旧バージョンではソース変更が必要だったエコブラックモードをデバ
+               イス名で指定できるようにした。
+     md1xMono  今回追加サポートした MD1300, MD5000 での動作を確認したモード。
+               Kousuke Ikeda さんからソースプログラムを頂き、旧バージョンの
+               ソースと統合したものです。
+               MD2000, MD4000 など、古いシリーズもこのモードをサポートしている
+               可能性があります。
+   
+使い方
+
+   ghostscript-5.10 または ghostscript-5.50 を作成するのに必要なソース類を展開
+   した上で、下記手順で配布ファイルを使用して下さい。
+
+     ・makefile への追加設定
+       * ghostscript-5.10 では makefile に gdevalps.mk の内容を追加
+       * ghostscript-5.50 では contrib.mk に gdevalps.mk-5.50 の内容を追加
+     ・makefile 中の DEVICE_DEVS に md50Mono.dev md50Eco.dev md1xMono.dev
+       を追加する。
+     ・gdevalps.c をソースディレクトリにコピーする。
+     ・コンパイルする
+
+TODO
+     ・インクカートリッジのオプション指定
+     ・カラーモードサポート
+     ・その他
+
+   バグ報告その他御意見などありましたら私宛にメイルでお願い致します。
+
+  vVv
+ > ..<   NEC Computer Systems, LTD.  / umi@mpd.necs.nec.co.jp
+   o     Umino, Shinya.              / umi@necs.co.jp
+
diff -urN -x .svn espgs-8.15rc2/addons/japanese/doc/gdevcd8.txt trunk/addons/japanese/doc/gdevcd8.txt
--- espgs-8.15rc2/addons/japanese/doc/gdevcd8.txt	1970-01-01 01:00:00.000000000 +0100
+++ trunk/addons/japanese/doc/gdevcd8.txt	2005-03-14 00:03:52.034771521 +0100
@@ -0,0 +1,146 @@
+   A printer driver for the HP670, HP690, HP850, HP855
+   HP870, HP890, HP1100 and HP1600 color printers. 
+   To be used with the ghostscript printing system.
+   These drivers are currently not in the official distrib.
+   Please report all problems to uli@bonk.ethz.ch 
+
+   CREDITS: Much of the driver is based on ideas derived
+            from the cdj550 driver of George Cameron.
+	    
+	    The support for the hp670, hp690, hp890
+	    and hp1600 was added by Martin Gerbershagen.
+
+   ----------------------------------------------------------------
+
+    Copyright (C) 1996-1998  <Uli Wortmann uli@bonk.ethz.ch>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+    -------------------------------------------------------------------
+
+   11.11.96. Initial release of the driver 
+
+   25.08.97  Version 1.2. Resolved all but one of the 
+                          known bugs, introduced a couple
+			  of perfomance improvements. Complete
+			  new color-transfer-function handling.
+			  (see gamma).
+
+  01.06.98   Version 1.3  Due to the most welcome contribution
+                          of Martin Gerbershagen (ger@ulm.temic.de),
+                          support for the hp670, hp690 and hp890
+			  and hp1600 has been added. Martin has also
+			  resolved all known bugs.
+
+	     Problems  :  Dark colors are still pale.
+	                  
+
+  The diver needs no longer special switches to be invoked
+  except -sDEVICE=cdj850, or -sDEVICE=CDJ890, or sDEVICE=CDJ670
+  or -sDevice=CDJ1600
+
+  The hp690 is supported through the hp670 device, the hp855, hp870 
+  and the hp1100 trough the hp850 device.
+
+  The following switches are supported.
+
+   -dPapertype= 0  plain paper [default]
+                1  bond paper
+		2  special paper
+		3  glossy film
+		4  transparency film
+
+		Note, currently the lookuptables are not suited
+		for printing on special paper or transperencies.
+		Please revert to the gamma functions in this case.
+
+   -dQuality=  -1 draft     
+                0 normal       [default]
+                1 presentation 
+
+   -dRetStatus= 0 C-RET off
+                1 C-RET on [default]
+
+   -dMasterGamma= 3.0 [default = 1.0]
+    __Note__: To take advantage of the calibrated color-transfer
+              functions, be sure not to have any Gamma-Statements
+	      left! If you need to (i.e. overhead sheets), 
+	      you still can use the gamma-functions, but they will 
+	      override the built-in calibration. To use gamma in the 
+	      traditional way, set MasterGamma to any value greater
+	      1.0 and less 10.0. To adjust individual gamma-values,
+	      you have to additionally set MasterGamma to a value
+	      greater 1.0 and less 10.0
+	      
+	      With the next release, gamma functions will be dropped.
+
+   When using the driver, be aware that printing in 600dpi involves
+   processing of large amounts of data (> 188MB !). Therefore, the
+   driver is not what you would expect to be a fast driver ;-)
+   This is no problem when printing a full sized color page (because
+   printing itself is slow), but it's really annoying if yoy print only
+   text pages. Maybe I can optimize the code for text-only pages in a
+   later release. Right now, it is recommended to use the highest
+   possible optimisation level your compiler offers....
+   For the time beeing, use the cdj550 device with -sBitsPerPixel=3
+   for fast proof-prints. If you simply want to print 600dpi b/w data,
+   use the cdj550 device with -sBitsPerPixel=8 (or 1).
+   
+   Since the printer itself is slow, it may help to set the
+   process-priority of the gs-process to regular or even less. On a
+   486/100MHZ this is still sufficient to maintain a continuos
+   data-flow.
+   Note to OS/2 users: Simply put the gs-window into the background,
+   or minimize it. Also make sure, that print01.sys is invoked without
+   the /irq switch (great speed improvement under warp4).
+
+   The printer default settings compensate for dot-gain by a
+   calibrated color-transfer function. If this appears to be to light
+   for your business-graphs, or for overhead-sheets, feel free to set
+   -dMasterGamma=1.7.
+
+   Furthermore, you may tweak the gammavalues independently by setting
+   -dGammaValC, -dGammaValM, -dGammaValY or -dGammaValK (if not set,
+   the values default to MasterGamma). This will only work, when
+   -dMasterGamma is set to a value greater than 1.0.
+
+   If you want to learn more about gamma, see:
+              
+       ftp://ftp.igd.fhg.de/pub/doc/colour/GammaFAQ.pdf
+
+       Further information, bugs, tips etc, can be found
+       at my website.
+
+   Have fun!
+
+	Uli
+
+	uli@bonk.ethz.ch
+	http://bonk.ethz.ch
+
+   Note: Depending on how you transfered the files, 
+   you might need to remove some CR-codes used on intel-based machines:
+
+   simply type:  unzip -a hp850.zip
+
+   to compile with gs5.x, simply add 
+
+             DEVICE_DEVS4=cdj850.dev cdj670.dev cdj890.dev cdj1600.dev
+
+   to your makefile. 
+
+   BTW, it is always a good idea to read make.txt found in the
+   gs-distrib before attempting to recompile.....
+
diff -urN -x .svn espgs-8.15rc2/addons/japanese/doc/gdevdmpr.txt trunk/addons/japanese/doc/gdevdmpr.txt
--- espgs-8.15rc2/addons/japanese/doc/gdevdmpr.txt	1970-01-01 01:00:00.000000000 +0100
+++ trunk/addons/japanese/doc/gdevdmpr.txt	2005-03-14 00:03:52.011772265 +0100
@@ -0,0 +1,545 @@
+■                                                                    ■
+■                ドットマトリクスプリンタ汎用ドライバ                ■
+■                         dmprt version 2.01                         ■
+■                   for Ghostscript version 4.03                     ■
+■                                                                    ■
+■                              淺山和典                              ■
+■                        TPM03937@pcvan.or.jp                        ■
+■                     GHF01532@niftyserve.or.jp                      ■
+■                    asayama@vsp.cpg.sony.co.jp                      ■
+■                                                                    ■
+
+========================================================================
+● １． ファイル構成
+========================================================================
+
+  このパッケージには次のファイルが含まれています。本ドキュメント中で「本
+パッケージ」という場合にはこれら全てのファイルを指しているものとします。
+
+          COPYING      GNU General Public License
+          gdevdmpr.sj  このファイル(Shift JIS)
+          gdevdmpr.c   プリンタドライバのソースファイル
+          dviprlib.c         〃
+          dviprlib.h         〃
+          gdevdmpr.mak Makefile
+          escp_24.src  dviprtのプリンタ定義ファイルのサンプル
+          dmp_init.ps  初期化ファイル
+          dmp_site.ps  環境設定ファイルのサンプル
+          testpage.ps  位置合わせテスト用のPSファイル
+
+========================================================================
+● ２． 概要
+========================================================================
+
+  このプリンタドライバは、ビットマップイメージの印字のためのプリンタ命令
+をユーザが定義できるようにし、出来る限り多くの種類のプリンタに対応できる
+ようにしたものです。
+
+  プリンタコードの定義は、MS-DOS 上で広く用いられている TeX 用プリンタド
+ライバ dviprt.exe のプリンタ定義ファイル (拡張子.cfg)、またはそのソース
+ファイル (拡張子.src) を用いる、という方法で行います。
+
+    ※  プリンタ定義ファイルの書式については dviprt のテクニカルマニュア
+      ル texjman.tex (ver. 2.42 以降) をご覧ください。tex???ma.lzh(???
+      はバージョン番号) というファイル名で配布されています。
+
+    ※  dviprt のプリンタ定義ファイルの仕様がバージョン 2.41.8 以降で拡
+      張されました。dmprt の本バージョンではこの新しい仕様にも対応してい
+      ます。
+
+    ※  dviprt.exe は TSG(東京大学理論科学グループ) 及び PC-VAN SSCIENCE
+      の SHIMA さんによる TeX 用プリンタドライバです。PC-VAN では
+      SSCIENCE の OSL、Nifty Serve では FLABO のライブラリの 11 番 (TeX
+      専用)、ASCII NET では pool msdos で入手可能です。また annonymous
+      FTP でも入手できます。
+
+    ※  プリンタ定義ファイルは dviprt.exe のユーティリティパッケージ
+      tex???ut.lzh (??? はバージョン番号) に含まれています。
+
+    ※  dviprt v2.42 の時点で配布パッケージに含まれているプリンタ定義フ
+      ァイルは以下のとおりです。
+
+      これら全てのプリンタでの動作確認が出来ているわけではありません。こ
+      れらのプリンタの中で正常に印字出来ない場合にはご連絡ください。出来
+      る限り対処します。
+
+       ap850.src    EPSON AP-850/MJ-500用 (48ドット)
+       ap900.src    EPSON AP-900用 (360dpi)
+       art.src      Xerox ART mode (240dpi)
+       art2.src     Xerox ART2 mode (240dpi, Hex mode)
+       bj_10v48.src Canon BJ-10/BJ-15用 (48ドット)
+       bj_130j.src  Canon BJ-130J/BJ-330J用 (48ドット)
+       dj500.src    HP DeskJet 500用 (300dpi)
+       dj505j.src   HP DeskJet 500J/300J/505J/505J plus用 (300dpi)
+       dj505j1.src  HP DeskJet 505J plus用 (300dpi PCL mode1 圧縮)
+       dj505j2.src  HP DeskJet 505J plus用 (300dpi PCl mode2 圧縮)
+       dvi2pbm.src  raw PBM 出力用 (118dpi)
+       epsimage.src Encapsulated PostScript(TM) Image 出力用(118dpi)
+       escp_24.src  EPSON ESC/P (24ドット)プリンタ用
+       escp_48.src  EPSON HG-4800用 (48ドット)
+       escp_48a.src EPSON HG-5130用 (48ドット, 隣接ドット可)
+       escp_8.src   EPSON ESC/P (8ピン)用
+       fmpr-351.src Fujitsu FMPR-351用 (48ドット)
+       g3fax.src    G3 FAX用(200dpi, Header なし)
+       hl_8e.src    Brother HL-8e用 (300dpi)
+       hp_djp.src   HP DeskJet Plus用 (300dpi)
+       hp_ljp.src   HP LaserJet Plus用 (300dpi)
+       jt48escp.src Star JT-48 ESC/P (48 ドット)
+       jt48nm.src   Star JT-48CL/NM (48 ドット)
+       lbp-b406.src Canon LBP-B406用(240dpi)
+       lbp8_240.src Canon LBP-8/LIPS II用 (240dpi)
+       lbp8_300.src Canon LBP-8/LIPS II用 (300dpi)
+       lcs240.src   Casio LCS-240用 (240dpi)
+       lips3.src    Canon LIPS III用
+       lp3000.src   EPSON LP-3000(2000)用
+       lp7000.src   EPSON LP-7000用
+       lp_rpdl.src  RICOH LP3320-SP4 mark2
+                        / LP2310-SP5 (RPDL)用 (240dpi)
+       l_880.src    Kyocera L-880用 (300dpi)
+       nec_page.src NEC PC-PR2000用
+       nec_pgr.src  NEC PC-PR1000,2000,4000用 (240dpi)
+       nec_pgr4.src NEC PC-PR2000,4000用 (400dpi)
+       nm_24.src    NEC NM(24ドット)用
+       pc-pr101.src NEC PC-PR101用(24ドット)
+       pc-pr_24.src NEC PC-PR(24ドット)用
+       pc150v48.src NEC PC-PR150V(48ドット)用
+       pc8821.src   NEC PC-8821(16ドット)用
+       pc_pr406.src NEC PR406LM(48ドット)用
+       pc_pr602.src NEC PC-PR602R用 (240dpi)
+       pr_130ax.src SANYO PR_130AX, TOSHIBA PR-48(J31DPR02)用 (180dpi)
+       pr-48.src    Toshiba PR-48 (360dpi)
+       r98_dma.src  RICOH LP3320-SP4 R98 emulation mode
+                        Direct Memory Access
+       rpdl_dma.src RICOH LP3320-SP4 Direct Memory Access (240dpi)
+       smdfax.src   SONY SMD50/70 シリーズFAX (200dpi)
+       starfax.src  Starfax用 (200dpi)
+
+
+========================================================================
+● ３． 動作環境
+========================================================================
+
+  ソースファイルは基本的に非機種依存のつもりで書いてあります (ただし
+FreeBSD 上でしか動作確認はおこなっていません)。
+
+  このドライバを組み込むことが出来る Ghostscript のバージョンですが、
+Ghostscript の本体とデバイスドライバとのインタフェースが Ghostscript
+version 4.03 と同様のものならば可能です (2.6.x には組み込めません。
+2.6.x では従来のものを用いて下さい)。
+
+
+========================================================================
+● ４． 導入の手順
+========================================================================
+  ここでは dmprt が組みこんである実行可能形式の gs が既に手元にあるもの
+として説明します。コンパイルが必要な場合はこのドキュメント末尾の「コンパ
+イル」の項目を参照してください。
+
+  dmprt はおおよそ汎用のプリンタドライバですから、逆に言うとユーザが設定
+をおこなってやらないと正しく動作してくれません。
+
+  以下の作業を行います。
+
+(1) 環境設定ファイルの編集
+(2) 環境設定ファイルの指定
+
+-----------------------
+★ 4.1 環境設定ファイル
+-----------------------
+
+  環境設定ファイルでは、プリンタの機種別情報などを指定します。また、印字
+位置の補正などが必要ならばさらにそれを指定します。
+
+
+-----------------------------
+★ 4.2 環境設定ファイルの書式
+-----------------------------
+
+  環境設定ファイル dmp_site.ps の大まかな書式を説明します。項目別の詳細
+な書式は各項目の説明を参照してください。
+
+(1) 設定ファイルの開始・終了コマンド
+
+      付属の dmp_site.ps の最初と最後の行にある 「BeginConfig」 と
+    「EndConfig」 という文字列のことです。設定ファイルの最初と最後の行
+    にそれぞれこれらの文字列がある必要があります。付属の dmp_site.ps を
+    編集して使う場合には、これらの行を削除しないようにしてください。
+
+(2) コメント
+
+      '%' 以降行末まではコメントとして無視されます。
+
+(3) 論理値 (スイッチ)
+
+      true (真 / on) 又は false (偽 / off) のどちらかの値です。
+
+(4) 文字列
+
+      '(' と ')' で囲まれたものが文字列です。これらの括弧の間には余分な
+    空白を含めてはいけません。
+
+(5) 長さ
+      dmp_site.ps の中で「長さ」で指定する項目では単位を付けることが出来
+    ます。使用できる単位は、
+
+     ・ in  インチ
+     ・ cm  センチメートル
+     ・ mm  ミリメートル
+     ・ pt  ポイント (1/72.27 インチ)
+     ・ bp  ビッグポイント (1/72 インチ)
+     ・ dot ドット
+
+    です。単位が指定されない場合は「インチ」を単位として処理します。
+
+      単位を指定する場合には、数値との間に空白文字を少なくとも一つ挿入し
+    てください。空白文字が数値との間にない場合、うまく解釈できません。
+
+      (e.g.)  /defaultsize [ 576 bp 792 bp ]
+
+
+    ※環境設定ファイルは実際には PostScript プログラムとして実行され解釈
+      されています。従って、環境設定ファイル中では PostScript 言語が許す
+      記述は基本的に許されます。
+
+      ただし、その場合に作業の都合上辞書に登録を行なう必要がある場合には
+      環境設定ファイル中でローカルな辞書を作って、その辞書に対して登録を
+      行なってください (dictfull エラーや思わぬ副作用が起きる可能性があ
+      ります)。また、オペランドスタックや辞書スタックを破壊しないように
+      十分に気を付けてください (ゴミを残さないように!!)。
+
+      環境設定ファイル中では Level 2 のオペレータは使わないようにしてく
+      ださい。
+
+-----------------------------
+★ 4.3 環境設定ファイルの項目
+-----------------------------
+
+  環境設定ファイル dmp_site.ps は以下の項目とコメントからなっています。
+
+ /printer     dviprtのプリンタ定義ファイル
+ /resolution  解像度
+ /offset      原点移動量
+ /defaultsize デフォルトの用紙サイズ
+ /margin      印字不可能領域
+ /maxsize     印字可能領域の最大範囲
+ /verbose     おしゃべりモード(^^;
+
+  これらは全て省略可能な項目です。ただし、/printer を設定しない場合には
+ESC/P 24 pins のプリンタコードを用いて出力しますので、これに該当しないプ
+リンタを使用する場合には最低限この項目は設定してください。
+
+  以下に各項目の指定法を説明します。各項目は行単位で指定し、重複した指定
+は最初の指定のみが有効となります。また、設定ファイル中の文字は全て大文字、
+小文字が区別されますので注意してください。
+
+(1) /printer
+
+     ・ 《指定法》
+
+          /printer (ファイル名)
+
+          dviprt の *.cfg/*.src のファイル名を文字列で指定します。拡張子
+        の省略はできません。
+
+          MS-DOS 上で使用する場合、ディレクトリの区切りには '\' ではなく
+        '/' を用いるようにしてください。
+
+     ・ 《指定例》
+
+          /printer (/usr/local/lib/tex/dviprt/escp_24.cfg)
+
+     ・ 《説明》
+
+          dviprt.exe で用いられるプリンタ定義ファイルまたはそのソースフ
+        ァイルを指定します。
+
+          ここで指定されたファイルは
+
+        (A) Ghostscript のライブラリ検索 (use.doc の File searching の項
+            目を参照) に従った検索
+        (B) 指定されたファイル名を環境変数 TEXCFG に設定されたディレクト
+            リ名に連結したファイル名のファイル (環境変数が設定されている
+            場合のみ)
+
+        の順に探されます。
+
+          このファイルは使用するプリンタの機種にあったものを用意する必要
+        があります。
+
+          dviprt は大変多くのユーザを持っているためありがたいことにたく
+        さんのプリンタ定義ファイルが既に作成・公開・配布されています。ま
+        ずは dviprt のユーティリティパッケージ tex???ut.lzh に目的のプリ
+        ンタ定義ファイルが無いかどうか確かめてください。
+
+          運悪くご使用のプリンタ用のプリンタ定義ファイルが tex???ut.lzh
+        に含まれていない場合、そのソースファイルはテキストファイルですの
+        でエディタで作成することが出来ます。
+
+          プリンタ定義ファイルのソースファイルとそれをコンバートしたバイ
+        ナリファイルとはその内容から自動判別しています。
+
+(2) /resolution
+
+     ・ 《指定法》
+
+          /resolution [ 横の解像度 縦の解像度 ]
+
+        dot/inch(dpi) 単位での実数表現。
+
+     ・ 《設定例》
+
+          /resolution [ 160 180 ]
+
+     ・ 《説明》
+
+          解像度を指定します。通常はプリンタ定義ファイルに記録してあるプ
+        リンタ固有の解像度を参照しますのでこの項目の設定は必要ありません
+        が dviprt のプリンタ定義ファイルは縦横の解像度が同じであることを
+        仮定していますのでこれに該当しないプリンタ (縦横の解像度が異なる
+        プリンタ) では実行毎に (Ghostscript の)-r オプションを指定しなけ
+        ればなりません。また、解像度が記録されていない古いバージョンのプ
+        リンタ定義ファイルを使用する場合でも同様です。
+
+          解像度の優先順位は、
+
+        (A) Ghostscript 起動時の -r オプションによる指定
+        (B) 環境設定ファイル中の "/resolution" の項目による指定
+        (C) プリンタ定義ファイル中の解像度
+        (D) 180dpi(デフォルト)
+
+        です。
+
+(3) /offset
+
+     ・ 《設定法》
+
+          /offset  [ 横の移動量 縦の移動量 ]
+
+        長さによる指定。
+
+     ・ 《設定例》
+
+          /offset [ 0.0 -0.2 ]
+
+     ・ 《説明》
+
+          原点 (出力イメージの左下角) の横 / 縦方向の移動量を指定します。
+
+          印字可能領域の枠から覗いて見える部分がここで指定された分だけ平
+        行移動する、というイメージを持っていただけばいいでしょう。
+
+          用紙右、上方向がそれぞれの正方向です。
+
+          省略された場合は縦横双方向 0 インチです。
+
+          このパッケージには位置合わせのための PS ファイル (testpage.ps)
+        が付属しています。このファイルは用紙の縁から、内側 1.5cm、1inch、
+        及び 3cm の位置に 1 dot 幅の細い線で枠を書くだけのものです。
+
+          testpage.ps では用紙サイズは、デバイスドライバの描画範囲に等し
+        いものとみなされます。例えば -sPAPERSIZE=b5 というオプションを付
+        けて Ghostscript を起動すれば用紙サイズは B5 であると仮定され、
+        また、Ghostscript に描画範囲を指定するオプション (-g、
+        -sPAPERSIZE) を付けずに起動した場合には、デバイスドライバのデフ
+        ォルトの描画範囲が用紙サイズであるとされます。
+
+          -sPAPERSIZE オプションと -g オプションについては Ghostscript
+        のドキュメント use.doc をご覧ください。
+
+        例えば、次のようにします。
+
+          gs -dNOPAUSE -sDEVICE=dmprt -sPAPERSIZE=b5 -- testpage.ps
+
+          このファイル testpage.ps の出力位置がずれる場合には正しい位置
+        に枠がくるように /offset の値を調節してください。
+
+(4) /defaultsize
+
+     ・ 《設定法》
+
+          /defaultsize  [ 幅 高 ]
+
+        長さによる指定。
+
+     ・ 《設定例》
+
+          /defaultsize [ 8.0 11.0 ]
+
+     ・ 《説明》
+
+          Ghostscript の起動オプションで印字領域の幅・高の指定 (-g オプ
+        ション、-sPAPERSIZE オプション) がない場合の印字領域を指定します。
+
+          指定されなかった場合には、幅 8.3 インチ、高 11.7 インチです。
+
+(5) /margin
+
+     ・ 《設定法》
+
+          /margin  [ 左 下 右 上 ]
+
+        長さによる指定。
+
+     ・ 《設定例》
+
+          /margin [ 3.675 mm 12.7 mm 3.675 mm 6.5 mm ]
+
+     ・ 《説明》
+
+          用紙のうちプリンタが印字することが出来ない部分を用紙上下左右の
+        端からの長さで指定します。
+
+          ここで指定された領域のイメージはプリンタに出力されません (c.f.
+        /maxsize)。
+
+          指定されなかった場合はは上下左右全て 0 インチです。
+
+(6) /maxsize
+
+     ・ 《設定法》
+
+          /maxsize  [ 幅 高 ]
+
+        長さによる指定。
+
+     ・ 《設定例》
+
+          /maxsize [ 8.0 11.0 ]
+
+     ・ 《説明》
+
+          プリンタの印字可能領域の最大サイズを指定します。このサイズから
+        はみ出す部分は指定された用紙サイズやマージンにかかわらず出力され
+        なくなります (右、上が切れることになります)。
+
+          例えば最大印字可能幅を越えるイメージを送った場合にそのぶんを無
+        視せずに次の行に折り返して印字してしまうプリンタを使用している場
+        合や、長すぎるページを出力した場合に次の用紙に続きを出力してしま
+        う場合などにこの項目を設定してください。
+
+          0 又は負の値は「無限大」を意味します。幅、高さの指定は独立です。
+        すなわち例えば幅が 8 インチ、高さが無限大、という指定も可能です。
+
+          (e.g.) /maxsize [ 8.0 0 ]
+
+          指定されなかった場合には縦横双方向が無限大です。
+
+          出力されるイメージのサイズが用紙サイズからマージンを差し引いた
+        サイズより大きいときに出力イメージのサイズをここで設定された値に
+        置き換えて処理されます (設定された値が 0 以下であればこの置き換
+        えは行われません)。
+
+(7) /verbose
+
+     ・ 《設定法》
+
+          /verbose 論理値
+
+     ・ 《設定例》
+
+          /verbose true
+
+     ・ 《説明》
+
+        デバイスドライバの動作状態を詳しく表示するかどうかの指定です。出
+        力中のページの通し番号や出力コードのバイト数などが表示されます。
+
+        デフォルトでは false (off) です (何も表示されません)。
+
+        この項目が true (on) に設定してあっても、Ghostscript の起動オプ
+        ションで -q オプション (QUIET) が指定してあれば、この項目の設定
+        が off の場合と同じ動作をします。
+
+-----------------------------
+★ 4.4 環境設定ファイルの指定
+-----------------------------
+  dmprt ドライバが組み込まれた Ghostscript は起動時に dmp_init.ps 及び
+dmp_site.ps を Ghostscript のファイル検索パス上から読み込みます。これら
+のファイルは Ghostscript のファイル検索パス上に置いてください。
+dmp_site.ps(環境定義ファイル) が見つからなければ読み込みを諦めてデフォル
+トの設定 (ESC/P 24 pin) を用います。
+
+  dmp_site.ps の代わりに別のファイルを指定して読み込むことも可能です。
+Ghostscript 起動時にそのファイル名を -sDMPCONFIG= ファイル名 のように指
+定してください。この場合に指定するファイルを置くディレクトリも
+dmp_init.ps などと同様です。
+
+  (e.g.) gs -sDEVICE=dmprt -sDMPCONFIG=dmp_local.ps -dNOPAUSE -- tiger.ps
+
+
+========================================================================
+● ５． 使用法
+========================================================================
+
+  dmp_site.ps の設定以外には特別なことを行う必要はありません。gs のデバ
+イスとして "dmprt" を指定して起動してください (他のデバイスドライバと同
+様の使い方)。
+
+  (e.g.) gs -sDEVICE=dmprt sample.ps
+
+
+========================================================================
+● ６． 謝辞
+========================================================================
+
+ ◇ PC-VAN SSCIENCE の FKR さんには 386BSD での利用における不具合を修正
+    していただきました。
+
+ ◇ CCITTFax エンコーダの実装にあたっては、そのコードを Godohoji さん及
+    び SHIMA さんによる Fax Endode/Decode ライブラリ中のものを元にさせて
+    いただきました。
+
+ ◇ そして何より dviprt/dviout という高機能 DVI ドライバを開発・拡張して
+    下さった PC-VAN SSCIENCE の SHIMA さんをはじめとする開発者の方々に感
+    謝します。
+
+
+========================================================================
+● ７． コンパイル
+========================================================================
+
+  以下の手順でコンパイルして下さい。
+
+(1) gdevdmpr.c、dviprlib.c、dviprlib.h を他の Ghostscript のソースと同じ
+    ディレクトリに置く。
+
+(2) devs.mak に gdevdmpr.mak の内容を追加する。
+
+(3) *-head.mak 中のマクロ "DEVICE_DEVS?" に "dmprt.dev" を加える。
+
+(4) tar_cat を実行する。
+
+(5) make する。
+
+
+========================================================================
+● ８． 著作権・保証・再配布・改変
+========================================================================
+
+  著作権は作者である淺山 (TPM03937@pcvan.or.jp) が保有します。本パッケー
+ジに含まれる全てのプログラム及びドキュメントは無保証です。
+
+  保証及び再配布・改変に関する条件は全て GNU General Public License (GNU
+GPL) に従います。GNU GPL は付属の COPYING というファイルに記述されていま
+す。
+
+
+========================================================================
+● ８． 履歴
+========================================================================
+
+1997.5.13.
+
+ ◇ Ghostscript 4.03 に対応。
+ ◇ *.src が正しく読み込めない場合 (line_feed, form_feed が未定義の *.src)
+    がある不具合を修正。
+ ◇ -sDMPSITE の処理が正しくおこなわれていなかった不具合を修正。
+ ◇ setpagedevice オペレータで設定可能な設定項目の多くを削除。
+ ◇ DJ's GPP への対応を凍結 (開発環境と暇がなくなったため)。
+ ◇ testpage.ps が Level 2 でうまく出力できなかった不具合を修正。
+
+
+                                            淺山 和典 (ASAYAMA Kazunori)
+                                                    TPM03937@pcvan.or.jp
+                                               GHF01532@niftyserve.or.jp
+                                              asayama@vsp.cpg.sony.co.jp
diff -urN -x .svn espgs-8.15rc2/addons/japanese/doc/gdevfmlbp.txt trunk/addons/japanese/doc/gdevfmlbp.txt
--- espgs-8.15rc2/addons/japanese/doc/gdevfmlbp.txt	1970-01-01 01:00:00.000000000 +0100
+++ trunk/addons/japanese/doc/gdevfmlbp.txt	2005-03-14 00:03:51.681782934 +0100
@@ -0,0 +1,81 @@
+
+	gdevfmlbp.c  -  Fujitsu FMLBP2xx 用デバイスドライバ
+
+			Version 1.2   1998/03/30
+
+◆ はじめに
+
+  これは、ghostscript 2.6.1 で、FMLBP2xx 系のページプリンタを使うための
+  デバイスドライバです。
+
+
+◆ インストール方法
+
+ 1. gdevfmlbp.c を ghostscript 2.6.1 のソースプログラムを展開した
+    ディレクトリにコピーします。
+
+ 2. Makefile に gdevfmlbp.mak を追加します。
+
+ 3. Makefile の DEVICE_DEVS に fmlbp.dev を加えます。
+
+    例: DEVICE_DEVS=x11.dev fmlbp.dev
+			    ~~~~~~~~~
+ 4. make コマンドで gs をコンパイルし、インストールします。
+
+
+◆ 使用方法
+
+   デバイスドライバの選択は -sDEVICE オプションによって行ないます。
+
+    例: gs -sDEVICE=fmlbp
+
+   (注意)プリンタ本体のエミュレーション設定を FMモードに設定してください。
+
+   デフォルトの解像度は 400dpi です。240dpi で印刷する場合は、次のように
+   -r オプションで指定します。
+
+    例: gs -sDEVICE=fmlbp  -r240
+
+   (注意) -r オプションの値はチェックしていません。
+
+   用紙サイズを指定する場合には、-sPAPERSIZE オプションで指定します。
+   指定可能なサイズは、a3, a4, a5, b4, b5, legal, letter です。
+   デフォルトの用紙は a4 です。a3 を指定する時は次のように指定します。
+
+    例: gs -sDEVICE=fmlbp  -sPAPERSIZE=a3
+
+
+◆ バグ/制限事項
+
+ o 動作確認は、Solaris上の ghostscript 2.6.1j と FMLBP226 で行なってます。
+
+ o おそらく Aladdin 版の ghostcript 5.01 でも動作すると思いますが、確認
+   していません。5.01 では gdevfmlbp.mk5 を gdevfmlbp.mak の代りに試して
+   みてください。
+
+ o 用紙は a3, a4, a5, b4, b5, legal, letter, ハガキ に対応させましたが、
+   a4 以外は、あまりテストしていませんので、問題があるかもしれません。
+
+
+◆ おわりに
+
+ o この FMLBP2xx 用ドライバは、成松宏氏の ESC/Page 用ドライバ gdevepag を
+   後藤和茂氏 <goto@statabo.rim.or.jp> が、FMLBP2xx 用に改造した物です。
+   修正および拡張を 中山正一 <naka@fadev.fvd.fujitsu.co.jp> が行っています。
+
+   なお、ESC/Page 用ドライバは、Tom Quinn氏 <trq@prg.oxford.ac.uk> 作成の
+   lbp8 用ドライバを成松宏氏 <nari@lsi.tmg.nec.co.jp> が、ESC/Page 用に
+   改造した物です。
+
+ o 配布条件は、もとのソースファイルと同様 GPL に従います。
+
+ o 私も富士通VLSI(株)も富士通(株)も、本ソフトウェアの修正その他、如何なる
+   保守についても義務を負いません。また、本ソフトウェアを使用することに
+   よって如何なる損害が生じても一切責任を負いません。
+   各自の責任でプログラムをご使用ください。
+
+ o ご意見・ご要望などは、naka@fadev.fvd.fujitsu.co.jp へお願いします。
+
+   
+                富士通VLSI(株)  中山 正一 <naka@fadev.fvd.fujitsu.co.jp>
+[EOF]
diff -urN -x .svn espgs-8.15rc2/addons/japanese/doc/gdevj100.txt trunk/addons/japanese/doc/gdevj100.txt
--- espgs-8.15rc2/addons/japanese/doc/gdevj100.txt	1970-01-01 01:00:00.000000000 +0100
+++ trunk/addons/japanese/doc/gdevj100.txt	2005-03-14 00:03:52.033771554 +0100
@@ -0,0 +1,28 @@
+
+	gdevj100.c  -  Star JJ-100 用デバイスドライバ
+
+
+○インストール方法
+
+1. gdevj100.c を gs261 のソースプログラムがあるディレクトリにコピーし
+て下さい。
+
+2. Makefile に gdevj100.mak を追加して下さい。
+
+3. Makefile の DEVICE_DEVS に jj100.dev を加えて下さい。
+
+    例) DEVICE_DEVS=pc98.dev jj100.dev
+			     ^^^^^^^^^
+4. make コマンドで gs をコンパイルし、インストールして下さい。
+
+
+○使い方
+
+＊デバイスの選択は -sDEVICE オプションによって行ないます。
+
+    例) gs -sDEVICE=jj100	(jj100を指定)
+	gs -sDEVICE=pc98	(pc98を指定)
+
+
+
+				横山和由 (caz@psq.mei.co.jp)
diff -urN -x .svn espgs-8.15rc2/addons/japanese/doc/gdevlbp3.txt trunk/addons/japanese/doc/gdevlbp3.txt
--- espgs-8.15rc2/addons/japanese/doc/gdevlbp3.txt	1970-01-01 01:00:00.000000000 +0100
+++ trunk/addons/japanese/doc/gdevlbp3.txt	2005-03-14 00:03:51.679782998 +0100
@@ -0,0 +1,37 @@
++---------------------------------------------------------------------+
+|                                                                     |
+|    $BI8=`(B/$B%U%!%$%s%$%a!<%8%b!<%I(B $BBP1~(B Ghostscript $B%G%P%$%9%I%i%$%P(B    |
+|                                                Ver 1.0.0 1999/05/23 |
++---------------------------------------------------------------------+
+
+$B@bL@(B
+  LBP-310/320/Pro $B$N%$%a!<%8%b!<%I$r;H$C$F=PNO$r9T$&%I%i%$%P$G$9!#(B
+  LIPS3 $B$G$N=PNO;~$KHf$Y$F(B 600dpi$B$N9b2rA|EY$,;H$($k$H$$$&MxE@$,$"$j$^$9!#(B
+
+$B%$%s%9%H!<%kJ}K!(B
+  1. Ghostscript $B$N%=!<%9%G%#%l%/%H%j$K(B gdevlbp3.c $B$r%3%T!<$9$k!#(B
+  2a. 5.10 $B0JA0$N>l9g$O(B Makefile $B$K(B gdevlbp3.mak $B$rDI2C$9$k!#(B
+  2b. 5.50 $B0J9_$N>l9g$O(B contrib.mak $B$K(B gdevlbp3.mak.gs55 $B$rDI2C$9$k!#(B
+  3. Makefile $B$N(B DEVICE_DEVS $B$K(B lbp310.dev $B$H(B lbp320.dev $B$rDI2C$9$k!#(B
+  4. Ghostscript $B$r%3%s%Q%$%k$9$k!#(B
+
+$B;HMQJ}K!(B
+  $B%G%P%$%9L>$K$O(B lbp310 $B$^$?$O(B lbp320 $B$r;XDj$7$F$/$@$5$$!#(B
+  [ $BNc(B ]
+  gs -sDEVICE=lbp310 -sOutputFile=|lpr -dNOPAUSE -dBATCH -q hoge.ps
+  $B2rA|EY$O(B -r $B$G;XDj$7$F$/$@$5$$!#(B
+  $B;XDj$G$-$k2rA|EY$O(B300,600$B$G%G%U%)%k%H$O(B600$B$G$9!#(B
+
+  $B!v$3$N%I%i%$%P$O0J2<$N4D6-$GF0:n3NG'$5$l$F$$$^$9!#(B
+    FreeBSD 4.0-current/3.1-stable
+    XFree86 3.3.3.1
+    LBP-310
+    Ghostscript 5.10/5.50($B6&$K(BVFlib$BBP1~(B)
+    2.x $B$G$O@5>o$K%3%s%Q%$%k$G$-$J$$$H;W$$$^$9!#(B
+  $B!v(BB5$B%5%$%:$OF|K\%5%$%:$G$9!#(BGhostscript $B$N(B B5 $B$O(B ISO B5 $B$G$9$N$G!"0u;z(B
+    $B7k2L$,>/$7:8>e$K4s$C$?46$8$K$J$j$^$9!#(B
+  $B!v(BLBP-320 $B$K$D$$$F$OF0:n$9$k$H$$$&Js9p$r$$$?$@$-$^$7$?$,!"$^$@%P%0$,(B
+    $B;D$C$F$$$k$+$b$7$l$^$;$s!#(B
+  $B!v0l1~(B GPL $B=`5r$H$$$&$3$H$G;HMQ$7$F$/$@$5$$!#(B
+----------------------------------------
+$B@>B<(B $BD>Li(B  <naoya@mahoroba.ne.jp>
\ Brak znaku nowej linii na kocu pliku
diff -urN -x .svn espgs-8.15rc2/addons/japanese/doc/Gdevlips.htm trunk/addons/japanese/doc/Gdevlips.htm
--- espgs-8.15rc2/addons/japanese/doc/Gdevlips.htm	1970-01-01 01:00:00.000000000 +0100
+++ trunk/addons/japanese/doc/Gdevlips.htm	2005-03-14 00:03:52.037771424 +0100
@@ -0,0 +1,1901 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN" "http://www.w3.org/TR/REC-html40/strict.dtd">
+<HTML LANG="ja">
+<HEAD>
+<META http-equiv="Content-type" content="text/html; charset=iso-2022-jp">
+<LINK rev="made" href="mailto:ohmori@p.chiba-u.ac.jp">
+<TITLE lang="en">Ghostscript driver for LIPS &amp; ESC/Page &amp; NPDL</TITLE>
+<!-- $Id$ -->
+</HEAD>
+<BODY lang="ja">
+
+<H1>LIPS &amp; ESC/Page &amp; NPDL $BBP1~(B Ghostscript $B%G%P%$%9%I%i%$%P(B</H1>
+<P>
+$B$3$N%=%U%H%&%'%"$O(B Ghostscript 5.10/5.50 $BMQ$N%G%P%$%9%I%i%$%P$H$7$F:n$i$l$F$$$^$9!#(B
+</P>
+<P>
+$B%G%P%$%9%I%i%$%P$H$7$F%i%9%?!<HG%G%P%$%9$N(B lips2p$B!"(Blips3$B!"(Bbjc880j$B!"(Blips4$B!"(B
+escpage$B!"(Blp2000$B!"(Bnpdl $B%G%P%$%9$H!"(B
+$B%Y%/%?!<HG%G%P%$%9$N(B lips4v $B$,4^$^$l$F$$$^$9!#(B
+</P>
+<P>
+$B3F5!<o$H%G%P%$%9$NBP1~$O!"(B<A HREF="#lbp_list">LIPS $BBP1~%W%j%s%?$H=PNO%G%P%$%9(B</A>$B!"(B
+<A HREF="#lp_list">ESC/Page $BBP1~%W%j%s%?$H=PNO%G%P%$%9(B</A>$B!"(B
+<A HREF="#mw_list">NPDL $BBP1~%W%j%s%?$H=PNO%G%P%$%9(B</A>$B$r8+$F2<$5$$!#(B
+</P>
+<HR>
+<H2>$B%$%s%G%C%/%9(B</H2>
+<UL>
+  <LI><A HREF="#haifu" NAME="i_haifu">$BG[I[>r7o(B</A>
+  <LI><A HREF="#difference" NAME="i_difference">gdevlips4-1.2.0 $B$H$N0c$$(B</A>
+  <LI><A HREF="#diff_epag" NAME="i_diff_epag">epag-3.08 $B$H$N0c$$(B</A>
+  <LI><A HREF="#diff_npdl" NAME="i_diff_npdl">gdevnpdl-1.5 $B$H$N0c$$(B</A>
+  <LI><A HREF="#lbp_list" NAME="i_lbp_list">LIPS $BBP1~%W%j%s%?$H=PNO%G%P%$%9(B</A>
+  <LI><A HREF="#lp_list" NAME="i_lp_list">ESC/Page $BBP1~%W%j%s%?$H=PNO%G%P%$%9(B</A>
+  <LI><A HREF="#mw_list" NAME="i_mw_list">NPDL $BBP1~%W%j%s%?$H=PNO%G%P%$%9(B</A>
+  <LI><A HREF="#unsupported" NAME="i_unsupported">$BBP1~$7$F$$$J$$%W%j%s%?(B</A>
+  <LI><A HREF="#install" NAME="i_install">$B%$%s%9%H!<%k(B</A>
+  <LI><A HREF="#usage" NAME="i_usage">$B;HMQJ}K!(B/$B;HMQ%*%W%7%g%s(B</A>
+      <UL>
+	<LI>LIPS$B!&(BESC/Page$B!&(BNPDL $B6&DL%*%W%7%g%s(B
+	    <UL>
+	      <LI><A HREF="#device" NAME="i_device">$B%G%P%$%9JQ99(B</A>
+	      <LI><A HREF="#pagesize" NAME="i_pagesize">$B%G%U%)%k%H%Z!<%8%5%$%:JQ99(B</A>
+	      <LI><A HREF="#numcopies" NAME="i_numcopies">$BJ#?tIt0u:~(B</A>
+	      <LI><A HREF="#resolution" NAME="i_resolution">$B2rA|EYJQ99(B</A>
+	      <LI><A HREF="#duplex" NAME="i_duplex">$BN>LL0u:~(B</A>
+              <LI><A HREF="#negativeprint" NAME="i_negativeprint">$BGr9uH?E>0u:~(B</A>
+	    </UL>
+	<LI>ESC/Page $B$N$_$N%*%W%7%g%s(B
+            <UL>
+              <LI><A HREF="#ritoff" NAME="i_ritoff">RIT ($BNX3TJd@55!G=(B) $B$r%*%U$K$9$k(B</A>
+            </UL>
+	<LI>LIPS $B$N$_$N%*%W%7%g%s(B
+	    <UL>
+              <LI><A HREF="#bitsperpixel" NAME="i_bitsperpixel">$B%b%N%/%m$H%+%i!<=PNO$N@ZBX$((B</A>
+	      <LI><A HREF="#feed" NAME="i_feed">$B5k;fJ}K!$NA*Br(B</A>
+	      <LI><A HREF="#panel" NAME="i_panel">$B%Q%M%kI=<(JQ99(B</A>
+	      <LI><A HREF="#mediatype" NAME="i_mediatype">$BMQ;f<oN`@_Dj(B</A>
+	      <LI><A HREF="#faceup" NAME="i_faceup">$B%U%'%$%9%"%C%W%H%l%$$N=PNO(B</A>
+	      <LI><A HREF="#nup" NAME="i_nup">n $BLL0u:~(B</A>
+	      <LI><A HREF="#fontdl" NAME="i_fontdl">$B%U%)%s%H%@%&%s%m!<%I(B</A>
+	      <LI><A HREF="#pjl" NAME="i_pjl">PJL $B=PNO(B</A>
+		  <UL>
+		    <LI><A HREF="#tdensity" NAME="i_tdensity">$B%H%J!<G;EYD4@a(B</A>
+		    <LI><A HREF="#tsave" NAME="i_tsave">$B%H%J!<@aLs(B</A>
+		  </UL>
+	    </UL>
+	<LI><A HREF="#netatalk" NAME="i_netatalk">Netatalk$B!&(BCAP $B$H(B Ghostscript + gdevlips</A>
+      </UL>
+  <LI><A HREF="#hireso" NAME="i_hireso">LIPS IV $B=PNO$K$*$1$k9b2rA|EY0u;z$K4X$9$kCm0U(B</A>
+  <LI><A HREF="#change" NAME="i_change">$BJQ99MzNr(B</A>
+  <LI><A HREF="#bug" NAME="i_bug">$B%P%0(B</A>
+      <UL>
+	<LI>npdl.dev
+	    <UL>
+              <LI><A HREF="#marginbug" NAME="i_marginbug">1. $B0u:~0LCV$,$:$l$k(B</A>
+              <LI><A HREF="#nonduplex" NAME="i_nonduplex">2. $BN>LL0u:~$G$-$J$$(B</A>
+            </UL>
+	<LI>bjc880j.dev
+            <UL>
+              <LI><A HREF="#landbug" NAME="i_landbug">1. $B%i%s%I%9%1!<%W2sE>;~$K0u:~0LCV$,$A$g$C$H$:$l$k(B</LI>
+            </UL>
+	<LI>lips4v.dev
+	    <UL>
+	      <LI><A HREF="#clipping" NAME="i_clipping">1. $B%Q%9$N%/%j%C%T%s%0=hM};~$N%a%b%jITB-(B ($B%7%9%F%`%a%b%j%U%k(B $B%(%i!<(B)</A>
+	      <LI><A HREF="#zeroline" NAME="i_zeroline">2. $BI}$,%<%m$N%Q%9$r%U%#%k$7$?$H$-2?$bIA$+$l$J$$(B</A>
+	      <LI><A HREF="#zeromove" NAME="i_zeromove">3. $B0\F05wN%(B 0 $B$N%Q%9$N07$$(B</A>
+	      <LI><A HREF="#square_cap" NAME="i_square_cap">4. Projecting square cap $B$N%P%0(B</A>
+	      <LI><A HREF="#round_cap" NAME="i_round_cap">5. Round cap $B$N%P%0(B</A>
+	      <LI><A HREF="#linewidth" NAME="i_linewidth">6. $B@~$NB@$5$,0c$&(B</A>
+	      <LI><A HREF="#setdash" NAME="i_setdash">7. $BGK@~$N%Q%?!<%s$,IA$+$l$J$$(B</A>
+	      <LI><A HREF="#pattern" NAME="i_pattern">8. lips4v $B%I%i%$%P$G%+%i!<$G%Q%?!<%s$rIA$$$?>l9g?'$,$*$+$7$$$3$H$,$"$k(B</A>
+	    </UL>
+      </UL>
+  <LI><A HREF="#faq" NAME="i_faq">FAQ</A>
+      <UL>
+	<LI><A HREF="#slow" NAME="i_slow">$B%W%j%s%?$N=PNO$OB.$/$J$i$J$$$N(B?</A>
+	<LI><A HREF="#font" NAME="i_font">$B%W%j%s%?$NFbB"%U%)%s%H$O;H$($J$$$N(B?</A>
+	<LI><A HREF="#bsize" NAME="i_bsize">B4 $B$^$?$O(B B5 $B%5%$%:$NMQ;f;XDj$,$&$^$/$$$+$J$$$s$@$1$I(B</A>
+	<LI><A HREF="#nup_printing" NAME="i_nup_printing">n $BLL0u:~$r$9$k$K$O!"$I$&$7$?$i$$$$$N(B?</A>
+	<LI><A HREF="#psresize" NAME="i_psresize">$BMQ;f%5%$%:$N3HBg!"=L>.0u:~$r$9$k$K$O$I$&$9$k$s$G$9$+(B?</A>
+	<LI><A HREF="#offset" NAME="i_offset">$B0u:~0LCV$rD4@0$9$k$K$O$I$&$7$?$i$$$$$G$9$+(B?</A>
+	<LI><A HREF="#vector" NAME="i_vector">$B%i%9%?!<HG%G%P%$%9$H%Y%/%?!<HG%G%P%$%9$N0c$$$O(B?</A>
+	<LI><A HREF="#l3vmono" NAME="i_l3vmono">LIPS IV $B0J30%I%i%$%P$N%Y%/%?!<HG$O:n$i$J$$$N(B?</A>
+	<LI><A HREF="#lbp2030" NAME="i_lbp2030">lbp2030.dev $B$O$I$3$$$C$?$N(B?</A>
+	<LI><A HREF="#fig" NAME="i_fig">lips3fig$B!"(Blips4cfig$B!"(Blips4fig $B$,$J$$$s$@$1$I(B</A>
+	<LI><A HREF="#lips2p" NAME="i_lips2p">$B$I$&$7$F(B LIPS II+ $BBP1~%I%i%$%P$O(B lips2+ $B$d(B lips2plus $B$H$$$&L>A0$8$c$J$$$N(B?</A>
+      </UL>
+  <LI><A HREF="#thanks" NAME="i_thanks">$B<U<-(B</A>
+  <LI><A HREF="#reference" NAME="i_reference">$B;29MJ88%(B</A>
+</UL>
+      
+<HR>
+<H2><A HREF="#i_haifu" NAME="haifu">$BG[I[>r7o(B</A></H2>
+<P>
+$B$3$N%=%U%H%&%'%"$NG[I[>r7o$O(B GNU General Public License (GPL) Ver.2 $B$K=`$8$^$9!#(B
+</P>
+<P>
+$B$^$?!"$3$N%I%i%$%P$N0l;~G[I[@h$OEvLL(B
+<A HREF="http://www.bukka.p.chiba-u.ac.jp/~ohmori/">&lt;URI:http://www.bukka.p.chiba-u.ac.jp/~ohmori/&gt;</A>
+$B$H$7$^$9!#(B
+</P>
+<P>
+$B$3$N%=%U%H%&%'%"$K4X$7$F$NLd$$9g$o$;$OBg?95*?M(B <A HREF="mailto:ohmori@p.chiba-u.ac.jp">&lt;URI:mailto:ohmori@p.chiba-u.ac.jp&gt;</A>$B$K$*4j$$$7$^$9!#(B
+<HR>
+<H2><A HREF="#i_difference" NAME="difference">gdevlips4-1.2.0 $B$H$N0c$$(B</A></H2>
+<P>
+lips3.dev lips4c.dev lips4.dev$B$K4X$7$F!"(Bgdevlips4-1.2.0 $B$G$N<!$N$h$&$JIT6q9g$,(B
+$BD>$C$F$$$^$9!#(B
+</P>
+<UL>
+  <LI>$B>e%^!<%8%s$,0u;z8B3&$N(B 5mm $B$^$G0u:~$G$-$k$h$&$K$J$C$?!#(B(gdevlips4-1.2.0 $B$G$O(B63/300$B%$%s%A(B($BLs(B10.3mm))
+  <LI>$B%^!<%8%sJQ99$KBP1~(B
+  <LI>$B%Z!<%8%5%$%:JQ99$KBP1~!#=PNO$G$-$J$$%Z!<%8%5%$%:$K$O$A$c$s$H%(%i!<$rJV$9!#(B
+  <LI>$B2rA|EYJQ99$KBP1~!#=PNO$G$-$J$$2rA|EY$K$O$A$c$s$H%(%i!<$rJV$9!#(B
+  <LI>$B%W%j%s%?$NGr;f$r=PNO$7$J$$@_Dj$,$-$A$s$HH?1G$5$l$k!#(B
+  <LI>BJC-880J $B$G(BA4$B$h$jBg$-$$MQ;f$K0u:~$9$k$H$-!V(B20 $B%Z!<%8(B $B%*!<%P!<!W$N%(%i!<$,H/@8$9$kLdBj$N2r7h(B
+</UL>
+<P>
+$B$^$?<!$N$h$&$J5!G=$,DI2C$5$l$F$$$^$9!#(B
+</P>
+<UL>
+  <LI>$B=PNO$N9bB.2=(B
+      <UL>
+	<LI>Ghostscript $B$N=hM}$N9bB.2=(B
+	<LI>$B%W%j%s%?$N=PNO$N9bB.2=(B
+	<LI>$BJ#?tIt0u:~;~$N9bB.2=(B
+      </UL>
+  <LI>$B%G%P%$%9$NDI2C(B
+      <UL>
+	<LI>LIPS II+ $B$KBP1~(B
+	<LI>LBP-840/LBP-850 $B$N%9!<%Q!<%U%!%$%s(B LIPS (1,200 dpi)$B$KBP1~(B
+	<LI>$B%Y%/%?!<HG%G%P%$%9(B lips4v.dev
+      </UL>
+  <LI>$B5k;fJ}K!$NA*Br$KBP1~(B
+  <LI>$B%i%9%?!<%$%a!<%8$N05=L$KBP1~(B
+  <LI>$B%Q%M%kI=<(JQ99$KBP1~(B
+  <LI>$BN>LL0u:~%f%K%C%H$KBP1~(B (LIPS IV $B$N$_(B)
+  <LI>n $BLL0u:~5!G=$KBP1~(B (LIPS IV $B$N$_(B)
+  <LI>$B%H%J!<G;EYD4@a5!G=$KBP1~(B (LIPS IV $B$N$_(B)
+  <LI>$B%H%J!<@aLs5!G=$KBP1~(B (LIPS IV $B$N$_(B)
+</UL>
+<HR>
+<H2><A HREF="#i_diff_epag" NAME="diff_epag">epag-3.08 $B$H$N0c$$(B</A></H2>
+<P>
+ESC/Page $B%I%i%$%PItJ,$O(B epag-3.08 $B$r%Y!<%9$K<c43$N%P%0%U%#%C%/%9$r$7$^$7$?!#(B
+$B$5$i$KJ#?tIt0u:~$r8zN(E*$K=PNO$G$-$k$h$&$K$7$^$7$?!#Gr9uH?E>0u:~$KBP1~$7$^$7$?!#(B
+$B$^$?!"(Bepag-3.08 $B$O$+$J$j%(%i!<=hM}$,4E$$$N$G$=$3$K$b<j$rF~$l$F$"$j$^$9!#(B
+</P>
+<P>
+ESC/Page $BMQ$N%G%P%$%9$,Fs$D$KA}$($F$$$k$N$O(B Ghostscript $B$N;EMM$K9g$o$;$k$?$a$G$9!#(B
+$B5U$K$$$&$H(B epag-3.08 $B$O(B Ghostscript $B$N;EMM$K9g$C$F$$$^$;$s!#(B
+($BNc$($P(B LP-1700S $B$G$O(B epag-3.08 $B$G$O(B -r600 $B%*%W%7%g%s$r;XDj$7$?$@$1$G$O(B 600 dpi $B0u:~$,@5>o$K$G$-$^$;$s!#(B)
+</P>
+<HR>
+<H2><A HREF="#i_diff_npdl" NAME="diff_npdl">gdevnpdl-1.5 $B$H$N0c$$(B</A></H2>
+<P>
+$B$3$N%I%i%$%P$K4^$^$l$k(B npdl.dev $B$O(B gdevnpdl-1.5 $B$K<!$N$h$&$J5!G=$,DI2C$5$l$F$$$^$9!#(B
+</P>
+<UL>
+  <LI>$B0u:~B.EY$N9bB.2=(B
+  <LI>$B$O$,$-%5%$%:$N%5%]!<%H(B
+  <LI>$B%i%s%I%9%1!<%W$N%5%]!<%H(B
+  <LI>$BJ#?tIt0u:~;~$K%3%T!<%b!<%I$r;H$$9bB.$K0u:~$G$-$k(B
+  <LI>$BGr9uH?E>0u:~$KBP1~(B
+</UL>
+<P>
+$B$^$?!"2rA|EY$N%G%U%)%k%H$,(B 240 dpi $B$K$J$C$F$$$k$H$3$m$,0[$J$j$^$9!#(B
+(gdevnpdl-1.5 $B$G$O(B 400 dpi)
+</P>
+<HR>
+<H2><A HREF="#i_lbp_list" NAME="lbp_list">LIPS $BBP1~%W%j%s%?$H=PNO%G%P%$%9(B</A></H2>
+<P>
+LIPS $BBP1~%W%j%s%?$H=PNO%G%P%$%9L>(B/$B2rA|EY$N%j%9%H$G$9!#(B
+$B$3$l$O!"$"$/$^$G$b5,3J>e=PNO$G$-$k$b$N$r%j%9%H$7$?$@$1$G!"A4$F$N%W%j%s%?$G<B:]$K=PNO$G$-$k$3$H$r3NG'$7$?$o$1$G$O$J$$$N$GCm0U$7$F2<$5$$!#(B
+</P>
+<TABLE BORDER SUMMARY="LIPS Priner and Output Device">
+  <TR>
+    <TH>$B5!<o(B</TH><TH>$B%G%P%$%9L>(B</TH><TH>$B2rA|EY(B (dpi)</TH><TH>$BHw9M(B</TH>
+  </TR>
+  <TR>
+    <TH ROWSPAN=2><A HREF="http://www.canon-sales.co.jp/faq/lbp/980021/lbp406s.html">LBP-B406S</A></TH><TD>lips2p</TD><TD>240x240</TD>
+  </TR>
+  <TR>
+    <TD>lips3</TD><TD>300x300</TD><TD>$B3HD%(BRAM$B5Z$S3HD%(BROM$B$NA}@_$,I,MW(B</TD>
+  </TR>
+  <TR>
+    <TH ROWSPAN=2><A HREF="http://www.canon-sales.co.jp/faq/lbp/980021/lbp406d.html">LBP-B406D</A></TH><TD>lips2p</TD><TD>240x240</TD>
+  </TR>
+  <TR>
+    <TD>lips3</TD><TD>300x300</TD><TD>$B3HD%(BRAM$B5Z$S3HD%(BROM$B$NA}@_$,I,MW(B</TD>
+  </TR>
+  <TR>
+    <TH><A HREF="http://www.canon-sales.co.jp/faq/lbp/980021/lbp406e.html">LBP-B406E</A></TH><TD>lips3</TD><TD>300x300</TD>
+  </TR>
+  <TR>
+    <TH><A HREF="http://www.canon-sales.co.jp/faq/lbp/980021/lbp406g.html">LBP-B406G</A></TH><TD>lips3</TD><TD>300x300</TD>
+  </TR>
+  <TR>
+    <TH><A HREF="http://www.canon-sales.co.jp/faq/lbp/980021/lbp406eII.html">LBP-B406E II</A></TH><TD>lips3</TD><TD>300x300</TD>
+  </TR>
+  <TR>
+    <TH><A HREF="http://www.canon-sales.co.jp/faq/lbp/980021/lbp406gII.html">LBP-B406G II</A></TH><TD>lips3</TD><TD>300x300</TD>
+  </TR>
+  <TR>
+    <TH ROWSPAN=2><A HREF="http://www.canon-sales.co.jp/faq/lbp/980021/lbp404.html">LBP-A404</A></TH><TD>lips2p</TD><TD>240x240</TD>
+  </TR>
+  <TR>
+    <TD>lips3</TD><TD>300x300</TD><TD>$B3HD%(BRAM$B5Z$S3HD%(BROM$B$NA}@_$,I,MW(B</TD>
+  </TR>
+  <TR>
+    <TH><A HREF="http://www.canon-sales.co.jp/faq/lbp/980021/lbp404e.html">LBP-B404E</A></TH><TD>lips3</TD><TD>300x300</TD>
+  </TR>
+  <TR>
+    <TH><A HREF="http://www.canon-sales.co.jp/faq/lbp/980021/lbp404gII.html">LBP-A404G II</A></TH><TD>lips3</TD><TD>300x300</TD>
+  </TR>
+  <TR>
+    <TH><A HREF="http://www.canon-sales.co.jp/faq/lbp/980021/lbp404f.html">LBP-A404F</A></TH><TD>lips3</TD><TD>300x300</TD>
+  </TR>
+  <TR>
+    <TH><A HREF="http://www.canon-sales.co.jp/faq/lbp/980021/lbp405jr.html">LBP-A405Jr.</A></TH><TD>lips3</TD><TD>300x300</TD>
+  </TR>
+  <TR>
+    <TH><A HREF="http://www.canon-sales.co.jp/faq/lbp/980021/lbp304e.html">LBP-A304E</A></TH><TD>lips3</TD><TD>300x300</TD>
+  </TR>
+  <TR>
+    <TH><A HREF="http://www.canon-sales.co.jp/faq/lbp/980021/lbp304eII.html">LBP-A304E II</A></TH><TD>lips3</TD><TD>300x300</TD>
+  </TR>
+  <TR>
+    <TH><A HREF="http://www.canon-sales.co.jp/faq/lbp/980021/lbp304gII.html">LBP-A304G II</A></TH><TD>lips3</TD><TD>300x300</TD>
+  </TR>
+  <TR>
+    <TH><A HREF="http://www.canon-sales.co.jp/faq/lbp/980021/lbp309gII.html">LBP-A309G II</A></TH><TD>lips3</TD><TD>300x300</TD>
+  </TR>
+  <TR>
+    <TH><A HREF="http://www.canon-sales.co.jp/faq/lbp/980021/lbp310.html">LBP-310</A></TH><TD>lips3</TD><TD>300x300</TD>
+  </TR>
+  <TR>
+    <TH><A HREF="http://www.canon-sales.co.jp/faq/lbp/980021/lbp320.html">LBP-320</A></TH><TD>lips3</TD><TD>300x300</TD>
+  </TR>
+  <TR>
+    <TH><A HREF="http://www.canon-sales.co.jp/Product/LBP/LBP-320Pro.html">LBP-320Pro</A></TH><TD>lips3</TD><TD>300x300</TD>
+  </TR>
+  <TR>
+    <TH  ROWSPAN=2><A HREF="http://www.canon-sales.co.jp/faq/lbp/980021/lbp730.html">LBP-730</A></TH><TD>lips4</TD><TD>300x300, 600x600</TD>
+  </TR>
+  <TR>
+    <TD>lips4v</TD><TD>300x300, 600x600</TD><TD>MaxiMem $BHsBP1~$J$N$G(B<A HREF="#clipping">$B%Q%9%/%j%C%T%s%0;~$N%a%b%jITB-(B</A>$B$KCm0U(B</TD>
+  </TR>
+  <TR>
+    <TH ROWSPAN=2><A HREF="http://www.canon-sales.co.jp/faq/lbp/980021/lbp720.html">LBP-720</A></TH><TD>lips4</TD><TD>300x300, 600x600</TD>
+  </TR>
+  <TR>
+    <TD>lips4v</TD><TD>300x300, 600x600</TD><TD>MaxiMem $BHsBP1~$J$N$G(B<A HREF="#clipping">$B%Q%9%/%j%C%T%s%0;~$N%a%b%jITB-(B</A>$B$KCm0U(B</TD>
+  </TR>
+  <TR>
+    <TH ROWSPAN=2><A HREF="http://www.canon-sales.co.jp/Product/LBP/LBP-450.html">LBP-450</A></TH><TD>lips4</TD><TD>300x300, 600x600</TD>
+  </TR>
+  <TR>
+    <TD>lips4v</TD><TD>300x300, 600x600</TD><TD>MaxiMem $BHsBP1~$J$N$G(B<A HREF="#clipping">$B%Q%9%/%j%C%T%s%0;~$N%a%b%jITB-(B</A>$B$KCm0U(B</TD>
+  </TR>
+  <TR>
+    <TH ROWSPAN=2><A HREF="http://www.canon-sales.co.jp/faq/lbp/980021/lbp830.html">LBP-830</A></TH><TD>lips4</TD><TD>300x300, 600x600</TD>
+  </TR>
+  <TR>
+    <TD>lips4v</TD><TD>300x300, 600x600</TD><TD>MaxiMem $BHsBP1~$J$N$G(B<A HREF="#clipping">$B%Q%9%/%j%C%T%s%0;~$N%a%b%jITB-(B</A>$B$KCm0U(B</TD>
+  </TR>
+  <TR>
+    <TH ROWSPAN=2><A HREF="http://www.canon-sales.co.jp/Product/LBP/LBP-430.html">LBP-430</A></TH><TD>lips4</TD><TD>300x300, 600x600</TD>
+  </TR>
+  <TR>
+    <TD>lips4v</TD><TD>300x300, 600x600</TD>
+  </TR>
+  <TR>
+    <TH ROWSPAN=2><A HREF="http://www.canon-sales.co.jp/faq/lbp/980021/lbp930.html">LBP-930</A></TH><TD>lips4</TD><TD>300x300, 600x600</TD>
+  </TR>
+  <TR>
+    <TD>lips4v</TD><TD>300x300, 600x600</TD>
+  </TR>
+  <TR>
+    <TH ROWSPAN=2><A HREF="http://www.canon-sales.co.jp/Product/LBP/LBP-750.html">LBP-750</A></TH><TD>lips4</TD><TD>300x300, 600x600</TD>
+  </TR>
+  <TR>
+    <TD>lips4v</TD><TD>300x300, 600x600</TD>
+  </TR>
+  <TR>
+    <TH ROWSPAN=2><A HREF="http://www.canon-sales.co.jp/Product/LBP/LBP-740.html">LBP-740</A></TH><TD>lips4</TD><TD>300x300, 600x600</TD>
+  </TR>
+  <TR>
+    <TD>lips4v</TD><TD>300x300, 600x600</TD>
+  </TR>
+  <TR>
+    <TH ROWSPAN=2><A HREF="http://www.canon-sales.co.jp/Product/LBP/LBP-930EX.html">LBP-930EX</A></TH><TD>lips4</TD><TD>300x300, 600x600</TD>
+  </TR>
+  <TR>
+    <TD>lips4v</TD><TD>300x300, 600x600</TD>
+  </TR>
+  <TR>
+    <TH ROWSPAN=2><A HREF="http://www.canon-sales.co.jp/Product/LBP/LBP-850.html">LBP-850</A></TH><TD>lips4</TD><TD>300x300, 600x600, 1200x1200</TD><TD>1200 dpi $B;~$O(B lips4v $B$N$[$&$,$$$$(B?</TD>
+  </TR>
+  <TR>
+    <TD>lips4v</TD><TD>300x300, 600x600, 1200x1200</TD>
+  </TR>
+  <TR>
+    <TH ROWSPAN=2><A HREF="http://www.canon-sales.co.jp/Product/LBP/LBP-840.html">LBP-840</A></TH><TD>lips4</TD><TD>300x300, 600x600, 1200x1200</TD><TD>1200 dpi $B;~$O(B lips4v $B$N$[$&$,$$$$(B?</TD>
+  </TR>
+  <TR>
+    <TD>lips4v</TD><TD>300x300, 600x600, 1200x1200</TD>
+  </TR>
+  <TR>
+    <TH ROWSPAN=2><A HREF="http://www.canon-sales.co.jp/Product/LBP/LBP-2030.html">LBP-2030</A></TH><TD>lips4</TD><TD>300x300, 600x600</TD><TD>$B%+%i!<=PNO$O(B -dBitsPerPixel=24 $B%*%W%7%g%s$G!#(B($B$3$N%I%i%$%P$G$OHs>o$KCY$$$G$9!#(B)</TD>
+  </TR>
+  <TR>
+    <TD>lips4v</TD><TD>300x300, 600x600</TD><TD>$B%+%i!<=PNO$O(B -dBitsPerPixel=24 $B%*%W%7%g%s$G!#(BMaxiMem $BHsBP1~$J$N$G(B<A HREF="#clipping">$B%Q%9%/%j%C%T%s%0;~$N%a%b%jITB-(B</A>$B$KCm0U(B</TD>
+  </TR>
+  <TR>
+    <TH ROWSPAN=2><A HREF="http://www.canon-sales.co.jp/Product/LBP/LBP-2160.html">LBP-2160</A></TH><TD>lips4</TD><TD>300x300, 600x600</TD><TD>$B%+%i!<=PNO$O(B -dBitsPerPixel=24 $B%*%W%7%g%s$G!#(B($B$3$N%I%i%$%P$G$OHs>o$KCY$$$G$9!#(B)</TD>
+  </TR>
+  <TR>
+    <TD>lips4v</TD><TD>300x300, 600x600</TD><TD>$B%+%i!<=PNO$O(B -dBitsPerPixel=24 $B%*%W%7%g%s$G!#(B</TD>
+  </TR>
+  <TR>
+    <TH ROWSPAN=2><A HREF="http://www.canon-sales.co.jp/Product/LBP/LBP-2040.html">LBP-2040</A></TH><TD>lips4</TD><TD>300x300, 600x600</TD><TD>$B%+%i!<=PNO$O(B -dBitsPerPixel=24 $B%*%W%7%g%s$G!#(B($B$3$N%I%i%$%P$G$OHs>o$KCY$$$G$9!#(B)</TD>
+  </TR>
+  <TR>
+    <TD>lips4v</TD><TD>300x300, 600x600</TD><TD>$B%+%i!<=PNO$O(B -dBitsPerPixel=24 $B%*%W%7%g%s$G!#(B</TD>
+  </TR>
+  <TR>
+    <TH><A HREF="http://www.canon-sales.co.jp/faq/bj/980026/bjc880j.html">BJC-880J</A></TH>
+    <TD>bjc880j</TD><TD>360x360</TD><TD>$B%+%i!<=PNO$O(B -dBitsPerPixel=24 $B%*%W%7%g%s$G!#(B($BHs>o$KCY$$$G$9!#(B)</TD>
+  </TR>
+  <TR>
+    <TH><A HREF="http://www.canon-sales.co.jp/faq/bj/980026/bjc680j.html">BJC-680J</A></TH>
+    <TD>bjc880j</TD><TD>360x360</TD><TD>$B%+%i!<=PNO$O(B -dBitsPerPixel=24 $B%*%W%7%g%s$G!#(B($BHs>o$KCY$$$G$9!#(B)</TD>
+  </TR>
+</TABLE>
+<HR>
+<H2><A HREF="#i_lp_list" NAME="lp_list">ESC/Page $BBP1~%W%j%s%?$H=PNO%G%P%$%9(B</A></H2>
+<P>
+ESC/Page $BBP1~%W%j%s%?$H=PNO%G%P%$%9L>(B/$B2rA|EY$N%j%9%H$G$9!#(B
+$B$3$l$O!"$"$/$^$G$b5,3J>e=PNO$G$-$k$b$N$r%j%9%H$7$?$@$1$G!"A4$F$N%W%j%s%?$G<B:]$K=PNO$G$-$k$3$H$r3NG'$7$?$o$1$G$O$J$$$N$GCm0U$7$F2<$5$$!#(B
+</P>
+<TABLE BORDER SUMMARY="ESC/Page Priner and Output Device">
+  <TR>
+    <TH>$B5!<o(B</TH><TH>$B%G%P%$%9L>(B</TH><TH>$B2rA|EY(B (dpi)</TH><TH>$BHw9M(B</TH>
+  </TR>
+  <TR>
+    <TD>LP-7000</TD><TD>lp2000</TD><TD>240x240</TD>
+  </TR>
+  <TR>
+    <TD>LP-7000G</TD><TD>lp2000</TD><TD>240x240</TD>
+  </TR>
+  <TR>
+    <TD>LP-2000</TD><TD>lp2000</TD><TD>300x300</TD>
+  </TR>
+  <TR>
+    <TD>LP-3000</TD><TD>lp2000</TD><TD>300x300</TD>
+  </TR>
+  <TR>
+    <TD>LP-1500</TD><TD>escpage</TD><TD>300x300</TD>
+  </TR>
+  <TR>
+    <TD>LP-1500S</TD><TD>escpage</TD><TD>300x300</TD>
+  </TR>
+  <TR>
+    <TD>LP-8000</TD><TD>escpage</TD><TD>300x300</TD>
+  </TR>
+  <TR>
+    <TD>LP-8000S</TD><TD>escpage</TD><TD>300x300</TD>
+  </TR>
+  <TR>
+    <TD>LP-8000SE</TD><TD>escpage</TD><TD>300x300</TD>
+  </TR>
+  <TR>
+    <TD>LP-8000SX</TD><TD>escpage</TD><TD>300x300</TD>
+  </TR>
+  <TR>
+    <TD>LP-1000</TD><TD>escpage</TD><TD>300x300</TD>
+  </TR>
+  <TR>
+    <TD>LP-1600</TD><TD>escpage</TD><TD>300x300, 600x600</TD>
+  </TR>
+  <TR>
+    <TD>LP-1700</TD><TD>escpage</TD><TD>300x300, 600x600</TD>
+  </TR>
+  <TR>
+    <TD>LP-1700S</TD><TD>escpage</TD><TD>300x300, 600x600</TD>
+  </TR>
+  <TR>
+    <TD><A HREF="http://www.i-love-epson.co.jp/products/seihin/printer/laser/esper/lp1800.htm">LP-1800</A></TD><TD>escpage</TD><TD>300x300, 600x600</TD>
+  </TR>
+  <TR>
+    <TD><A HREF="http://www.i-love-epson.co.jp/products/seihin/printer/laser/prospert/lp800.htm">LP-800</A></TD><TD>escpage</TD><TD>300x300, 600x600</TD>
+  </TR>
+  <TR>
+    <TD>LP-8200</TD><TD>escpage</TD><TD>300x300, 600x600</TD>
+  </TR>
+  <TR>
+    <TD><A HREF="http://www.i-love-epson.co.jp/products/seihin/printer/laser/esper/lp8300.htm">LP-8300</A></TD><TD>escpage</TD><TD>300x300, 600x600</TD>
+  </TR>
+  <TR>
+    <TD>LP-8300S</TD><TD>escpage</TD><TD>300x300, 600x600</TD>
+  </TR>
+  <TR>
+    <TD><A HREF="http://www.i-love-epson.co.jp/products/seihin/printer/laser/esper/lp8400.htm">LP-8400</A></TD><TD>escpage</TD><TD>300x300, 600x600</TD>
+  </TR>
+  <TR>
+    <TD>LP-8500</TD><TD>escpage</TD><TD>300x300, 600x600</TD>
+  </TR>
+  <TR>
+    <TD><A HREF="http://www.i-love-epson.co.jp/products/seihin/printer/laser/esper/lp8600.htm">LP-8600</A></TD><TD>escpage</TD><TD>300x300, 600x600</TD>
+  </TR>
+  <TR>
+    <TD>LP-9000</TD><TD>escpage</TD><TD>300x300, 600x600</TD>
+  </TR>
+  <TR>
+    <TD>LP-9200</TD><TD>escpage</TD><TD>300x300, 600x600</TD>
+  </TR>
+  <TR>
+    <TD>LP-9200S</TD><TD>escpage</TD><TD>300x300, 600x600</TD>
+  </TR>
+  <TR>
+    <TD><A HREF="http://www.i-love-epson.co.jp/products/seihin/printer/laser/esper/lp92sx.htm">LP-9200SX</A></TD><TD>escpage</TD><TD>300x300, 600x600</TD>
+  </TR>
+  <TR>
+    <TD><A HREF="http://www.i-love-epson.co.jp/products/seihin/printer/laser/inter/lp9300.htm">LP-9300</A></TD><TD>escpage</TD><TD>300x300, 600x600</TD>
+  </TR>
+  <TR>
+    <TD><A HREF="http://www.i-love-epson.co.jp/products/seihin/printer/laser/inter/lp9600.htm">LP-9600</A></TD><TD>escpage</TD><TD>300x300, 600x600</TD>
+  </TR>
+  <TR>
+    <TD>LP-8000C</TD><TD>escpage</TD><TD>300x300, 600x600</TD><TD>$B%+%i!<=PNO$O$G$-$^$;$s(B</TD>
+  </TR>
+</TABLE>
+<HR>
+<H2><A HREF="#i_mw_list" NAME="mw_list">NPDL $BBP1~%W%j%s%?$H=PNO%G%P%$%9(B</A></H2>
+<P>
+NPDL $BBP1~%W%j%s%?$H=PNO%G%P%$%9L>(B/$B2rA|EY$N%j%9%H$G$9!#(B
+$B$3$l$O!"$"$/$^$G$b5,3J>e=PNO$G$-$k$b$N$r%j%9%H$7$?$@$1$G!"A4$F$N%W%j%s%?$G<B:]$K=PNO$G$-$k$3$H$r3NG'$7$?$o$1$G$O$J$$$N$GCm0U$7$F2<$5$$!#(B
+</P>
+<TABLE BORDER SUMMARY="NPDL Priner and Output Device">
+  <TR>
+    <TH>$B5!<o(B</TH><TH>$B%G%P%$%9L>(B</TH><TH>$B2rA|EY(B (dpi)</TH><TH>$BHw9M(B</TH>
+  </TR>
+  <TR>
+    <TD>PC-PR1000</TD><TD>npdl</TD><TD>240x240</TD><TD>$BGr9uH?E>0u:~(B(-dNegativePrint)$B$KHsBP1~(B</TD>
+  </TR>
+  <TR>
+    <TD>PC-PR2000</TD><TD>npdl</TD><TD>240x240</TD><TD>$BGr9uH?E>0u:~(B(-dNegativePrint)$B$KHsBP1~(B</TD>
+  </TR>
+  <TR>
+    <TD>PC-PR1000/2</TD><TD>npdl</TD><TD>240x240</TD><TD>$BGr9uH?E>0u:~(B(-dNegativePrint)$B$KHsBP1~(B</TD>
+  </TR>
+  <TR>
+    <TD>PC-PR2000/2</TD><TD>npdl</TD><TD>240x240</TD>
+  </TR>
+  <TR>
+    <TD>PC-PR2000/4</TD><TD>npdl</TD><TD>400x400</TD>
+  </TR>
+  <TR>
+    <TD>PC-PR4000/4</TD><TD>npdl</TD><TD>400x400</TD>
+  </TR>
+  <TR>
+    <TD>PC-PR3000PS/4F</TD><TD>npdl</TD><TD>400x400</TD><TD>PostScript $B$K$bBP1~(B</TD>
+  </TR>
+  <TR>
+    <TD>PC-PR1000/4</TD><TD>npdl</TD><TD>400x400</TD>
+  </TR>
+  <TR>
+    <TD>PC-PR3000PS/4</TD><TD>npdl</TD><TD>400x400</TD><TD>PostScript $B$K$bBP1~(B</TD>
+  </TR>
+  <TR>
+    <TD>PC-PR4000E/4</TD><TD>npdl</TD><TD>400x400</TD>
+  </TR>
+  <TR>
+    <TD>PC-PR1000E/4R</TD><TD>npdl</TD><TD>400x400</TD>
+  </TR>
+  <TR>
+    <TD>PC-PR1000E/4</TD><TD>npdl</TD><TD>400x400</TD>
+  </TR>
+  <TR>
+    <TD>PC-PR1000FX/4</TD><TD>npdl</TD><TD>400x400</TD>
+  </TR>
+  <TR>
+    <TD>PC-PR2000/4R</TD><TD>npdl</TD><TD>400x400</TD>
+  </TR>
+  <TR>
+    <TD>PC-PR2000/4W</TD><TD>npdl</TD><TD>400x400</TD>
+  </TR>
+  <TR>
+    <TD>PC-PR2000/6W</TD><TD>npdl</TD><TD>600x600</TD>
+  </TR>
+  <TR>
+    <TD>PC-PR1000E/4W</TD><TD>npdl</TD><TD>400x400</TD>
+  </TR>
+  <TR>
+    <TD>MultiWriter 1000EW (PC-PR1000EW)</TD><TD>npdl</TD><TD>400x400</TD>
+  </TR>
+  <TR>
+    <TD>MultiWriter 2000E (PC-PR2000E)</TD><TD>npdl</TD><TD>400x400</TD>
+  </TR>
+  <TR>
+    <TD>MultiWriter 2000FW (PC-PR2000FW)</TD><TD>npdl</TD><TD>600x600</TD>
+  </TR>
+  <TR>
+    <TD>MultiWriter 2000NW (PC-PR2000NW)</TD><TD>npdl</TD><TD>400x400</TD>
+  </TR>
+  <TR>
+    <TD>MultiWriter 2200NW2 (PC-PR2200NW2)</TD><TD>npdl</TD><TD>400x400</TD>
+  </TR>
+  <TR>
+    <TD>MultiWriter 2400 (PC-PR2400)</TD><TD>npdl</TD><TD>400x400</TD>
+  </TR>
+  <TR>
+    <TD>MultiWriter 2000X (PC-PR2000X)</TD><TD>npdl</TD><TD>600x600</TD>
+  </TR>
+  <TR>
+    <TD>MultiWriter 2200X (PC-PR2200X)</TD><TD>npdl</TD><TD>600x600</TD>
+  </TR>
+  <TR>
+    <TD>MultiWriter 2400X (PC-PR2400X)</TD><TD>npdl</TD><TD>400x400</TD>
+  </TR>
+  <TR>
+    <TD>MultiWriter 2200X2 (PR-L2200X2)</TD><TD>npdl</TD><TD>600x600</TD>
+  </TR>
+  <TR>
+    <TD>MultiWriter 2200XE (PR-L2200X2)</TD><TD>npdl</TD><TD>600x600</TD>
+  </TR>
+  <TR>
+    <TD>MultiWriter 2000X2 (PR-L2000X2)</TD><TD>npdl</TD><TD>600x600</TD>
+  </TR>
+  <TR>
+    <TD><A HREF="http://www.pc98.nec.co.jp/PRODUCT/EXT/print/mw2000x/">MultiWriter 1400X (PR-L1400X)</A></TD><TD>npdl</TD><TD>600x600</TD>
+  </TR>
+  <TR>
+    <TD><A HREF="http://www.pc98.nec.co.jp/PRODUCT/EXT/print/mw6050/spec1.htm">MultiWriter 6050 (PC-L6050A)</A></TD><TD>npdl</TD><TD>400x400, 600x600</TD>
+  </TR>
+  <TR>
+    <TD><A HREF="http://www.pc98.nec.co.jp/PRODUCT/EXT/print/mw6050/spec1.htm">MultiWriter 4050 (PR-L4050)</A></TD><TD>npdl</TD><TD>400x400, 600x600</TD>
+  </TR>
+  <TR>
+    <TD><A HREF="http://www.pc98.nec.co.jp/PRODUCT/EXT/print/mw2000x/">MultiWriter 2050 (PR-L2050)</A></TD><TD>npdl</TD><TD>600x600</TD>
+  </TR>
+  <TR>
+    <TD><A HREF="http://www.pc98.nec.co.jp/PRODUCT/EXT/print/mw2000x/">MultiWriter 2250 (PR-L2250)</A></TD><TD>npdl</TD><TD>600x600</TD>
+  </TR>
+  <TR>
+    <TD><A HREF="http://www.pc98.nec.co.jp/PRODUCT/EXT/print/mw2650e/">MultiWriter 2650 (PR-L2650)</A></TD><TD>npdl</TD><TD>600x600</TD>
+  </TR>
+  <TR>
+    <TD><A HREF="http://www.pc98.nec.co.jp/PRODUCT/EXT/print/mw2650e/">MultiWriter 2650E (PR-L2650E)</A></TD><TD>npdl</TD><TD>600x600</TD>
+  </TR>
+</TABLE>
+<HR>
+<H2><A HREF="#i_unsupported" NAME="unsupported">$BBP1~$7$F$$$J$$%W%j%s%?(B</A></H2>
+<P>
+$B<!$N%W%j%s%?$O%5%]!<%H$7$F$$$^$;$s!#(B
+</P>
+<UL>
+  <LI>LIPS I/LIPS II $B%W%j%s%?(B
+  <LI>Windows Printing System (WPS)$B@lMQ%W%j%s%?(B
+     <UL>
+        <LI><A HREF="http://www.canon-sales.co.jp/faq/lbp/980021/lbp210.html">Canon LBP-210</A>
+        <LI><A HREF="http://www.canon-sales.co.jp/faq/lbp/980021/lbp220.html">Canon LBP-220</A>
+        <LI>Canon LBP-220Pro
+        <LI>NEC MultiWriter 1000LW(PC-PR1000LW)
+        <LI>NEC MultiWriter 1100(PR-L1100)
+     </UL>
+  <LI><A HREF="http://www.canon-sales.co.jp/faq/lbp/980021/lbp310.html">Canon LBP-310</A>/<A HREF="http://www.canon-sales.co.jp/faq/lbp/980021/lbp320.html">LBP-320</A>/LBP-320Pro $B$N%$%a!<%8%b!<%I(B(LIPS III $B$G$O=PNO2DG=(B)
+  <LI><A HREF="http://www.canon-sales.co.jp/faq/bj/980026/bjc680j.html">Canon BJC-680J</A>/<A HREF="http://www.canon-sales.co.jp/faq/bj/980026/bjc880j.html">BJC-880J</A> $B0J30$N%$%s%/%8%'%C%H%W%j%s%?(B
+  <LI>EPSON LP-5000 ($B8E$9$.(B)
+</UL>
+<HR>
+<H2><A HREF="#i_install" NAME="install">$B%$%s%9%H!<%k(B</A></H2>
+<OL>
+  <LI>Ghostscript $B$N%=!<%9%G%#%l%/%H%j$K(B
+      gdevespg.c$B!"(B gdevl4r.c$B!"(B gdevl4v.c$B!"(Bgdevlips.c$B!"(Bgdevlips.h$B!"(B gdevlprn.c$B!"(Bgdevlprn.h$B!"(Bgdevnpdl.c $B$r%3%T!<$7$^$9!#(B($BMW$9$k$K(B *.c *.h $B$r%3%T!<$7$^$9!#(B)
+<PRE>
+      $BNc(B:
+      cp *.c *.h "Ghostscript $B$N%G%#%l%/%H%j(B"
+</PRE>
+  <LI>Ghostscript 5.50 $B$N>l9g$O(B gdevlips.mak $B$r(B contrib.mak $B$KDI2C$7$^$9!#(B
+<PRE>
+      $BNc(B:
+      cat gdevlips.mak &gt;&gt;contrib.mak
+</PRE>
+  <LI>Ghostscript 5.10 $B$N>l9g$O(B gdevlips.mak $B$r(B Makefile $B$KDI2C$7$^$9!#(B
+<PRE>
+      $BNc(B:
+      cat gdevlips.mak &gt;&gt;makefile
+</PRE>
+  <LI>Makefile $B$N(B DEVICE_DEVS $B$K(B<A HREF="#dev">$B%G%P%$%9$H$=$N5!G=(B</A>$B$K=R$Y$i$l$k$N%G%P%$%9$N$&$AI,MW$J$b$N$r5-=R$7$^$9!#(B
+  <LI>B4$B!"(BB5$B!"(BB6 $B%5%$%:$J$I$NMQ;f$r07$&>l9g$O(B gs_statd.ps $B$K%Q%C%A$r$"$F$^$9!#(B
+<PRE>
+      $BNc(B:
+       patch &lt;gs_statd.dif
+</PRE>      
+  <LI>Ghostscript $B$r%3%s%Q%$%k$7!"%$%s%9%H!<%k$7$^$9!#(B
+</OL>
+<HR>
+<H3><A NAME="dev">$B%G%P%$%9$H$=$N5!G=(B</A></H3>
+<H4>$B%i%9%?!<HG%I%i%$%P(B</H4>
+<DL>
+  <DT>lips2p.dev</DT>
+  <DD>LIPS II+ $B$N%3!<%I$r=PNO$7$^$9!#(B</DD>
+  <DT>lips3.dev</DT>
+  <DD>LIPS III $B$N%3!<%I$r=PNO$7$^$9!#(B</DD>
+  <DT>bjc880j.dev</DT>
+  <DD>LIPS IVc (BJC-680J/880J $BMQ(B)$B$N%3!<%I$r=PNO$7$^$9!#%+%i!<=PNO$K$bBP1~$7$F$$$^$9!#(B</DD>
+  <DT>lips4.dev</DT>
+  <DD>LIPS IV $B$N%3!<%I$r=PNO$7$^$9!#%+%i!<=PNO$K$bBP1~$7$F$$$^$9!#(B</DD>
+  <DT>lp2000.dev</DT>
+  <DD>ESC/Page $B$N%3!<%I$r=PNO$7$^$9!#(B(LP-2000/LP-3000/LP-7000/LP-7000G $BMQ$G$9!#(B)</DD>
+  <DT>escpage.dev</DT>
+  <DD>ESC/Page $B$N%3!<%I$r=PNO$7$^$9!#BP1~5!<o$O(B<A HREF="#lp_list">ESC/Page $BBP1~%W%j%s%?$H=PNO%G%P%$%9(B</A>$B$r;2>H$N$3$H!#(B</DD>
+  <DT>npdl.dev</DT>
+  <DD>NPDL $B$N%3!<%I$r=PNO$7$^$9!#BP1~5!<o$O(B<A HREF="#mw_list">NPDL $BBP1~%W%j%s%?$H=PNO%G%P%$%9(B</A>$B$r;2>H$N$3$H!#(B</DD>
+</DL>
+<H4>$B%Y%/%?!<HG%I%i%$%P(B</H4>
+<DL>
+  <DT>lips4v.dev</DT>
+  <DD>LIPS IV $B$N%3!<%I$r=PNO$7$^$9!#%+%i!<=PNO$K$bBP1~$7$F$$$^$9!#(B</DD>
+</DL>
+<HR>
+<H2><A HREF="#i_usage" NAME="usage">$B;HMQJ}K!(B/$B;HMQ%*%W%7%g%s(B</A></H2>
+<P>
+$B0J2<$K$+$+$l$F$$$k%*%W%7%g%s$O(B PostScript $B%U%!%$%k$NCf$N%*%Z%l!<%?$G$bJQ99$5$l$k$3$H$,$"$j$^$9!#(B
+lpd $B$N%U%#%k%?!<$H$7$F;H$&>l9g$O$3$NCf$G(B <A HREF="#device">-sDEVICE</A>$B!"(B
+<A HREF="#resolution">-r</A> $B$N$_$r;XDj$9$k$H$h$$$G$7$g$&!#(B
+</P>
+<H3>LIPS$B!&(BESC/Page$B!&(BNPDL $B%I%i%$%P6&DL%*%W%7%g%s(B</H3>
+<DL>
+  <DT><A HREF="#device">-sDEVICE</A></DT>
+  <DD>$B=PNO$9$k%G%P%$%9$NJQ99$K;HMQ$7$^$9!#(B<EM>$B:GDc8B$3$l$@$1$O;XDj$7$F2<$5$$!#(B</EM></DD>
+  <DT><A HREF="#pagesize">-sPAPERSIZE</A></DT>
+  <DD>$B=PNO$9$kMQ;f%5%$%:$NJQ99$K;HMQ$7$^$9(B</DD>
+  <DT><A HREF="#numcopies">-dNumCopies</A></DT>
+  <DD>$B0u:~It?t$r;XDj$9$k>l9g$K;HMQ$7$^$9(B</DD>
+  <DT><A HREF="#resolution">-r</A></DT>
+  <DD>$B2rA|EY$r;XDj$9$k>l9g$K;HMQ$7$^$9(B</DD>
+  <DT><A HREF="#duplex">-dDuplex</A></DT>
+  <DD>$BN>LL0u:~$9$k>l9g$K;HMQ$7$^$9(B</DD>
+  <DT><A HREF="#tumble">-dTumble</A></DT>
+  <DD>$BN>LL0u:~$9$k>l9g$K$H$8J}8~$rJQ99$9$k>l9g$K;HMQ$7$^$9(B</DD>
+  <DT><A HREF="#negativeprint">-dNegativePrint</A></DT>
+  <DD>$BGr9uH?E>0u:~$,$G$-$^$9!#(B</DD>
+</DL>
+<H3>ESC/Page $B%I%i%$%P$N$_$N%*%W%7%g%s(B</H3>
+<DL>
+  <DT><A HREF="#ritoff">-dRITOff</A></DT>
+  <DD>RIT ($BNX3TJd@55!G=(B)$B$r%*%U$K$9$k>l9g$K;HMQ$7$^$9(B</DD>
+</DL>
+<H3>LIPS $B%I%i%$%P$N$_$N%*%W%7%g%s(B</H3>
+<DL>
+  <DT><A HREF="#bitsperpixel">-dBitsPerPixel</A><DT>
+  <DD>LIPS IV $B$K$*$$$F%b%N%/%m$H%+%i!<=PNO$r@ZBX$($k$?$a$K;HMQ$7$^$9(B</DD>
+  <DT><A HREF="#manualfeed">-dManualFeed</A></DT>
+  <DD>$B5k;f%H%l%$$+$i5k;f$9$k>l9g$K;HMQ$7$^$9(B</DD>
+  <DT><A HREF="#casset">-dCasset</A></DT>
+  <DD>$B5k;f$9$k%H%l%$(B/$B%+%;%C%H$r;XDj$9$k>l9g$K;HMQ$7$^$9(B</DD>
+  <DT><A HREF="#panel">-sUserName</A></DT>
+  <DD>$B%W%j%s%?$N%Q%M%k$KI=<($9$kJ8;z$rJQ99$9$k>l9g$K;HMQ$7$^$9(B</DD>
+  <DT><A HREF="#mediatype">-sMediaType</A></DT>
+  <DD>LBP-2160 (LBP-2040 $B$b(B?)$B$G=PNO$9$kMQ;f$N<oN`$r;XDj$9$k$?$a$K;HMQ$7$^$9!#(B
+  <DT><A HREF="#faceup">-dOutputFaceUp</A></DT>
+  <DD>LBP-2160 (LBP-2040 $B$b(B?)$B$G%U%'%$%9%"%C%W%H%l%$$K=PNO$9$k$?$a$K;HMQ$7$^$9!#(B
+  <DT><A HREF="#nup">-dNup</A></DT>
+  <DD>N $BLL0u:~$r$9$k>l9g$K;HMQ$7$^$9(B</DD>
+  <DT><A HREF="#pjl">-dPJL</A></DT>
+  <DD>PJL $B$r=PNO$9$k>l9g$K;HMQ$7$^$9(B</DD>
+  <DT><A HREF="#tdensity">-dTonerDensity</A></DT>
+  <DD>$B%H%J!<G;EYD4@a$r$9$k>l9g$K(B -dPJL $B$H$H$b$K;HMQ$7$^$9(B</DD>
+  <DT><A HREF="#tsave">-dTonerSaving</A></DT>
+  <DD>$B%H%J!<@aLs$r$9$k>l9g$K(B -dPJL $B$H$H$b$K;HMQ$7$^$9(B</DD>
+</DL>
+<HR>
+<H3>LIPS$B!&(BESC/Page$B!&(BNPDL $B%I%i%$%P6&DL%*%W%7%g%s(B</H3>
+<H4><A HREF="#i_device" NAME="device">$B%G%P%$%9JQ99(B</A></H4>
+<P>
+$B$3$N%I%i%$%P$r;HMQ$9$k$?$a$K$O(B -sDEVICE $B%*%W%7%g%s$G%G%P%$%9$rJQ99$9$kI,MW$,$"$j$^$9!#$=$l$>$l<!$N$h$&$K;XDj$7$^$9!#(B
+</P>
+<DL>
+  <DT>-sDEVICE=lips2p</DT>
+  <DD>lips2p $B%G%P%$%9$r;HMQ$7$^$9(B</DD>
+  <DT>-sDEVICE=lips3</DT>
+  <DD>lips3 $B%G%P%$%9$r;HMQ$7$^$9(B</DD>
+  <DT>-sDEVICE=bjc880j</DT>
+  <DD>bjc880j $B%G%P%$%9$r;HMQ$7$^$9(B</DD>
+  <DT>-sDEVICE=lips4</DT>
+  <DD>lips4 $B%G%P%$%9$r;HMQ$7$^$9(B</DD>
+  <DT>-sDEVICE=lips4v</DT>
+  <DD>lips4v $B%G%P%$%9$r;HMQ$7$^$9(B</DD>
+  <DT>-sDEVICE=lp2000</DT>
+  <DD>lp2000 $B%G%P%$%9$r;HMQ$7$^$9(B</DD>
+  <DT>-sDEVICE=escpage</DT>
+  <DD>escpage $B%G%P%$%9$r;HMQ$7$^$9(B</DD>
+  <DT>-sDEVICE=npdl</DT>
+  <DD>npdl $B%G%P%$%9$r;HMQ$7$^$9(B</DD>
+</DL>
+<HR>
+<H4><A HREF="#i_pagesize" NAME="pagesize">$B%G%U%)%k%HMQ;f%5%$%:JQ99(B($B%G%U%)%k%H(B:A4$B%5%$%:(B)</A></H4>
+<P>
+$B$3$N%I%i%$%P$G$O(B-sPAPERSIZE$B%*%W%7%g%s$+(Bsetpagedevice$B%*%Z%l!<%?$K$h$C$F(B
+$B;XDj$7$?%5%$%:$r(B<EM>$BMQ;fJ}8~$b4^$a$F(B</EM>$B@5$7$/07$&$3$H$,$G$-$^$9!#(B
+$B$?$@$7!"5!<o$K$h$C$FBP1~$9$kMQ;f%5%$%:$K@)8B$,$"$j$^$9$N$G$I$NMQ;f%5%$%:$,;H$($k$+$O;HMQ$7$F$$$k%W%j%s%?$N@bL@=q$r;2>H$7$F2<$5$$!#(B($BNc$($P!"(BA4 $B5!$G$"$k(B LBP-450 $B$G$O(B A3 $B$NMQ;f$G$O=PNO$G$-$^$;$s$7!"(BLBP-2160 $B$G$O41@=$O$,$-$K$OBP1~$7$F$$$^$;$s!#(B)
+</P>
+<P>
+$B$^$?!"(B<KBD>-sPAPERSIZE</KBD> $B%*%W%7%g%s$O%G%U%)%k%H$NMQ;f%5%$%:$rJQ99$9$k$@$1$G$9!#(B
+$BMQ;f%5%$%:$r8GDj$7$?$$>l9g$O(B <KBD>-dFIXEDMEDIA</KBD> $B%*%W%7%g%s$H$H$b$KMQ$$$F2<$5$$!#(B
+</P>
+<P>
+$B<!$N%*%W%7%g%s$,;XDj$5$l$?$H$-$9$Y$F$N%I%i%$%P$G(B
+$B%W%j%s%?$K@5$7$/MQ;f%5%$%:$N>pJs$,Aw$i$l$^$9!#(B
+($B$?$@$7!"(BB $B%5%$%:$H41@=$O$,$-$OIUB0$N%Q%C%A$r$"$F$k$3$H(B)
+</P>
+<DL>
+  <DT><KBD>-sPAPERSIZE=a3</KBD></DT><DD>A3</DD>
+  <DT><KBD>-sPAPERSIZE=a4</KBD></DT><DD>A4</DD>
+  <DT><KBD>-sPAPERSIZE=a5</KBD></DT><DD>A5</DD>
+  <DT><KBD>-sPAPERSIZE=b4</KBD></DT><DD>B4</DD>
+  <DT><KBD>-sPAPERSIZE=b5</KBD></DT><DD>B5</DD>
+  <DT><KBD>-sPAPERSIZE=letter</KBD></DT><DD>$B%l%?!<(B</DD>
+  <DT><KBD>-sPAPERSIZE=postcard</KBD></DT><DD>$B41@=$O$,$-(B</DD>
+</DL>
+<P>
+LIPS $B$H(B ESC/Page $B$N%I%i%$%P$G$O<!$N%5%$%:$K$bBP1~$7$F$$$^$9!#(B
+</P>
+<DL>
+  <DT><KBD>-sPAPERSIZE=legal</KBD></DT><DD>$B%j!<%,%k(B</DD>
+  <DT><KBD>-sPAPERSIZE=ledger</KBD></DT><DD>$B%l%8%c!<(B</DD>
+  <DT><KBD>-sPAPERSIZE=b6</KBD></DT><DD>B6</DD>
+</DL>
+<P>
+LIPS $B$N%I%i%$%P$N$_<!$N%5%$%:$KBP1~$7$F$$$^$9!#(B
+</P>
+<DL>
+  <DT><KBD>-sPAPERSIZE=envyou4</KBD></DT><DD>$BMN7A(B4$B9f(B($BIuE{(B)</DD>
+</DL>
+<P>
+$BG$0U$NMQ;f%5%$%:$O<!$N$h$&$K$7$F;XDj$7$^$9!#(B
+</P>
+<DL>
+  <DT><KBD>-g</KBD><VAR>number1</VAR><KBD>x</KBD><VAR>number2</VAR></DT>
+  <DD><KBD>-dDEVICEWIDTH=</KBD><VAR>number1</VAR> $B$H(B<KBD>-dDEVICEHEIGHT=</KBD><VAR>number2</VAR>
+      $B$r;XDj$7$?>l9g$b0UL#$OF1$8$G$9!#(B
+      $B$=$l$>$l%T%/%;%kC10L$GMQ;f$NI}(B(<VAR>number1</VAR>)$B$H(B
+      $B9b$5(B(<VAR>number2</VAR>)$B$r;XDj$7$F2<$5$$!#(B</DD>
+</DL>
+<P>
+LIPS $B%I%i%$%P$K4X$7$F$O41@=$O$,$-%5%$%:$h$j>.$5$$%5%$%:$d(B A3 $B%5%$%:$h$j(B
+$BBg$-$J%5%$%:$O(B LIPS $B$N5,3J>e0u:~$G$-$J$$$3$H$K$J$C$F$$$k$N$G!"(B
+$B$=$N$h$&$J%5%$%:$,;XDj$5$l$?>l9g$O=hM}$r9T$J$$$^$;$s!#(B($B%(%i!<$K$J$j$^$9(B)
+</P>
+<HR>
+<H4><A HREF="#i_numcopies" NAME="numcopies">$BJ#?tIt0u:~(B($B%G%U%)%k%H(B:1$BIt(B)</A></H4>
+<P>
+$B$3$N%I%i%$%P$G$OJ#?tIt0u:~$K$*$$$F%W%j%s%?$N%3%T!<%b!<%I$r;HMQ$7!"9bB.$K0u:~$5$l$^$9!#(B
+</P>
+<P>
+$B%3%^%s%I%i%$%s$G$O!"(B<KBD>-dNumCopies=</KBD><VAR>number</VAR>$B$H$7$F(B
+$B0u:~It?t(B<VAR>number</VAR>$B$r;XDj$7$F2<$5$$!#(B<VAR>number</VAR>$B$N:GBgCM$O(B
+$B<!$N$h$&$K$J$C$F$$$^$9!#$3$l0J>e$NCM$r;XDj$7$F$b:GBgCM$NIt?t$7$+0u:~$5$l$^$;$s!#(B
+</P>
+<DL>
+  <DT>LIPS$B!"(BESC/Page $B%W%j%s%?(B</DT><DD>255</DD>
+  <DT>NPDL $B%W%j%s%?(B</DT><DD>99</DD>
+</DL>
+<HR>
+<H4><A HREF="#i_resolution" NAME="resolution">$B2rA|EYJQ99(B($B%G%U%)%k%H$O2<5-(B)</A></H4>
+<P>
+<KBD>-r</KBD><VAR>$B2rA|EY(B</VAR> $B%*%W%7%g%s$G2rA|EY$rJQ99$9$k$3$H$,$G$-$^$9!#(B
+</P>
+<DL>
+<DT>lips2p</DT><DD>240</DD>
+<DT>lips3</DT><DD>300</DD>
+<DT>bjc880j</DT><DD>60$B!A(B360 ($B%G%U%)%k%H(B 360 dpi)</DD>
+<DT>lips4</DT><DD>60$B!A(B600$B!"(B1200 ($B%G%U%)%k%H(B 600 dpi)</DD>
+<DT>lips4v</DT><DD>60$B!A(B600$B!"(B1200 ($B%G%U%)%k%H(B 600 dpi)</DD>
+<DT>lp2000</DT><DD>60$B!A(B300 ($B%G%U%)%k%H(B 300 dpi)</DD>
+<DT>escpage</DT><DD>60$B!A(B600 ($B%G%U%)%k%H(B 300 dpi)</DD>
+<DT>npdl</DT><DD>160$B!"(B200$B!"(B240$B!"(B400$B!"(B600 ($B%G%U%)%k%H(B 240 dpi)</DD>
+</DL>
+<P>
+LIPS IV $B$G(B $B9b2rA|EY(B (600 dpi$B!"(B1200 dpi) $B0u;z$r9T$J$&>l9g$O(B <A HREF="#hireso">LIPS IV $B=PNO$K$*$1$k9b2rA|EY0u;z$K4X$9$kCm0U(B</A>$B$rFI$s$G2<$5$$!#(B
+$B$b$7FbB"%a%b%j$,B-$j$J$$$h$&$G$7$?$i(B -r300 $B$H$7$F(B 300 dpi $B$G0u:~$9$k$3$H$r(B
+$B$*$9$9$a$7$^$9!#(B
+</P>
+<P>
+[$BHw9M(B]$B8=:_(B(1999$BG/(B4$B7n(B15$BF|(B)$B$N$H$3$m!"(BLIPS IV $B$G(B
+1200 dpi $B$G=PNO2DG=$J%W%j%s%?$O(B LBP-840/LBP-850 $B$7$+H/Gd$5$l$F$$$^$;$s!#(B
+</P>
+<HR>
+<H4><A HREF="#i_duplex" NAME="duplex">$BN>LL0u:~(B($B%G%U%)%k%H(B:$B%Q%M%k@_Dj(B)</A></H4>
+<P>
+$B%W%j%s%?$NCf$K$ON>LL0u:~%f%K%C%H$rAuHw$G$-$k$b$N$,$"$j$^$9$,!"(B
+$B$=$N5!G=$,;H$($^$9!#$H$8J}$O(B2$B<oN`A*Br$G$-$^$9!#(B
+$B$3$N5!G=$K4X78$9$k$N$O(B Duplex $B$H(B Tumble $B$G$9!#(B
+</P>
+<P>
+Ghostscript $B$N%*%W%7%g%s$H$7$FN>LL0u:~$r;XDj$9$k>l9g$K$O<!$N$h$&$J(B
+$B%*%W%7%g%s$r;H$C$F2<$5$$!#(B
+</P>
+<UL>
+  <LI><KBD>-dDuplex</KBD>
+</UL>
+<P>
+$B$^$?!"JRLL0u:~$r;XDj$9$k>l9g$K$O<!$N$h$&$J%*%W%7%g%s$r;H$C$F2<$5$$!#(B
+<EM>$B8=:_$N$H$3$m(B NPDL $B%I%i%$%P$OJRLL0u:~$K$OBP1~$7$F$$$^$;$s!#(B</EM>
+</P>
+<UL>
+  <LI><KBD>-dDuplex=false</KBD>
+</UL>
+<H5><A NAME="tumble">$B$H$8J}8~(B ($B%G%U%)%k%H(B: $BD9JU$H$8(B)</A></H5>
+<P>
+$BN>LL0u:~$r$9$k$H$-$H$8J}8~$rD9JU$H$8$+C;JU$H$8$r;XDj$G$-$^$9!#(B
+$B%G%U%)%k%H$G$OD9JU$H$8$G$9!#C;JU$H$8$r;XDj$9$k>l9g$K$O<!$N$h$&$J(B
+$B%*%W%7%g%s$r;H$C$F2<$5$$!#(B
+$BJRLL0u:~;~$K$3$N%*%W%7%g%s$r;XDj$7$F$b0UL#$O$"$j$^$;$s!#(B
+<EM>$B8=:_$N$H$3$m(B NPDL $B%I%i%$%P$OC;JU$H$8$K$OBP1~$7$F$$$^$;$s!#(B</EM>
+</P>
+<UL>
+  <LI><KBD>-dTumble</KBD>
+</UL>
+<HR>
+<H4><A HREF="#i_negativeprint" NAME="negativeprint">$BGr9uH?E>0u:~(B ($B%G%U%)%k%H(B: $BH?E>$7$J$$(B)</A></H4>
+<P>
+lips4.dev($B%b%N%/%m$N$_(B)$B!"(Blp2000.dev$B!"(Bescpage.dev$B!"(Bnpdl.dev(NPDL (level2)$BBP1~5!<o$N$_(B) $B$K8B$j<!$N%*%W%7%g%s$rF~NO$9$k$3$H$GGr9u$rH?E>$5$;$k$3$H$,$G$-$^$9!#(B
+</P>
+<UL>
+  <LI>-dNegativePrint
+</UL>
+<HR>
+<H3>ESC/Page $B%I%i%$%P$N$_BP1~$N%*%W%7%g%s(B</H3>
+<H4><A HREF="#i_ritoff" NAME="ritoff">RIT ($BNX3TJd@55!G=(B)$B$r%*%U$K$9$k(B ($B%G%U%)%k%H(B: RIT $B$r;H$&(B)</A></H4>
+<P>
+escpage.dev $B$K8B$j<!$N%*%W%7%g%s$r;H$&$3$H$K$h$j(B RIT (Resolution Improvement Technology$B!"NX3TJd@55!G=(B)$B$r%*%U$K$9$k$3$H$,$G$-$^$9!#(B
+</P>
+<P>
+$BDL>o$O(B RIT $B$O%*%s$N$^$^;H$($P$h$$$G$9$,!"%Q%?!<%sEI$j$D$V$7$J$N$G0U?^$7$?0u:~7k2L$H0c$&$b$N$,=PNO$5$l$k>l9g$O$3$N5!G=$r;H$C$F(B RIT $B$r%*%U$K$7$F$/$@$5$$!#(B
+</P>
+<UL>
+  <LI>-dRITOff
+</UL>
+<HR>
+<H3>LIPS $B%I%i%$%P$N$_BP1~$N%*%W%7%g%s(B</H3>
+<H4><A HREF="#i_bitsperpixel" NAME="bitsperpixel">$B%b%N%/%m$H%+%i!<=PNO$N@ZBX$((B($B%G%U%)%k%H(B:$B%b%N%/%m(B)</A></H4>
+<P>
+<EM>$B$3$N%*%W%7%g%s$O(B bjc880j$B!"(Blips4$B!"(Blips4v $B$N$_BP1~$7$F$$$^$9!#(B</EM>
+</P>
+<P>
+<KBD>-dBitsPerPixel=</KBD><VAR>number</VAR>$B%*%W%7%g%s$K$h$j%b%N%/%m$H(B
+$B%+%i!<=PNO$N@ZBX$($,$G$-$^$9!#(B
+</P>
+<H5>bjc880j$B!"(Blips4</H5>
+<DL>
+<DT>-dBitsPerPixel=1</DT><DD>$B%b%N%/%m=PNO(B ($B%G%U%)%k%H(B)</DD>
+<DT>-dBitsPerPixel=24</DT><DD>$B%+%i!<=PNO(B</DD>
+</DL>
+<H5>lips4v</H5>
+<DL>
+<DT>-dBitsPerPixel=8</DT><DD>$B%b%N%/%m=PNO(B ($B%G%U%)%k%H(B)</DD>
+<DT>-dBitsPerPixel=24</DT><DD>$B%+%i!<=PNO(B</DD>
+</DL>
+<HR>
+<H4><A HREF="#i_feed" NAME="feed">$B5k;fJ}K!$NA*Br(B($B%G%U%)%k%H(B:$B<+F0A*Br(B)</A></H4>
+<P>
+<EM>$B$3$N%*%W%7%g%s$O(B LIPS $B$N%G%P%$%9$N$_BP1~$7$F$$$^$9!#(B</EM>
+</P>
+<P>
+-dManualFeed$B%*%W%7%g%s$K$h$k(BMP$B%H%l%$(B($B5k;f%H%l%$(B)$B$+$i$N5k;f$H(B
+-dCasset$B%*%W%7%g%s$K$h$k5k;f%+%;%C%H$NA*Br$KBP1~$7$^$7$?!#(B
+$B%G%U%)%k%H$G$N5k;f$O<+F0A*Br$K$J$j$^$9!#$^$?!"(B-dManualFeed$B%*%W%7%g%s$G$N(B
+$B;XDj$O(B-dCasset$B$K$h$k;XDj$h$j$bM%@h$9$k$3$H$KCm0U$7$F2<$5$$!#(B
+</P>
+<H5><A NAME="manualfeed">MP$B%H%l%$(B($B5k;f%H%l%$(B)$B$+$i$N5k;f(B</A></H5>
+<P>
+$B<!$N$h$&$J%*%W%7%g%s$r;XDj$9$k$3$H$G(BMP$B%H%l%$(B($B5k;f%H%l%$(B)$B$+$i(B
+$B5k;f$G$-$^$9!#(B
+</P>
+<UL>
+  <LI><KBD>-dManualFeed</KBD>
+</UL>
+<H5><A NAME="casset">$B5k;f%+%;%C%H$NA*Br(B</A></H5>
+<P>
+<EM>$B$3$N%*%W%7%g%s$O(B LIPS $B$N%G%P%$%9$N$_BP1~$7$F$$$^$9!#(B</EM>
+</P>
+<P>
+<KBD>-dCasset=</KBD><VAR>number</VAR>$B%*%W%7%g%s$^$?$O(B<KBD>-DCasset=</KBD>
+<VAR>number</VAR>$B$K$h$j5k;f%+%;%C%H$r(B
+$BA*Br$G$-$^$9!#(B
+<VAR>number</VAR>$B$N;XDj$O<!$N$h$&$K$J$j$^$9!#$3$l$i0J30$N?tCM$r;XDj$9$k$H(B
+$B%(%i!<$K$J$j$^$9!#(B
+</P>
+<DL>
+  <DT>-1</DT><DD>$B5k;f%+%;%C%H$NA*Br$r$9$k%3%^%s%I$r=PNO$7$J$$(B</DD>
+  <DT>0</DT><DD>$B<+F05k;f(B</DD>
+  <DT>1</DT><DD>$B<j:9$75k;f(B(MP$B%H%l%$(B)</DD>
+  <DT>2</DT><DD>$B2<CJ%+%;%C%H5k;f(B</DD>
+  <DT>3</DT><DD>$B>eCJ%+%;%C%H5k;f(B</DD>
+  <DT>10</DT><DD>MP$B%H%l%$(B($B<j:9$75k;f$KAjEv(B)</DD>
+  <DT>11</DT><DD>$B%+%;%C%H(B1</DD>
+  <DT>12</DT><DD>$B%+%;%C%H(B2</DD>
+  <DT>13</DT><DD>$B%+%;%C%H(B3</DD>
+  <DT>14</DT><DD>$B%+%;%C%H(B4</DD>
+  <DT>15</DT><DD>$B%+%;%C%H(B5</DD>
+  <DT>16</DT><DD>$B%+%;%C%H(B6</DD>
+  <DT>17</DT><DD>$B%+%;%C%H(B7</DD>
+</DL>
+<P>
+-dCasset=-1 $B$O(B -dCasset=0 $B$G$O<+F05k;f$,F/$+$J$$>l9g$KMQ$$$F2<$5$$!#(B
+($B>/$J$/$H$b(B LBP-A405Jr. $B$G$OMQ$$$kI,MW$,$"$k$h$&$G$9(B)
+</P>
+<P>
+$B%W%m%0%i%^!<%:%^%K%e%"%k(B 4.2 $B$K$h$k$H;Y>c$N$J$$8B$j(B&quot;0&quot;$B$^$?$O(B&quot;10&quot;$B!A(B&quot;17&quot;$B$rMQ$$$F2<$5$$$H$$$&$3$H$J$N$G(B LIPS IV $BEk:\%W%j%s%?$G$O$=$N$h$&$K$7$?$[$&$,$h$$$G$7$g$&!#(B
+</P>
+<HR>
+<H4><A HREF="#i_panel" NAME="panel">$B%Q%M%kI=<(JQ99(B($B%G%U%)%k%H(B:Ghostscript)</A></H4>
+<P>
+<EM>$B$3$N%*%W%7%g%s$O(B LIPS $B$N%G%P%$%9$N$_BP1~$7$F$$$^$9!#(B</EM>
+</P>
+<P>
+$B%W%j%s%?$N%9%F!<%?%9I=<(It$KI=<($9$k%3%a%s%H$r(B-dUserName$B%*%W%7%g%s$r(B
+$BMQ$$$FF0E*$KI=<($9$k$3$H$,$G$-$k$h$&$K$J$j$^$7$?!#$3$l$K$h$C$F(B
+Ghostscript$B$r0u:~$N%U%#%k%?!<$H$7$F;H$C$F$$$k>l9g!"(B
+$B<!$N$h$&$J%$%s%W%C%H%U%#%k%?!<$r;H$&$3$H$K$h$C$F0u:~;~$K%f!<%6L>$r(B
+$B%W%j%s%?$N%9%F!<%?%9I=<(It$KI=<($G$-$k$h$&$K$J$j$^$9!#(B
+<PRE>
+<CODE>#!/bin/sh</CODE>
+
+<CODE><VAR>user</VAR>=/dev/null</CODE>
+
+<CODE>#</CODE>
+<CODE># Get username from filter parameters</CODE>
+<CODE>#</CODE>
+<CODE>while [ <VAR>$#</VAR> != 0 ]</CODE>
+<CODE>do  case "<VAR>$1</VAR>" in</CODE>
+    <CODE>-n)   <VAR>user</VAR>=<VAR>$2</VAR> ; shift ;;</CODE>
+    <CODE>*)    ;;</CODE>
+    <CODE>esac</CODE>
+    <CODE>shift</CODE>
+<CODE>done</CODE>
+
+<CODE>gs -q -sDEVICE=lips4 -dSAFER -dNOPAUSE -sUserName=<VAR>$user</VAR> -sOutputFile=- -</CODE>
+
+<CODE>exit 0</CODE>
+</PRE>
+<HR>
+<H4><A HREF="#i_mediatype" NAME="mediatype">$BMQ;f<oN`;XDj(B</A></H4>
+<P>
+<EM>$B$3$N%*%W%7%g%s$O(B LBP-2160 ($B$b$7$+$7$?$i(B LBP-2040$B$b(B?)$B$KBP1~$7$F$$$^$9!#(B</EM>
+</P>
+<P>
+LBP-2160($B$b$7$+$7$?$i!"(BLPB-2040$B$b(B?) $B$G$OIaDL;f!"8|;f!"(BOHP$B!"8wBt%U%#%k%`$KBP1~$7$F$$$^$9$,!"(B
+$BE,@Z$J%3%^%s%I$r=PNO$7$J$$$H%H%J!<$NDjCe$KITET9g$,@8$8$^$9!#(B
+$B<!$N%*%W%7%g%s$rMQ$$$F$=$l$>$l$NMQ;f$K=PNO$7$F$/$@$5$$!#(B
+$B$J$*!"IaDL;f0J30$r;XDj$9$k$H<+F0E*$K5k;f%H%l%$$+$i5k;f$5$l$k$h$&$K$J$j$^$9!#(B
+</P>
+<DL>
+  <DT><KBD>-sMediaType=PlanePaper</KBD></DT><DD>$BIaDL;f(B</DD>
+  <DT><KBD>-sMediaType=CardBoard</KBD></DT><DD>$B8|;f(B</DD>
+  <DT><KBD>-sMediaType=OHP</KBD></DT><DD>OHP</DD>
+  <DT><KBD>-sMediaType=TransparencyFilm</KBD></DT><DD>OHP</DD>
+  <DT><KBD>-sMediaType=GlossyFilm</KBD></DT><DD>$B8wBt%U%#%k%`(B</DD>
+</DL>
+<HR>
+<H4><A HREF="#i_faceup" NAME="faceup">$B%U%'%$%9%"%C%W%H%l%$$N=PNO(B</A></H4>
+<P>
+<EM>$B$3$N%*%W%7%g%s$O(B LBP-2160 ($B$b$7$+$7$?$i(B LBP-2040$B$b(B?)$B$N$_$KBP1~$7$F$$$^$9!#(B</EM>
+</P>
+<P>
+LPB-2160 $B$G$ODL>o$N%U%'%$%9%@%&%s%H%l%$$NB>$K%U%'%$%9%"%C%W%H%l%$$X$N=PNO$r%5%]!<%H$7$F$$$^$9!#<!$N%*%W%7%g%s$K$h$j%U%'%$%9%"%C%W%H%l%$$K=PNO$9$k$3$H$,$G$-$^$9!#(B
+</P>
+<P>
+$B$b$7$+$7$?$i!"(BLPB-2040 $B$G$b;HMQ$G$-$k$+$b$7$l$^$;$s!#(B
+</P>
+<UL>
+  <LI>-dOutputFaceUp
+</UL>
+<HR>
+<H3><A HREF="#i_nup" NAME="nup">n $BLL0u:~(B ($B%G%U%)%k%H(B: $B%Q%M%k@_Dj(B)</A></H3>
+<P>
+<EM>$B$3$N%*%W%7%g%s$O(B LIPS IV $B$N%G%P%$%9$N$_BP1~$7$F$$$^$9!#(B</EM>
+</P>
+<P>
+<EM>[$B7Y9p(B]</EM>$B$3$l$O(B LIPS IV $B$NHs8x3+5!G=$r;H$C$F$$$k$?$a!";HMQ$K$O==J,$KCm0U$7$F2<$5$$!#BP1~$7$F$$$J$$5!<o$b$"$k$+$b$7$l$^$;$s!#(B
+$B$^$?!"(Bpsnup $B$G$&$^$/$$$/(B PostScript $B%U%!%$%k$N>l9g$O!"(Bpsnup $B$r;H$$$^$7$g$&!#(B
+psnup $B$r;H$&$[$&$,(B<EM>$BA4$F$NLL$G(B</EM>$BM%$l$F$$$^$9!#(B
+$B$3$N5!G=$O4pK\E*$K$O(B psnup $B$G$&$^$/$$$+$J$$(B PostScript $B%U%!%$%k$K;H$C$F2<$5$$!#(B
+$B>\$7$/$O(B FAQ $B$N(B<A HREF="#nup_printing">$B!V(B n $BLL0u:~$r$9$k$K$O!"$I$&$7$?$i$$$$$N(B? $B!W(B</A>$B$rFI$s$G2<$5$$!#(B
+$B$^$?!"Ek:\%a%b%jNL$K$h$j!"!V%7%9%F%`%a%b%j(B $B%U%k!W$J$I$N%(%i!<$K$J$k2DG=@-$b$"$k$+$b$7$l$^$;$s!#(B
+</P>
+<P>
+$B<!$N%*%W%7%g%s$r;H$&$3$H$K$h$j!"(Bn $BLL0u:~$,2DG=$G$9!#(B
+</P>
+<DL>
+  <DT>-dNup=1</DT>
+  <DD>1 $BLL0u:~(B ($B%G%U%)%k%H(B)</DD>
+  <DT>-dNup=2</DT>
+  <DD>2 $BLL0u:~(B</DD>
+  <DT>-dNup=4</DT>
+  <DD>4 $BLL0u:~(B</DD>
+</DL>
+<P>
+[$B:n<T$+$i$N=u8@(B]$B$3$N5!G=$G(B 4 $BLL0u:~$r$9$k>l9g!"(B300 dpi $B$H(B 600 dpi $B$N=PNO$KL@$i$+$J:9$O$J$$$N$G!"(B300 dpi $B$K2rA|EY$rMn$9$H$h$jB.$/=PNO$G$-$^$9!#(B2 $BLL0u:~$K$*$$$F$O$3$N8B$j$G$O$"$j$^$;$s!#(B
+1,200 dpi $B$H(B 600 dpi $B$N:9$O$I$&$J$C$F$$$k$+J,$+$j$^$;$s!#(B
+</P>
+<HR>
+<H4><A HREF="#i_fontdl" NAME="fontdl">$B%U%)%s%H%@%&%s%m!<%I(B($B%G%U%)%k%H(B: $B$7$J$$(B)</A></H4>
+<P>
+<EM>$B$3$N%*%W%7%g%s$O(B lips4v $B$N$_BP1~$7$F$$$^$9!#(B</EM>
+</P>
+<P>
+$B%Y%/%?!<HG%G%P%$%9(B lips4v $B$G$O%S%C%H%^%C%W%U%)%s%H$r%@%&%s%m!<%I$9$k$3$H$K$h$j!"F1$8J8;z$,7+$jJV$7$G$F$/$k>l9g!"$h$j9bB.$K0u:~$G$-$k$h$&$K$9$k$3$H$,$G$-$^$9!#FC$K1Q8l$NO@J8$J$I$G$O$3$N8z2L$O@dBg$G$9!#(B
+$B$7$+$7!"(BLIPS IV $B$N@)Ls$K$h$j%/%j%C%T%s%0=hM}$r9T$J$&>l9g!">/$7$G$b%/%j%C%T%s%0NN0hFb$K$"$kJ8;z$O%/%j%C%T%s%0NN0h30$NItJ,$,$"$C$?$H$7$F$b4]!9IA$+$l$F$7$^$&$H$$$&IT6q9g$,$"$j$^$9!#(B
+$B%/%j%C%T%s%0NN0h$r;H$$$3$J$7$??^7A$rIA$/$h$&$J>l9g$O$3$N%*%W%7%g%s$O;H$o$J$$J}$,$h$$$G$9!#(B
+$B$7$+$7$J$,$i!"%/%j%C%T%s%0NN0h$GJ8;z%+%C%H$7$J$,$iIA$/$H$$$&=hM}$O9T$J$o$J$$%f!<%6$NJ}$,B?$$$H;W$$$^$9!#(B
+</P>
+<P>
+$B$^$?!"(B18 point $B0J2<$N%-%c%i%/%?!<$7$+%@%&%s%m!<%I$O9T$J$$$^$;$s!#(B
+</P>
+<P>
+$B<!$N%*%W%7%g%s$r;H$&$3$H$K$h$j!"%U%)%s%H$N%@%&%s%m!<%I$,2DG=$G$9!#(B
+</P>
+<UL>
+  <LI><KBD>-dFontDL</KBD>
+</UL>
+<HR>
+<H4><A HREF="#i_pjl" NAME="pjl">PJL $B=PNO(B ($B%G%U%)%k%H(B: $B=PNO$7$J$$(B)</A></H4>
+<P>
+<EM>[$B7Y9p(B]</EM>$B$3$l$OHs8x3+5!G=$r;H$C$F$$$k$?$a!";HMQ$K$O==J,$KCm0U$7$F2<$5$$!#BP1~$7$F$$$J$$5!<o$b$"$j$^$9!#(B
+$B>/$J$/$H$b(B LIPS IV $BEk:\5!<o$G$OA4$F$N%G%P%$%9(B(lips*.dev)$B$G!"(B
+$B$3$N5!G=$,;H$($k$h$&$G$9!#(B
+</P>
+<P>
+$B<!$N%*%W%7%g%s$r;H$&$3$H$K$h$j(B PJL $B$r=PNO$7$^$9!#(B
+PJL $B$r=PNO$9$k$3$H$K$h$j%W%j%s%?$N(B LIPS $B%b!<%I$X$N@ZBX$r@)8f$G$-$^$9!#(B
+$B$7$+$7$J$,$i!"(BLASER SHOT $B$N(B LIPS $B%b!<%I$N<+F0G'<1$O$+$J$jM%=($J$N$GI,$:$7$b(B
+$B$3$N%*%W%7%g%s$r;H$&I,MW$O$"$j$^$;$s!#(B
+</P>
+<UL>
+  <LI><KBD>-dPJL</KBD>
+</UL>
+<P>
+$B$^$?!"(BPJL $B$rMQ$$$k$3$H$K$h$j!"(B<A HREF="#tdensity">$B%H%J!<G;EYD4@a5!G=(B</A>$B$d(B<A HREF="#tsave">$B%H%J!<@aLs5!G=(B</A>$B$r(B Ghostscript$B%I%i%$%P$GMQ$$$k$3$H$,$G$-$k$h$&$K$J$j$^$9!#(B
+</P>
+<H5><A HREF="#i_tdensity" NAME="tdensity">$B%H%J!<G;EYD4@a(B ($B%G%U%)%k%H(B: $B%Q%M%k@_Dj(B)</A></H5>
+<P>
+$B<!$N%*%W%7%g%s$r;H$&$3$H$K$h$j!"%H%J!<G;EYD4@a$,2DG=$G$9!#(B
+</P>
+<DL>
+  <DT><KBD>-dPJL -dTonerDensity=<VAR>n</VAR></KBD></DT>
+  <DD>n $B$O(B 0 $B$+$i(B 8, 0 $B$O%Q%M%k$N@_Dj!#?t;z$,Bg$-$$$[$IG;$/$J$j$^$9!#(B</DD>
+</DL>
+<H5><A HREF="#i_tsave" NAME="tsave">$B%H%J!<@aLs(B ($B%G%U%)%k%H(B: $B%Q%M%k@_Dj(B)</A></H5>
+<P>
+$B<!$N%*%W%7%g%s$r;H$&$3$H$K$h$j!"%H%J!<@aLs$,2DG=$G$9(B
+</P>
+<UL>
+  <LI><KBD>-dPJL -dTonerSaving</KBD>
+</UL>
+<P>
+$B5U$K<!$N%*%W%7%g%s$r;H$&$3$H$K$h$j!"%H%J!<@aLs$r(B<EM>$B$7$J$$(B</EM>$B$3$H$,2DG=$G$9(B
+</P>
+<UL>
+  <LI><KBD>-dPJL -dTonerSaving=false</KBD>
+</UL>
+<P>
+$B2?$b;XDj$7$J$$>l9g$O%W%j%s%?$N%Q%M%k@_Dj$K=>$$$^$9!#(B
+</P>
+<HR>
+<H4><A HREF="#i_netatalk" NAME="netatalk">Netatalk$B!&(BCAP $B$H(B Ghostscript + gdevlips</A></H4>
+<P>
+Netatalk $B$d(B CAP $B$rMQ$$$F(B Ghostscript + gdevlips $B$rMQ$$$k>l9g!"(B
+$BDL>o(B LaserWriter 8 $B$d(B Adobe PS $B$J$I$N%W%j%s%?%I%i%$%P$r;HMQ$7$^$9$,!"(B
+$B%W%j%s%?5-=R%U%!%$%k(B(PPD $B%U%!%$%k(B)$B$GE,@5$J$b$N$r=q$1$P>e5-$N%*%W%7%g%s$OA4$F(B Macintosh $B$+$i;XDj$G$-$k$h$&$K$J$j$^$9!#(B
+$B$^$??7$?$K%W%j%s%?5-=R%U%!%$%k$r=q$+$J$/$F$b4{B8$N$b$N$rMxMQ$9$l$P$+$J$j$N$3$H$,$G$-$^$9!#(B
+</P>
+<P>
+$B$^$?!"(BGhostscript $B%I%i%$%P$NCf$K$O(B LaserWrite 8 $B$N=PNO$9$k(B Landscape $B$,2sE>$G$-$J$$$b$N$,$"$j$^$9$,!"(B
+$B$3$N%I%i%$%P$G$O$-$A$s$H2sE>$7$F@5>o$K=PNO$9$k$h$&$K$J$C$F$$$k$N$G!"$=$NE@$O8f0B?42<$5$$!#(B
+</P>
+<P>
+$BNc$H$7$F(B<A HREF="ftp://ftp.adobe.com/pub/adobe/printerdrivers/mac/all/ppdlevel2/canon.sit.hqx">Canon LASER SHOT LBP-730PS$BMQ$N%W%j%s%?5-=R%U%!%$%k(B</A>$B$rMQ$$$?>l9g!"(B
+$BJQ99$J$7$G<!$N5!G=$,MxMQ$G$-$^$9!#(B
+</P>
+<UL>
+  <LI>$B%Z!<%8%5%$%:JQ99(B(A3$B!A$O$,$-(B)
+  <LI>$B<j:9$70u:~$H<+F00u:~$N@ZBX$((B(1$B%Z!<%8L\$H$=$l0J9_$N%Z!<%8$N=PNOJ}K!$r(B
+      $BJQ99$9$k5!G=$b;H$($k!#$?$@$7!"$3$N5!G=$O(B LIPS $B%I%i%$%P$N$_(B)
+  <LI>$B2rA|EYJQ99(B($B$?$@$7(B Ghostscript $B$N%*%W%7%g%s$K(B-dFIXEDRESOLUTION=false $B$r$D$1$k$3$H(B)
+  <LI>$BN>LL0u:~(B($BD9JU$H$8!"C;JU$H$8(B)
+</UL>
+<P>
+$B5k;fJ}K!A*Br%*%W%7%g%s$N$&$A(B-dManualFeed$B%*%W%7%g%s$O(BPostScript$B8@8l$N:nK!$K(B
+$B=>$C$F$$$^$9$,!"(B-dCasset$B%*%W%7%g%s$O$=$&$G$O$J$$$N$GCm0U$7$F2<$5$$!#(B
+-dCasset $B$rMQ$$$k$h$&$K(B PPD $B$r5-=R$9$l$P;H$($k$h$&$K$J$k$H;W$$$^$9!#(B
+</P>
+<HR>
+<H2><A HREF="#i_change" NAME="change">$BJQ99MzNr(B</A></H2>
+<H3>gdevlips-2.3.3 (1999/6/22 release)</H3>
+<UL>
+  <LI>[lips4v.dev]$BMQ;f%5%$%:JQ99$9$k%*%Z%l!<%?$r;HMQ$7$?$H$-$N5sF0$,(B
+      $B$*$+$7$/$J$k%P%0$N=$@5!#(B(Thanks to $B[X3@$5$s(B)
+</UL>
+<H3>gdevlips-2.3.2 (1999/5/18 release)</H3>
+<UL>
+  <LI>[npdl.dev]$BN>LL0u:~$N%5%]!<%H(B
+</UL>
+<H3>gdevlips-2.3.1 (1999/5/16 release)</H3>
+<UL>
+   <LI>[escpage.dev]-dRIP $B%*%W%7%g%s$K$h$k2rA|EYJd@55!G=@)8f$N%5%]!<%H(B($B%G%U%)%k%H$G$O%*%s$K$J$j$^$9(B)$B!#$3$l$O;04d$5$s$+$i>pJs$r$$$?$@$-$^$7$?!#(B
+   <LI>[npdl.dev]-dNegativePrint $B%*%W%7%g%s$K$h$kGr9uH?E>0u:~$N%5%]!<%H(B
+</UL>
+<H3>gdevlips-2.3.0 (1999/5/10 release)</H3>
+<UL>
+  <LI>NPDL $B@)8f8@8l$KBP1~$7$?%G%P%$%9(B npdl.dev $B$NDI2C(B
+  <LI>[lips4c.dev, lips4vc.dev]$B$=$l$>$l(B lips4.dev lips4v.dev $B$KE}9g$7$^$7$?!#(B
+  -dBitsPerPixel=24 $B%*%W%7%g%s$G%+%i!<$K@Z$jBX$o$j$^$9!#(B
+  <LI>[lp2000.dev, escpage.dev, lips4.dev]-dNegativePrint $B%*%W%7%g%s$K$h$kGr9uH?E>0u:~$N%5%]!<%H(B
+</UL>
+<H3>gdevlips-2.2.1 (1999/4/28 release)</H3>
+<UL>
+  <LI>[lp2000.dev, escpage.dev] $B5!<o$K$h$C$F$O0u:~$5$l$k:BI8$,$:$l$F$7$^$&(B
+      $B%P%0$N=$@5(B
+</UL>
+<H3>gdevlips-2.2.0 (1999/4/8 release)</H3>
+<UL>
+  <LI>ESC/Page $B@)8f8@8l$KBP1~$7$?%G%P%$%9(B lp2000.dev$B!"(Bescpage.dev $B$NDI2C(B
+  <LI>[lips2p$B!"(Blips3$B!"(Blips4]$B=PNO%"%k%4%j%:%`$r@.>>;a$N$b$N$rMQ$$$k$h$&$K$7$?!#(B
+      ($B<c439bB.$K$J$k(B?)
+</UL>
+<H3>gdevlips-2.1.2 (1999/3/1 release)</H3>
+<UL>
+  <LI>LBP-2160 $BMQ$N5!G=3HD%$K$h$j(BLBP-840 $B$GN>LL0u:~$dFsLL0u:~$,F/$+$J$$%P%0$N=$@5!#(B($B;{@n$5$s$+$i$NJs9p(B)
+</UL>
+<H3>gdevlips-2.1.1 (1999/2/23 release)</H3>
+<UL>
+  <LI>[lips4$B!"(Blips4c$B!"(Blips4v$B!"(Blips4vc] $B;3Fb!w2,;38)N)Bg$5$s$K(B LBP-2160 $B$NMM!9$JMQ;f=PNO$KBP1~$9$k%Q%C%A$r$$$?$@$$$?$N$G<h$j9~$s$@!#(B
+      $B$^$?!"(BLBP-2160 $B$N%U%'%$%9%"%C%W%H%l%$=PNO$KBP1~$9$k(B -dOutputFaceUp $B%*%W%7%g%s$,DI2C$5$l$?!#(B
+</UL>
+
+<H3>gdevlips-2.1.0 (1999/2/13 release)</H3>
+<UL>
+  <LI>[lips4v$B!"(Blips4vc] $B%Q%9$KBP$9$k%/%j%C%T%s%0$,@5>o$K$O$?$i$+$J$$%P%0$N=$@5(B
+  <LI>[lips4v$B!"(Blips4vc] $BB?3Q7A$NFbIt$rEI$j$D$V$9>l9g!"Hs%<%m4,?tK!$,%G%U%)%k%H$K$J$C$F$$$J$$%P%0$N=$@5(B
+  <LI>[lips4v$B!"(Blips4vc] $B%b%N%/%m2hA|$G%Q%?!<%s%U%#%k$J$I$7$?>l9g(B 1$B!A(B7 $B%I%C%H2hA|$,$:$l$k%P%0$N=$@5(B
+  <LI>[lips4v$B!"(Blips4vc] $BF)2a(B/$BGr$NAH9g$;$G%Q%?!<%s%U%#%k$J$I$7$?>l9gF)2a$JItJ,$HGr$NItJ,$N=hM}$,5U$K$J$C$F$$$k%P%0$N=$@5(B
+  <LI>[lips4v$B!"(Blips4vc] known bug $B$N5-=R$rDI2C(B
+</UL>
+<H3>gdevlips-2.0.12 (1999/2/11 release)</H3>
+<UL>
+  <LI>[lips4v$B!"(Blips4vc] $B%$%a!<%8=hM}$r9T$J$&$H%/%i%C%7%e$7$?$j@5>o$KIA$+$l$J$$%P%0$N=$@5(B
+  <LI>[lips4v$B!"(Blips4vc] $B6k7A$KBP$9$k3Q4]$aL?Na$d3Q@Z$jMn$H$7L?Na$J$I$,F/$+$J$$%P%0=$@5(B
+</UL>
+<H3>gdevlips-2.0.11 (1999/2/9 release)</H3>
+<UL>
+  <LI>[lips4v$B!"(Blips4vc] gdevlips-2.0.10 $B$N%P%0%U%#%C%/%9!#J8;z$J$I$rIA$/$H%3%"%@%s%W$9$k%P%0$r=$@5!#(B
+</UL>
+<H3>gdevlips-2.0.10 (1999/2/9 release)</H3>
+<UL>
+  <LI>[lips4v$B!"(Blips4vc] $BJ#;($J%$%a!<%8=hM}$r9T$J$&$H!"%3%"%@%s%W$9$k%P%0$r=$@5!#$^$?!"2hA|$N?'$,$*$+$7$/$J$k%P%0$H2hA|$,$:$l$FIA$+$l$k%P%0$r=$@5(B
+</UL>
+<H3>gdevlips-2.0.9 (1999/2/8 release)</H3>
+<UL>
+  <LI>[lips4v$B!"(Blips4vc] gdevlips-2.0.8 $B$NJQ99$K$*$$$F(B Hi-Level bitmap Imaging $B$G0lEY$KJ#?t%i%$%s$r07$&$H$-$K:G=i$N%i%$%s$7$+IA$+$l$J$$%P%0$rF~$l9~$s$G$7$^$C$?$N$G$=$l$r=$@5!#(B
+</UL>
+<H3>gdevlips-2.0.8 (1999/2/7 release)</H3>
+<UL>
+  <LI>[lips4v$B!"(Blips4vc] $BA4$F$N%S%C%H%^%C%W%k!<%A%s$,05=L$KBP1~(B
+  <LI>[lips4v$B!"(Blips4vc] $B2hA|$N1&C<$K(B1$BK\M>7W$J@~$,IA$+$l$k%P%0$r=$@5(B
+</UL>
+<H3>gdevlips-2.0.7 (1999/2/4 release)</H3>
+<UL>
+  <LI>[lips2p$B!"(Blips3$B!"(Blips4] $B$$$C$?$s05=L$7$F!"05=L8e$N7k2L$,0-$$>l9g$O05=L$5$l$F$$$J$$$b$N$rMQ$$$k$H$$$&%"%k%4%j%:%`$rF3F~!#(B
+      $B$=$N7k2L!"(Blips2p$B!"(Blips3 $B%G%P%$%9$G05=LN($,$+$J$j8~>e$7$?!#(B
+      $B05=L$7$?$?$a$K0u:~%9%T!<%I$,CY$/$J$k$H$$$&$3$H$b$+$J$j$N3d9g$GHr$1$i$l$k!#(B
+      $B$3$N%"%k%4%j%:%`F3F~$KH<$$(B -dCompress $B%*%W%7%g%s$OGQ;_$5$l$?!#(B
+</UL>
+<H3>gdevlips-2.0.6 (1999/1/30 release)</H3>
+<UL>
+  <LI>[lips4c] gdevlips-2.0.4 $B$N%P%0BP:v$G=PNO$,$=$l0JA0$N$b$NHf$Y$F(B 3 $BG\0J>eBg$-$/$J$C$F$7$^$&$N$G!"$b$C$H=PNO$,>.$5$/$J$k$h$&$KD4@0$7$?!#(B
+</UL>
+<H3>gdevlips-2.0.5 (1999/1/28 release)</H3>
+<UL>
+  <LI>[lips2p$B!"(Blips3$B!"(Blips4]$B05=L(B(-dCompress) $B$N@_Dj$N$H$-$N%P%0(B(gdevlips-2.0.1 $B$K:.F~(B)$B!#@5>o$KIA$+$l$J$+$C$?!#(B
+</UL>
+<H3>gdevlips-2.0.4 (1999/1/16 release)</H3>
+<UL>
+  <LI>[lips4c] $B05=L$r9T$J$&@_Dj$N$H$-$K!"(BVMError $B$,=P$?$j%3%"%@%s%W$7$?$j$9$k$3$H$,$"$k%P%0$N=$@5(B
+</UL>
+<H3>gdevlips-2.0.3 (1999/1/11 release)</H3>
+<UL>
+  <LI>[lips4v$B!"(Blips4vc] RGB 3 plane$B!_(B4 bit $B$N%G!<%?$r=hM}$9$k$H$-%i%9%?!<$,(B 1 dot $B$:$D$:$l$F$$$C$F$7$^$&$3$H$,$"$k%P%0$N=$@5(B (LIPS $B$N;EMM=q$N5-:\%_%9(B)
+  <LI>[lips4v$B!"(Blips4vc] $B0lIt$N%k!<%A%s$,05=L$KBP1~(B (1 bit $B$N%G!<%?$N$_(B)
+</UL>
+<H3>gdevlips-2.0.2 (1999/1/8 release)</H3>
+<UL>
+  <LI>$B%Y%/%?!<HG%G%P%$%9(B lips4v lips4vc $B$NI|3h(B
+      <UL>
+	<LI>[lips4v$B!"(Blips4vc]setflat $B%*%Z%l!<%?$r;HMQ$9$k$H6J@~$,%,%?%,%?$9$k%P%0$N=$@5(B
+	<LI>[lips4v$B!"(Blips4vc]$B%-%c%i%/%?!<$,@5>o$KIA$+$l$J$$%P%0$N2sHr(B
+	<LI>[lips4v$B!"(Blips4vc]$B2hA|Jd@5$r9T$C$?>l9g$N%P%0=$@5(B
+      </UL>
+</UL>
+<H3>gdevlips-2.0.1 (1998/11/30 release)</H3>
+<UL>
+  <LI>[lips2p$B!"(B lips3]$B%*%W%7%g%s$,@5>o$K5!G=$7$J$+$C$?$j!"M>7W$JJ8;z$,0u:~$5$l$k%P%0$N=$@5(B(gdevlips4-19981015 $B$GF~$j$3$s$@%P%0(B)
+  <LI>[lips2p$B!"(Blips3$B!"(Blips4]$B$A$g$C$H9bB.2=(B($BM>7W$J=hM}$,F~$C$F$$$?(B)
+  <LI>[lips4c]$B2rA|EY$N%G%U%)%k%H$r(B 600 dpi $B$K$7$?!#(B
+  <LI>$B<+F05k;f$,F/$+$J$$(B LASER SHOT $B$KBP1~$9$k%*%W%7%g%s(B -dCasset=-1 $B$NDI2C(B
+  <LI>[$BA4%G%P%$%9(B]PJL$B$r=PNO$9$k%*%W%7%g%s(B -dPJL $B$NDI2C!#(B
+      lips4.dev $B$G$O%G%U%)%k%H$G$O(B PJL $B$r=PNO$7$J$$$h$&$K$7$?!#(B
+      $B%H%J!<@aLs5!G=$d%H%J!<G;EYD4@a5!G=$O(B -dPJL $B%*%W%7%g%s$r;XDj$7$J$$$H(B
+      $B;H$($J$$$h$&$K$J$j$^$7$?!#(B
+</UL>
+<H3>gdevlips-2.0.0 (1998/11/16 release)</H3>
+<UL>
+  <LI>$B%Y%/%?!<HG%G%P%$%9(B lips4v lips4vc $B$NGQ;_(B(PDL $B$N%P%0$N$?$a(B)
+</UL>
+<H3>gdevlips-2.0.0pre1 (1998/10/10 release)</H3>
+<UL>
+  <LI>$B%P!<%8%g%sHV9f$N$D$1$+$?$rJQ99$7$?(B
+  <LI>[$BA4%G%P%$%9(B]$B%^!<%8%sJQ99$KBP1~(B
+  <LI>l4vmono $B"*(B lips4v$B!"(Bl4vcolor $B"*(B lips4vc $B$KL>>NJQ99(B
+  <LI>[lips4v lips4vc]$B%U%)%s%H$N%@%&%s%m!<%I5!G=$KBP1~(B($B$?$@$7@)8B$"$j(B)
+  <LI>[lips4v lips4vc]$B%^%$%?%j%_%C%H$,@5>o$K5!G=$7$J$$%P%0$N=$@5(B
+  <LI>[lips4v lips4vc]$B0lIt$N5!<o$G5/$3$kJ8;z$d2hA|$,>C$($k(B LIPS IV $B$N%P%0$r2sHr$7$?(B
+</UL>
+<H3>gdevlips4-19981104 (release 27)</H3>
+<UL>
+  <LI>Ghostscript 5.10 $BMQ$N(B Makefile $B$N5-=R$K8m$j$,$"$j!"%3%s%Q%$%k$G$-$J$$IT6q9g$r=$@5$7$?(B($B0KF#(B@$B72GOBg$5$s$NJs9p(B)
+</UL>
+<H3>gdevlips4-19981017 (release 26)</H3>
+<UL>
+  <LI>[lips2p lips3 lips4] $B%i%9%?!<%$%a!<%8=hM}$N%P%0=$@5!#(B
+      $B1&C<$N%i%9%?$,H4$1$?$j!"$R$I$$>l9g(B 1 $B%i%$%s4]!9IA$+$l$J$$$3$H$,$"$C$?!#(B
+</UL>
+<H3>gdevlips4-19981015 (release 25)</H3>
+<UL>
+  <LI>[lips4 l4vmono l4vcolor] n $BLL0u:~5!G=!&%H%J!<G;EYD4@a5!G=!&%H%J!<%;!<%V5!G=$NDI2C(B
+</UL>
+<H3>gdevlips4-19981012 (release 24)</H3>
+<UL>
+  <LI>[l4vmono] $B%Q%?!<%s$J$I$,Gv$$?'$K$J$C$?$j>C$($F$7$^$&%P%0$N=$@5(B
+</UL>
+<H3>gdevlips4-19981009 (release 23)</H3>
+<UL>
+  <LI>[l4vmono l4vcolor] $B6k7A$N2sE>$,$&$^$/$$$+$J$$%P%0$N=$@5(B
+  <LI>[l4vmono l4vcolor] $BJ8;z$K?'$,$D$+$J$$$3$H$,$"$k%P%0$N=$@5(B
+</UL>
+<H3>gdevlips4-19981006 (release 22)</H3>
+<UL>
+  <LI>[l4vmono l4vcolor] $B6k7A$rIA$$$?8e$N?^7A$,IA$+$l$J$$%P%0$N=$@5(B
+</UL>
+<H3>gdevlips4-19981005 (release 21)</H3>
+<UL>
+  <LI>[l4vmono l4vcolor] $B4q?t6v?tK!$G%Q%9$rEI$j$D$V$9=hM}$,Hs%<%m4,?tK!$G9T$J$o$l$k$h$&$K$J$C$F$$$k%P%0$rD>$7$?(B
+  <LI>[l4vmono l4vcolor] $B%^%$%?%j%_%C%H$N;XDjJ}K!$,4V0c$C$F$$$?!#(B
+  <LI>[lips4c] BJC-680J/BJC-880J $B$K$D$$$F!V(B20 $B%Z!<%8(B $B%*!<%P!<!W$N%(%i!<$,H/@8$9$kLdBj$N2r7h(B
+  <LI>Ghostscript 5.50 $B$NG[I[$HF1MM$K%I%-%e%a%s%H$rA4$F(B HTML $B$K$7$?!#(B
+  <LI>Ghostscript 5.10 $BBP1~%I%i%$%P$H(B Ghostscript 5.50 $BBP1~%I%i%$%P$rF1:-(B
+  <LI>lips4g$B!"(Blips3fig$B!"(Blips4fig$B!"(Blips4cfig $B%I%i%$%P$NGQ;_(B
+  <LI>$B$=$NB>:Y$+$$%P%0%U%#%C%/%9(B
+</UL>
+
+<H3>gdevlips4-19980924 (release 20)</H3>
+<UL>
+  <LI>Ghostscript 5.50 $BBP1~$K$7$?$H$-$N%P%0%U%#%C%/%9(B
+  <LI>$B%9!<%Q!<%U%!%$%s(B LIPS (1200 dpi) $BBP1~$N$?$a$N%F%9%H(B
+</UL>
+
+<H3>gdevlips4-19980922 (release 19)</H3>
+<UL>
+  <LI>Ghostscript 5.50 $BBP1~!#(B
+</UL>
+
+<H3>gdevlips4-19980908 (release 18)</H3>
+<UL>
+  <LI>[lips2p, lips3, lips4] $B9bB.$K=PNO$G$-$k%"%k%4%j%:%`$r:NMQ$7$?!#(B
+</UL>
+<H3>gdevlips4-19980904 (release 17)</H3>
+<UL>
+  <LI>[lips4c, lips4, lips4g] $B2hA|$rJ,$1$FE>Aw$9$k;~6u9T$,@hF,$KMh$k$H(B
+      $B4|BT$7$?=PNO$5$l$J$$(B LIPS IV $B$N;EMM$r2sHr$9$k$?$a!"(B-dcRowBuf $B$N%G%U%)%k%H(B
+      $B$r(B 0 $B$K$7$?!#(B
+  <LI>[l4vmono, l4vcolor] $B2hA|H?E>%P%0$N=$@5(B
+  <LI>[l4vmono, l4vcolor] 1bit$B!&%b%N%/%m%0%i%U%#%C%/$G%^%9%/=hM}$r9T$J$&>l9g!"(B
+      $B2?$b$G$J$$$3$H$,$"$k%P%0$N=$@5(B
+  <LI>[l4vmono, l4vcolor] $B@~$NB@$5$,(B 720 dpi $B$rA[Dj$7$FIA$+$l$F$$$?$N$G(B
+      600 dpi $B$G(B 1.2 $BG\$NB@$5$K$J$C$F$7$^$&%P%0$r=$@5!#$=$NB>$N2rA|EY$K$bBP1~(B
+  <LI>[l4vmono, l4vcolor] 600dpi $B0J30$GE@@~$,$*$+$7$$%P%0$r=$@5(B
+  <LI>[l4vmono, l4vcolor] $B6k7A$r8zN(NI$/IA$1$k$h$&$K$7$?!#(B
+</UL>
+
+<H3>gdevlips4-19980822 (release 16)</H3>
+<UL>
+  <LI>$B%0%l!<%9%1!<%k$N2hA|$r4^$s$@(B PostScript $B%U%!%$%k$G2hA|$,Gr9uH?E>$7$F$7$^$&(B
+$BLdBj$N2r7h(B
+  <LI>TeX $B$G(B EPS $B$r4^$s$@(B DVI $B%U%!%$%k$r%I%i%U%H=PNO$7$?$H$-$KIA$+$l$k6k7A$,(B
+$B$*$+$7$/$J$k(B LIPS IV $B$N;EMM$r2sHr$7$FLdBj$r2r7h(B
+</UL>
+
+<H3>gdevlips4-19980821 (release 15)</H3>
+<UL>
+  <LI>[l4vmono l4vcolor] $B1_$J$I$r@5>o$K%Q%?!<%s%U%#%k$G$-$J$$LdBj$N2r7h!#(B
+lips4v_copy_mono $B$H(B lips4v_copy_color $B4X?t$K%P%0$,$"$C$?!#(B
+  <LI>[l4vmono l4vcolor] $B@~$NB@$5$,HyL/$KB@$/$J$C$F$7$^$&$3$H$,$"$kLdBj$N2r7h(B
+</UL>
+
+<H3>gdevlips4-19980729 (release 14)</H3>
+<UL>
+  <LI>-sOutputFile=foo%d.xyz
+      $B$N7A<0$G=PNO%U%!%$%k$r;XDj$7$?>l9g$K%3%"%@%s%W$9$k%P%0$N2r7h(B
+  <LI>gdevlips4-19980707 $B$NJQ99$G(B lips4cfig$B!"(Blips4fig $B$,=PNO$G$-$J$/$J$C$?(B
+      $B%P%0$N2r7h(B
+  <LI>[l4vmono$B!"(Bl4vcolor] pswrite $BEy$N%G%P%$%9$,AH$_9~$^$l$F$$$J$$$H(B
+      $B%3%s%Q%$%k$G$-$J$$LdBj$N2r7h(B
+  <LI>[l4vmono$B!"(Bl4vcolor] $BJ8;z$N%^%9%/=hM}$,$*$+$7$$LdBj$N2r7h(B
+</UL>
+
+<H3>gdevlips4-19980716 (release 13)</H3>
+<UL>
+  <LI>gdevlips4-19980707 $B$G(B gdevlips.mak $B$,$*$+$7$$$?$a$K%3%s%Q%$%k$G$-$J$$(B
+      $BIT6q9g$r=$@5$7$?!#(B
+</UL>
+
+<H3>gdevlips4-19980707 (release 12)</H3>
+<UL>
+  <LI>LIPS IV $B$G(B High-level drawing $B$H(B High-level bitmap imaging
+      $B$r9T$J$&%Y%/%?!<%G%P%$%9(B $B$G$"$k(B l4vmono l4vcolor $B%G%P%$%9$rDI2C$7$?!#(B
+</UL>
+
+<H3>gdevlips4-19980704 (release 11)</H3>
+<UL>
+  <LI>lips4c$B!"(Blips4$B!"(Blips4g$B!"(Blips4cfig$B!"(Blips4fig $B%G%P%$%9$K$*$$$F!"(B $B@5>o(B
+      $B$K=PNO$G$-$J$$%P%0$,$"$C$?!#(B($BJ8K!4V0c$$!#(B)
+</UL>
+
+<H3>gdevlips4-19980623 (release 10)</H3>
+<UL>
+  <LI>lips4* $B%G%P%$%9$N05=LJ}K!$r%G%k%?05=L$KJQ99$7$?!#Nc30E*$K(Blips4.dev $B$G$N(B
+  tiger.ps $B$N05=LN($ONI$/$J$$$,!"$[$H$s$I$N>l9g0JA0$N%I%i%$%P$h$j$b(B
+  $B05=LN($,9b$/$J$k!#(B
+  <LI>lips4* $B%G%P%$%9$G(B gdevepag Ver. 3 $B$N$h$&$K(B -dcRowBuf $B%*%W%7%g%s$G(B
+  $B%i%9%?!<%$%a!<%8$rJ,3d$9$k$h$&$K$7$?!#$3$l$K$h$j!"(Blips4c$B!"(Blips4cfig $B$N(B
+  $B%i%9%?!<%$%a!<%8$r$^$H$a$FAw$l$k$h$&$K$J$C$?!#(B
+  <LI>lips4* $B%G%P%$%9$G$bHs05=L(B(-dCompress=false)$B$,;H$($k$h$&$K$J$C$?!#(B
+  ($B<g$K%G%P%C%0MQ(B)
+  <LI>$BG[I[>r7o$,(B GPL Ver.2 $B$K$J$C$?!#(B
+</UL>
+
+<H3>gdevlips4-19980612 (release 9)</H3>
+<UL>
+  <LI>lips2p $B%G%P%$%9$G(B LIPS II+ $B$KBP1~(B
+  <LI>lbp2030 $B%G%P%$%9$r(B lips4c $B%G%P%$%9$KE}9g(B
+      (600 dpi $B$G=PNO$9$k$H$-$O!"(B-r600 $B%*%W%7%g%s$r$D$1$k$3$H(B)
+  <LI>lips4g $B%G%P%$%9$G(B LIPS IV $B$N%0%l!<%9%1!<%k(B(8 bit = 256 $B3,D4(B)$B$KBP1~(B
+  <LI>$B%U%!%$%kL>$r(B 8.3 $B7A<0$KJQ99(B
+    <UL>
+      <LI>gdevlips4.c $B"*(B gdevlips.c
+      <LI>gdevlips4.h $B"*(B gdevlips.h
+    </UL>
+</UL>
+
+<H3>gdevlips4-19980429 (release 8)</H3>
+<UL>
+  <LI>lips3fig $B%G%P%$%9$,%3%"%@%s%W$9$kLdBj$N2r7h(B
+  <LI>lips3 $B%G%P%$%9$G05=L!&Hs05=L$r(B-dCompress$B%*%W%7%g%s$G@ZBX$($i$l$k$h$&$K$7$?!#(B
+</UL>
+
+<H3>gdevlips4-19980413 (release 7)</H3>
+<UL>
+  <LI>$BIUB0$N(Bgs_statd.ps$B$r;H$&$H(BGhostscript$B$,%$%s%?%i%/%F%#%V%b!<%I$G(B
+      $B5/F0$G$-$J$$%P%0$r=$@5(B($B@P4]$5$s$+$i$NJs9p(B)$B!#(B
+      -sPAPERSIZE=executive $B%*%W%7%g%s$O;HMQ$G$-$J$/$J$k(B
+  <LI>lbp2030 $B$G%G%U%)%k%H$,(B 360 dpi $B$K$J$C$F$$$?$N$r(B 600 dpi $B$K=$@5(B
+  <LI>lips4c$B!"(Blips4cfig $B$G%i%9%?!<%$%a!<%8$N05=L$r%5%]!<%H(B
+      ($B$H$$$&$h$j$b(Blbp2030$B$H$N%3!<%I$N6&DL2=(B)
+  <LI>$BN>LL0u:~$G$H$80LCV$rJQ99$G$-$k$h$&$K$J$C$?!#(B
+      (-dFlipBinding$B%*%W%7%g%s(B)
+  <LI>$BMQ;f%5%$%:$KESCf$N%Z!<%8$GJQ99$,$J$$>l9g$O!"(B
+      $B%Z!<%8!&%U%)!<%^%C%HA*BrL?Na$O0l2s$@$1H/9T$9$k$h$&$K$7$?!#(B
+      $B$3$l$O3F%Z!<%8$4$H$K%Z!<%8!&%U%)!<%^%C%HA*BrL?Na$rH/9T$9$k$H(B
+      $B0u;z8zN($,Dc2<$9$k$?$a$G$"$k(B
+  <LI>$B>e5-$HF1MM$KN>LL0u:~L?Na!&5k;f%b!<%IL?Na$bESCf$GJQ99$,$J$$>l9g$O!"(B
+      $B0l2s$NH/9T$7$+9T$J$o$J$$$h$&$K$7$?!#(B
+</UL>
+
+<H3>gdevlips4-19980403 (release 6)</H3>
+<UL>
+  <LI>LIPS IV $B$N05=LJ}<0$r%P%$%H%i%s%l%s%0%905=LK!$+$i%Q%C%/%S%C%D(B
+      (TIFF)$B05=LK!$KJQ99$7$?$?$a05=LN($,>e$,$j!";HMQ%a%b%j!<NL$,(B
+      $B8:$C$?!#(B
+      $B$3$l$O0KF#>M@2$5$s$,(Bfj$B$KEj9F$7$?(B<A HREF="news:605qpt$f50$1@kuma.fastnet.or.jp">gdevlips4-1.2.0$B$X$N%Q%C%A(B</A>&lt;605qpt$f50$1@kuma.fastnet.or.jp&gt;$B$+$i(B
+      $B%^!<%8$7$?!#(B
+  <LI>$B%W%j%s%?$N%9%F!<%?%9I=<(It$KI=<($9$k%3%a%s%H$rF0E*$KJQ99$9$k$3$H$,(B
+      $B$G$-$k$h$&$K$J$C$?!#(B
+  <LI>$B%b%N%/%m0u:~$K$*$$$F%S%C%H%^%C%W%9%`!<%8%s%0=hM}$r(BON/OFF$B$G$-$k$h$&$K$J$C$?!#(B
+  <LI>$B%+%i!<0u:~$K$*$$$F9b@::Y%$%a!<%8=hM}$r(BON/OFF$B$G$-$k$h$&$K$J$C$?!#(B
+</UL>
+
+
+<H3>gdevlips4-19980401-2 (release 5)</H3>
+<UL>
+  <LI>$BN>LL0u:~$N@_Dj$K$D$$$F%G%U%)%k%H$G$O%W%j%s%?B&$N@_Dj$r;H$&$h$&$K$7$?!#(B
+</UL>
+
+<H3>gdevlips4-19980401 (release 4)</H3>
+<UL>
+  <LI>$B5k;f%+%;%C%H$NA*Br$KBP1~$7$?!#(B 
+  <LI>$BN>LL0u:~$K40A4BP1~$7$?!#(B
+</UL>
+
+<H3>gdevlips4-19980331-2 (release 3)</H3>
+<UL>
+  <LI>$B8x3+;~$K(BDEFAULT_HEIGHT_10THS_A4$B$N$H$3$m$K(BDEFAULT_WIDTH_10THS_A4$B$r$$$l$F(B
+      $B$7$^$C$?$?$a%G%U%)%k%H%5%$%:$,(BA4$B2#(BxA4$B2#$K$J$k$H$$$&CWL?E*$J%P%0$,$"$C$?!#(B
+  <LI>$BG$0U$NMQ;f%5%$%:$N;XDj$K%P%0$,$"$C$?!#(B
+</UL>
+
+<H3>gdevlips4-19980331 (release 2)</H3>
+<UL>
+  <LI>60dpi$B$h$jAF$$%5%$%:$r=hM}$G$-$J$$$h$&$K$7$?!#(B(LIPS$B$N5,3J$N$?$a(B)
+  <LI>lips3$B$G$O(B300dpi$B!"(Blips4c$B$G$O(B360dpi$B!"(Blips4$B$H(Blbp2030$B$G$O(B600dpi$B$h$j:Y$+$$(B
+      $B%5%$%:$r=hM}$G$-$J$$$h$&$K$7$?!#(B(LIPS$B$N5,3J$N$?$a(B)
+  <LI>$BIuE{$NMN7A(B4$B9f%5%$%:$,$*$+$7$+$C$?$N$GD>$7$?!#(B
+  <LI>$B=$@5$7$?(B gs_stad.ps $B$rImB0$7$?!#(B
+</UL>
+
+<H3>gdevlips4-19980330 (release 1)</H3>
+<UL>
+  <LI>lips3, lips4, lips4c, lbp2030
+      <UL>
+	<LI>$B>e%^!<%8%s$,(B 63/300 inch ($BLs(B10.3 mm)$B$G$"$C$?$N$r(B 5 mm (lips4c $B$O(B 8 mm)
+	    $B$K$7$?!#(B
+	<LI>$B%Z!<%8%5%$%:JQ99$K40A4BP1~$7$?!#(B
+	<LI>$B%H%l%$5k;f$H<+F05k;f$N@ZBX$($KBP1~$7$?!#(B
+	<LI>$BJ#?tIt0u:~$KBP1~$7$?!#(B
+      </UL>
+  <LI>lips4
+      <UL>
+	<LI>$B%i%9%?!<%$%a!<%8$N05=L$KBP1~$7$?!#(B
+	<LI>$BN>LL0u:~%f%K%C%H$KBP1~$7$?!#(B
+      </UL>
+  <LI>lips3
+      <UL>
+	<LI>$B%i%9%?!<%$%a!<%8$N05=L$KBP1~$7$?!#(B
+      </UL>
+</UL>
+<HR>
+<H2><A HREF="#i_hireso" NAME="hireso">LIPS IV $B=PNO$K$*$1$k9b2rA|EY0u;z$K4X$9$kCm0U(B</A></H2>
+<P>
+600dpi $B0u;z$d(B 1200dpi $B0u;z$r9T$&>l9g$O(B, $B%W%j%s%?$KEk:\$5$l$F$$$kFbB"(B
+$B%a%b%j$NMFNL$KCm0U$7$F2<$5$$!#(B
+</P>
+<P>
+$B$3$l$OFbB"%a%b%j$NMFNL$,>/$J$$>l9g$K!"(B
+$B%W%j%s%?$,%G!<%?NL$NB?$5$KBP1~$G$-$:<+F0E*$K2rA|EY$rMn$7$F0u;z$5$;$k$+$i$G$9(B
+($B0u;z%G!<%?$K0MB8$9$k$N$G0l35$K$O8@$($^$;$s(B)$B!#(B
+$B$3$N=hM}$,9T$o$l$k$H(B, $B0u;z2rA|EY$,JQ$o$kB>$K(B 2 $BE@$N%G%a%j%C%H$,$"$j$^$9!#(B
+<UL>
+  <LI>$B0u;z$K;~4V$,$+$+$k$3$H$,B?$$(B($BFbIt=hM}$r(B 2 $BEY9T$C$F$$$k(B?)
+  <LI>$B%i%9%?%G!<%?$r0u;z$9$k>l9g$OC1=c$K4V0z$/$h$&$G!"(B
+      $B%0%l!<$NItJ,$,Gr$C$]$/(B/$B9u$C$]$/$J$C$?$j$J$I$7$F=jK>$N0u;z$,F@$i$l$J$$$3$H$,$"$k(B
+</UL>
+<P>
+$B$3$l$i$rHr$1$k$?$a$K$b!"Ek:\%a%b%j$K8+9g$C$?2rA|EY$G$N0u;z$r$*4+$a$7$^$9!#(B
+$B9b2rA|EY$G0u;z$r9T$&$?$a$KI,MW$J%a%b%jMFNL$O!"(B
+$B!V%W%j%s%?5!G=%^%K%e%"%k!W$X(B `$B0u;zJ]>Z%a%b%j(B' $B$H$7$F=q$+$l$F$$$^$9!#(B
+$B=PNOMQ;f%5%$%:$dN>LL0u;z$NM-L5$K$h$C$FJQ2=$9$kE@$bCm0U$7$F2<$5$$!#(B
+</P>
+<HR>
+<H2><A HREF="#i_bug" NAME="bug">$B%P%0(B</A></H2>
+<P>
+$B$3$3$K%j%9%H$5$l$F$$$k%P%0$O:n<T$,GD0.$7$F$$$k%P%0$G$9!#(B
+$B$3$l0J30$N%P%0$,$J$$$H$$$&0UL#$G$O$J$$$N$GCm0U$7$F2<$5$$!#(B
+</P>
+<P>
+$B$3$3$K%j%9%H$5$l$F$$$k0J30$G%P%0$rH/8+$7$^$7$?$i(B
+<A HREF="mailto:ohmori@p.chiba-u.ac.jp">$B:n<T(B</A>$B$^$GJs9p$r$*4j$$$7$^$9!#(B
+</P>
+<H3>[npdl.dev]</H3>
+<H4><A HREF="#i_marginbug" NAME="marginbug">1. $B0u:~0LCV$,$:$l$k(B</A></H4>
+<P>
+$B@)8f8@8l(B NPDL $B$G$O=PNO0LCV$N@_Dj$,5!<o0MB8$K$J$C$F$$$^$9!#(B
+$B5!<o$K$h$C$F0u:~2DG=HO0O$,0[$J$k$N$G0u:~0LCV$,$:$l$F$7$^$$$^$9!#(B
+<A HREF="#offset">$B0u:~0LCV$rD4@0$9$k$K$O$I$&$7$?$i$$$$$G$9$+(B?</A>
+$B$r;29M$K$7$FD4@0$9$k$+!"%=!<%9%U%!%$%k$rD>@\$$$8$C$FD>$7$F$/$@$5$$!#(B
+</P>
+<HR>
+<H4><A HREF="#i_nonduplex" NAME="nonduplex">2. $BJRLL0u:~$dN>LL0u:~;~$KC;JU$H$8$G0u:~$G$-$J$$(B</A></H4>
+<P>
+NPDL $BMQ$N%I%i%$%P$G$O8=:_$N$H$3$mJRLL0u:~$O$G$-$^$;$s!#(B
+$B$3$l$O(B NPDL $B$N;EMM=q$KJRLL0u:~$9$k$?$a$N%3%^%s%I$,5-:\$5$l$F$$$J$$$3$H$H!";d$,N>LL0u:~$G$-$k(B NPDL $BEk:\%W%j%s%?$,;H$($k4D6-$K$J$$$?$a$G$9!#(B
+$BF1MM$NM}M3$GN>LL0u:~;~$KC;JU$H$8$G0u:~$G$-$^$;$s!#(B
+</P>
+<P>
+$BN>LL0u:~$G$-$k(B NEC MultiWriter (NPDL(Level2) $BEk:\%W%j%s%?(B) $B$r$*;}$A$N$+$?$O(B
+$BN>LL0u:~$r@)8f$9$k%3%^%s%I(B($BJRLL0u:~%3%^%s%I$dC;JU$H$8$K$9$k%3%^%s%I(B)$B$r65$($F$$$?$@$1$k$H$3$N%I%i%$%P$KAH$_9~$`$3$H$,$G$-$^$9!#8f6(NO$h$m$7$/$*4j$$$7$^$9!#(B
+</P>
+<HR>
+<H3>[bjc880j.dev]</H3>
+<H4><A HREF="#i_landbug" NAME="landbug">1. $B%i%s%I%9%1!<%W2sE>;~$K0u:~0LCV$,$A$g$C$H$:$l$k(B</A></H4>
+<P>
+$BB>$N(B LIPS $B$N%I%i%$%P$G$O>e2<:81&$N%^!<%8%s$,6Q0l$J$N$G%i%s%I%9%1!<%W$O(B
+$B$=$N$^$^2sE>$7$F$d$l$P0u:~0LCV$,$"$$$^$9$,!"(B
+BJC-680J$B!"(BBJC-880J $B$G$O%^!<%8%s$,0c$&$N$G>/$7$:$l$F$7$^$$$^$9!#(B
+$B2sE>;~$K87L)$K0LCV$r7W;;$9$l$P$:$l$J$$(B?
+</P>
+<HR>
+<H3>[lips4v.dev]</H3>
+<H4><A HREF="#i_clipping" NAME="clipping">1. $B%Q%9$N%/%j%C%T%s%0=hM};~$N%a%b%jITB-(B ($B%7%9%F%`%a%b%j%U%k(B $B%(%i!<(B)</A></H4>
+<P>
+$B6k7A0J30$N%Q%9$GB?>/J#;($J%/%j%C%T%s%0=hM}$7$?$@$1$G%W%j%s%?$,%a%b%jITB-$K4Y$k!#(B
+$BNc$($P(B Tgif $B$G1_$r%Q%?!<%s%U%#%k$7$F=PNO$7$?(B PostScript $B%U%!%$%k$G$3$N8=>]$,$_$i$l$k!#(B
+</P>
+<P>
+$B$3$l$O(B Ghostsciprt 5.10 $B$,=PNO$9$k%/%j%C%T%s%0%Q%9$,8zN(0-$$$3$H$H!"(B
+LIPS IV $B$N%Q%9%/%j%C%T%s%0=hM}$,%a%b%j!<$r?)$$2a$.$k$?$a$K5/$3$j$^$9!#(B
+</P>
+<P>
+$B"($3$N%P%0$O(B Ghostscript 5.50 $B$G$O%Q%9$N%/%j%C%T%s%0=hM}$,8zN($h$/$J$C$?$?$a$KB?>/$^$7$K$J$C$F$$$^$9!#(B
+$B$^$?!"%-%d%N%s$K$h$k$H(B MaxiMem $BEk:\5!$G$O%/%j%C%T%s%0$K4X$9$k%a%b%j!<8zN($bNI$/$J$C$F$$$k$=$&$J$N$G$3$NLdBj$O2r7h$5$l$F$$$k$+$b$7$l$^$;$s!#(B($BL$3NG'(B)
+</P>
+<HR>
+<H4><A HREF="#i_zeroline" NAME="zeroline">2. $BI}$,%<%m$N%Q%9$r%U%#%k$7$?$H$-2?$bIA$+$l$J$$(B</A></H4>
+<P>
+PostScript $B$G$OI}$,%<%m$N%Q%9$r%U%#%k$7$?$H$-$bIA$+$l$J$1$l$P$J$i$J$$$,!"IA$+$l$J$$!#(B
+</P>
+<P>
+LIPS IV $B$G$OIA$+$l$J$$;EMM$G$9!#(B
+</P>
+<P>
+$B"((BGhostscript $B$KImB0$N(B zeroline.ps $B$r0u:~$9$k$H$3$N%P%0$,J,$+$j$^$9!#(B
+</P>
+<HR>
+<H4><A HREF="#i_zeromove" NAME="zeromove">3. $B0\F05wN%(B 0 $B$N%Q%9$N07$$(B</A></H4>
+<P>
+$B0\F05wN%(B 0 $B$N%Q%9$r%9%H%m!<%/$7$?;~!"(Bsetlinejoin $B$,(B 1 (Round join)
+$B$N$H$-$J$K$bIA$+$l$J$$!#(B
+</P>
+<P>
+PostScript $B$G$O$3$N$H$-1_$,IA$+$l$J$1$l$P$J$j$^$;$s$,!"(BLIPS IV $B$G$O(B
+$BIA$+$l$J$$;EMM$K$J$C$F$$$^$9!#(B
+</P>
+<P>
+$B"((BGhostscript $B$KImB0$N(B zeroline.ps $B$r0u:~$9$k$H$3$N%P%0$,J,$+$j$^$9!#(B
+</P>
+<HR>
+<H4><A HREF="#i_square_cap" NAME="square_cap">4. Projecting square cap $B$N%P%0(B</A></H4>
+<P>
+$B@~$N@\9gIt$G!"(Bsetlinecap $B$G(B 2 (Projecting square cap) $B$r;XDj$7$?;~!"%Q%9$r%/%m!<%:(B
+$B$7$?ItJ,$N@~@\9g$,$&$^$/$$$+$J$$!#$^$?!"%/%m!<%:$9$k:BI8$,%Q%9$N86E@$+$i(B
+$B0z$-?-$P$7$?J}8~$K$:$l$k!#(B
+</P>
+<P>
+LIPS IV $B$N%P%0$G$9!#(B
+</P>
+<P>
+$B"((BGhostscript $B$KImB0$N(B lines.ps $B$r0u:~$9$k$H$3$N%P%0$,J,$+$j$^$9!#(B
+</P>
+<HR>
+<H4><A HREF="#i_round_cap" NAME="round_cap">5. Round cap $B$N%P%0(B</A></H4>
+<P>
+$B@~$N@\9gIt$G(Bsetlinecap $B$G(B 1 (Round cap) $B$r;XDj$7$F!"(Bsetlinejoin $B$G(B 2 (Bevel join)$B$r;XDj$7$?$H$-!"(B
+$B%Q%9$r%/%m!<%:$7$?ItJ,$N@~@\9g$O(B $B!V%Y%Y%k(B($B@Z$jMn$H$7(B)$B!W(B $B$K$J$i$J$1$l$P$$$1$J$$$H$3$m!V4]!W$K$J$C$F$7$^$&!#(B
+</P>
+<P>
+LIPS IV $B$N%P%0$G$9!#(B
+</P>
+<P>
+$B"((BGhostscript $B$KImB0$N(B lines.ps $B$r0u:~$9$k$H$3$N%P%0$,J,$+$j$^$9!#(B
+</P>
+<HR>
+<H4><A HREF="#i_linewidth" NAME="linewidth">6. $B@~$NB@$5$,0c$&(B</A></H4>
+<P>
+LIPS IV $B$N@)8B$G@~$NB@$5$N>e8B$O(B 0.85 $B%$%s%A$H$J$C$F$$$^$9!#(B
+PostScript $B$K$O$=$N$h$&$J@)8B$,$J$$$N$G!"6KC<$KB@$$@~$rIA$/$H$-$K(B
+$B=PNO$N0c$$$,=P$F$7$^$$$^$9!#(B
+</P>
+<P>
+$B$^$?!"(BGhostscript $B$N(B $B%Y%/%?!<%I%i%$%P$N%P%0$K$h$j=D2#$N%9%1!<%k$,0[$J$k>l9g!"(B
+$B@~$NB@$5$,0c$C$F$-$F$7$^$$$9!#(B
+</P>
+<P>
+rectstroke $B%*%Z%l!<%?$r;H$C$?>l9g$G=D$H2#$NB@$5$,0c$&>l9g$b@5>o$KIA$+$l$^$;$s!#(B($B=D$H2#$NB@$5$,F1$8$K$J$C$F$7$^$$$^$9!#(B)
+</P>
+<HR>
+<H4><A HREF="#i_setdash" NAME="setdash">7. $BGK@~$N%Q%?!<%s$,IA$+$l$J$$(B</A></H4>
+<P>
+$BGK@~$N%Q%?!<%s$K(B 0 $B$,4^$^$l$F$$$k>l9g!"$3$N%I%i%$%P$G$OIA$+$l$^$;$s!#(B
+</P>
+<P>
+$BGK@~$N%Q%?!<%s$K(B 0 $B$,4^$^$l$F$$$k>l9g$N%*%Z%l!<%?$N5sF0$O$I$&$J$C$F$$$k$N$+(B
+Red Book $B$K=q$$$F$J$$$N$G;d$K$OJ,$+$j$^$;$s!#C/$+65$($F2<$5$$!#(B
+</P>
+<HR>
+<H4><A HREF="#i_pattern" NAME="pattern">8. lips4v $B%I%i%$%P$G%0%l!<%9%1!<%k=PNO$9$k$H$-$K%+%i!<%Q%?!<%s$rIA$$$?>l9g?'$,$*$+$7$$$3$H$,$"$k(B</A></H4>
+<P>
+$BB?J,!"(BGhostscript $B$N%P%0$G$9!#%+%i!<=PNO(B (-dBitsPerPixel=24) $B$G$O$3$N%P%0$O8+$i$l$^$;$s!#(B
+</P>
+<HR>
+<H2><A HREF="#i_faq" NAME="faq">FAQ</A></H2>
+<H3><A HREF="#i_slow" NAME="slow">$B%W%j%s%?$N=PNO$OB.$/$J$i$J$$$N(B?</A></H3>
+<P>
+LIPS IV $B5!$N>l9g(B -r300 $B%*%W%7%g%s$r$D$1$F2rA|EY$r(B 300 dpi ($B%/%$%C%/(B)
+$B$K$9$k$HB.$/$J$j$^$9!#(B($BEvA32h<A$OMn$A$^$9(B)
+</P>
+<P>
+LIPS IV $B5!$G(B 600 dpi $B0u:~$9$k>l9g$O(B lips4 $B%I%i%$%P$rMQ$$$k$N$,NI$$$G$7$g$&!#(B
+lips4v $B%I%i%$%P$r;H$C$F$bB.EYE*$J%a%j%C%H$O$"$j$^$;$s!#(B
+</P>
+<P>
+LIPS IV $B5!$G(B 1,200 dpi $B0u:~$9$k>l9g$O(B lips4v.dev $B$r;H$C$?$[$&$,(B
+$BB.$$$+$b$7$l$^$;$s$,!";d$O;H$C$?$3$H$J$$$N$GJ,$+$j$^$;$s!#(B
+</P>
+<P>
+Color LASER SHOT $B$G%+%i!<0u:~$9$k>l9g$O(B lips4.dev $B$G$J$/(B
+lips4v.dev $B$r;H$C$?J}$,9bB.$K=PNO$G$-$^$9!#(B
+($B$7$+$7!"%Y%/%?!<HG%I%i%$%P$O@)8B$,B?$$$N$GCm0U$7$F$/$@$5$$!#(B)
+</P>
+<HR>
+<H3><A HREF="#i_font" NAME="font">$B%W%j%s%?$NFbB"%U%)%s%H$O;H$($J$$$N(B?</A></H3>
+<P>
+$B;H$($^$;$s!#(B
+</P>
+<HR>
+<H3><A HREF="#i_nup_printing" NAME="nup_printing">n $BLL0u:~$r$9$k$K$O!"$I$&$7$?$i$$$$$N(B?</A></H3>
+<P>
+PSUtils $B$H$$$&%=%U%H%&%'%"$K4^$^$l$k(B psnup $B$rMQ$$$^$9!#(B
+PSUtils $B$O(B PostScript $B%U%!%$%k$NCf$+$iFCDj$N%Z!<%8$rCj=P$7$?$j!"(B
+$B%Z!<%8$NJB$S$rJQ99$7$?$j$G$-$k%3%^%s%I72$G$9!#(B
+</P>
+<P>
+PSUtils $B$O<!$N$H$3$m$+$iF@$i$l$^$9!#(B
+<UL>
+  <LI><A HREF="http://www.dcs.ed.ac.uk/home/ajcd/psutils/">&lt;URI:http://www.dcs.ed.ac.uk/home/ajcd/psutils/&gt;</A>
+</UL>
+<P>
+psnup $B$O<!$N$h$&$K;H$$$^$9!#$h$j>\$7$$$3$H$O%^%K%e%"%k$rFI$s$G2<$5$$!#(B
+</P>
+<DL>
+  <DT><KBD>psnup -2 [<VAR>infile</VAR>[<VAR>outfile</VAR>]]</KBD></DT>
+  <DD>2 $B%Z!<%8$r(B 1 $B%Z!<%8$K$^$H$a$F0u:~$7$^$9(B</DD>
+  <DT><KBD>psnup -4 [<VAR>infile</VAR>[<VAR>outfile</VAR>]]</KBD></DT>
+  <DD>4 $B%Z!<%8$r(B 1 $B%Z!<%8$K$^$H$a$F0u:~$7$^$9(B</DD>
+  <DT><KBD>psnup -8 [<VAR>infile</VAR>[<VAR>outfile</VAR>]]</KBD></DT>
+  <DD>8 $B%Z!<%8$r(B 1 $B%Z!<%8$K$^$H$a$F0u:~$7$^$9(B</DD>
+</DL>
+<P>
+$B$?$@$7!"(Bpsnup $B$G$&$^$/$$$+$J$$(B PostScript $B%U%!%$%k$b$"$j$^$9!#(B
+$B$=$N$h$&$J>l9g$K(B LIPS IV $B$K8B$j!"(B<A HREF="#nup">-dNup $B%*%W%7%g%s(B</A>$B$K$h$j(B 2 $BLL0u:~$H(B 4 $BLL0u:~$,2DG=$G$9!#(B
+$B$7$+$7!"$3$l$OHs8x3+5!G=$r;H$C$F$$$?$j!"0u;zB.EY$,CY$$$H$$$&LdBj$,$"$j$^$9$N$G2DG=$J8B$j(B psnup $B$rMQ$$$^$7$g$&!#(B
+</P>
+<HR>
+<H3><A HREF="#i_psresize" NAME="psresize">$BMQ;f%5%$%:$N3HBg!"=L>.0u:~$r$9$k$K$O$I$&$9$k$s$G$9$+(B?</A></H3>
+<P>
+PSUtils $B$K4^$^$l$k%3%^%s%I(B psresize $B$rMQ$$$^$9!#(B
+</P>
+<P>
+PSUtils $B$O<!$N$H$3$m$+$iF@$i$l$^$9!#(B
+<UL>
+  <LI><A HREF="http://www.dcs.ed.ac.uk/home/ajcd/psutils/">&lt;URI:http://www.dcs.ed.ac.uk/home/ajcd/psutils/&gt;</A>
+</UL>
+<P>
+psresize $B$O(B A3$B!&(BA4$B!&(BA5$B!&%l%?!<!&%j!<%,%k$dG$0U$N%5%$%:$KBP1~$7$F$$$^$9!#(B
+$B2<5-$K$$$/$D$+;HMQNc$r5s$2$^$9!#$/$o$7$/$O%^%K%e%"%k$r;2>H$7$F2<$5$$!#(B
+</P>
+<DL>
+  <DT><KBD>psresize -q -PA4 -pletter <VAR>in.ps</VAR> &gt; <VAR>out.ps</VAR></KBD></DT>
+  <DD>A4 $B%5%$%:$r%l%?!<%5%$%:$K$7$^$9!#(B</DD>
+  <DT><KBD>psresize -q -PA3 -pA4 <VAR>in.ps</VAR> &gt; <VAR>out.ps</VAR></KBD></DT>
+  <DD>A3 $B%5%$%:$r(B A4 $B%5%$%:$K$7$^$9!#(B</DD>
+  <DT><KBD>psresize -q -W729 -H1032 -w516 -h729 <VAR>in.ps</VAR> &gt; <VAR>out.ps</VAR></KBD></DT>
+  <DD>B4 $B%5%$%:$r(B B5 $B%5%$%:$K$7$^$9!#(B</DD>
+</DL>
+<P>
+NPDL $BEk:\%W%j%s%?$NCf$K$O;XDj$5$l$?MQ;f$,%[%C%Q(B($B5k;f%+%;%C%H(B)$B$K$J$$>l9g$G!"(B
+$B=L>.0u:~2DG=$JMQ;f%5%$%:$O$"$k>l9g!"=L>.0u:~$5$l$k$b$N$b$"$j$^$9!#(B
+</P>
+<HR>
+<H3><A HREF="#i_offset" NAME="offset">$B0u:~0LCV$rD4@0$9$k$K$O$I$&$7$?$i$$$$$G$9$+(B?</A></H3>
+<P>
+$B0u:~0LCV$,$:$l$F$7$^$&>l9g$O!"<!$NJ}K!$N$&$A$I$l$+$rMQ$$$FD4@0$7$^$9!#(B
+$B$J$*!"(BGhostscript $B$N86E@$OMQ;f$N(B<EM>$B:8>e(B</EM>$B$G$9$N$G(B<EM>$B:8>e(B</EM>$B$+$i$N0u:~0LCV$,$"$&$h$&$KD4@0$7$F$/$@$5$$!#(B
+</P>
+<OL>
+  <LI>$B%W%j%s%?$N%Q%M%k@_Dj$N!V=DJd@5!W!V2#Jd@5!W$N5!G=$rMQ$$$k(B
+  <LI>Ghostscript $B$N(B PageOffset $B%*%Z%l!<%?$GD4@0$9$k!#(B
+</OL>
+<P>
+$B%W%j%s%?$N%Q%M%k@_Dj$N!V=DJd@5!W!V2#Jd@5!W$N5!G=$rMQ$$$k>l9g!"(BGhostscript $B$NB>$K0u:~$9$k%=%U%H%&%'%"$r;H$&$H$=$N%=%U%H%&%'%"$G$bJd@5$,8z$$$F$7$^$&$N$GCm0U$,I,MW$G$9!#(B
+</P>
+<P>
+Ghostscript $B$G0u:~0LCV$rJQ99$7$?$$>l9g$O!"%U%!%$%k(B /usr/local/etc/offset.ps $B$J$I$HL>A0$r$D$1$?%U%!%$%k$r:n$C$F<!$N$h$&$JFbMF$r5-=R$7$^$9!#(B
+</P>
+<PRE>
+&lt;&lt;
+/PageOffset [0.0 0.0]
+&gt;&gt; setpagedevice
+</PRE>
+<P>
+$B<!$K$3$N%U%!%$%k$N(B [0.0 0.0] $B$H$J$C$F$$$kItJ,$K$:$i$7$?$$D9$5$r5-=R$7$^$9!#(B
+$BC10L$O%]%$%s%H(B(1/72 inch$B!"Ls(B 0.35 mm)$B$G$9!#Nc$($P1&$K(B 3 mm$B!">e$K(B 1.5 mm
+$B0u:~0LCV$r$:$i$7$?$$>l9g$O!"(B
+<PRE>
+3.0 $B!_(B 25.4 $B!`(B 72 $B!a(B 8.5039...
+1.5 $B!_(B 25.4 $B!`(B 72 $B!a(B 4.2519...
+</PRE>
+$B$J$N$G!"(B
+<PRE>
+&lt;&lt;
+/PageOffset [8.5 -4.25]
+&gt;&gt; setpagedevice
+</PRE>
+$B$H5-=R$7$^$9!#(B
+</P>
+<P>
+$B$=$7$F!"(BGhostscript $B$r5/F0$9$k$?$S$K$3$N(B offset.ps $B$r8F$S=P$7$F2<$5$$!#(B
+$BNc$($P<!$N$h$&$K$7$^$9!#(B
+</P>
+<PRE>
+<KBD>gs -q -dSAFER -dNOPAUSE -sDEVICE=lips4 -sOutputFile=- offset.ps -</KBD>
+</PRE>
+<HR>
+<H3><A HREF="#i_bsize" NAME="bsize">B4 $B$^$?$O(B B5 $B%5%$%:$NMQ;f;XDj$,$&$^$/$$$+$J$$$s$@$1$I(B</A></H3>
+<P>
+<A HREF="#install">$B%$%s%9%H!<%k(B</A>$B$N$H$3$m$G=R$Y$i$l$F$$$k$h$&$K!"(Bgs_statd.ps $B$K%Q%C%A$r$"$F$F2<$5$$!#(B
+Ghostscript $BI8=`$N(B B$B%5%$%:$O(B <EM>ISO</EM>$B$N(BB$B%5%$%:$G$"$C$F(B <EM>JIS</EM>$B$N(BB$B%5%$%:$G$O$"$j$^$;$s!#(B
+</P>
+<HR>
+<H3><A HREF="#i_vector" NAME="vector">$B%i%9%?!<HG%G%P%$%9$H%Y%/%?!<HG%G%P%$%9$N0c$$$O(B?</A></H3>
+<P>
+$B%i%9%?!<HG%G%P%$%9$O(B Ghostscript $B$,:n$k!"%Z!<%8$H$[$\F1$8Bg$-$5$N(B1$BKg$N%S%C%H%^%C%W$r0u:~$9$k%G%P%$%9$G$9!#(B
+LIPS $B$NL?Na$H$7$F$O<g$K%i%9%?!<!&%$%a!<%8IA2hL?Na$7$+;H$C$F$$$^$;$s!#(B
+$B$=$l$KBP$7$F%Y%/%?!<HG%G%P%$%9$O$h$j9b5!G=$J(B LIPS $B$NL?Na$r;H$C$F0u:~$9$k%G%P%$%9$G$9!#(B
+$B$=$l$>$l$KD9=j$HC;=j$,$"$k$N$G;H$$J,$1$F2<$5$$!#(B
+</P>
+<P>
+$B%Y%/%?!<HG%G%P%$%9$,(B LIPS $B$NL?Na$H$7$F;H$C$F$$$k$N$O<!$N$H$*$j$G$9!#(B
+</P>
+<UL>
+  <LI>$BIA2h>r7o@_Dj(B
+      <UL>
+	<LI>$B%/%j%C%T%s%0L?Na(B
+	<LI>$BIA2hO@M}@_DjL?Na(B
+      </UL>
+  <LI>$B?^7AIA2hB0@-@_Dj(B
+      <UL>
+	<LI>$B@~I};XDjL?Na(B
+	<LI>$B@~@\B3;XDjL?Na(B
+	<LI>$B%^%$%?!&%j%_%C%H;XDjL?Na(B
+	<LI>$B@hC<7A>u;XDjL?Na(B
+	<LI>$B%i%$%s!&%+%i!<;XDjL?Na(B
+	<LI>$BEI$j$D$V$7%+%i!<;XDjL?Na(B
+	<LI>$BB?3Q7AIA2h%b!<%I;XDjL?Na(B
+      </UL>
+  <LI>$B%Q%?!<%sEPO?(B
+      <UL>
+	<LI>$B@~%Q%?!<%sEPO?L?Na(B2
+      </UL>
+  <LI>$B?^7AIA2h(B
+      <UL>
+	<LI>$B6k7AIA2hL?Na(B
+	<LI>$BB?3Q7AIA2hL?Na(B2
+      </UL>
+  <LI>$B%$%a!<%8IA2h(B
+      <UL>
+	<LI>$B%$%a!<%8NN0h3NJ]L?Na(B1
+	<LI>$B%$%a!<%8NN0h3NJ]L?Na(B2
+	<LI>$BC1?'%$%a!<%8!&%+%i!<;XDjL?Na(B
+	<LI>$B%$%a!<%8IA2hL?Na(B
+      </UL>
+  <LI>$B%Q%99=C[(B
+      <UL>
+	<LI>$B%Q%99=C[3+;OL?Na(B
+	<LI>$B%Q%99=C[=*N;L?Na(B
+	<LI>$B%5%V%Q%93+;OL?Na(B
+	<LI>$B%Q%9!&%]%j%i%$%sL?Na(B
+	<LI>$B%Q%9!&%/%m!<%:L?Na(B
+      </UL>
+  <LI>$B%Q%9!&%W%l%$(B
+      <UL>
+	<LI>$B%Q%9!&%9%H%m!<%/L?Na(B
+	<LI>$B%Q%9!&%U%#%kL?Na(B
+	<LI>$B%Q%9!&%9%H%m!<%/!&%U%#%kL?Na(B
+	<LI>$B%Q%9!&%/%j%C%T%s%0L?Na(B
+	<LI>$B%Q%9J?3jEY;XDjL?Na(B
+      </UL>
+</UL>
+<P>
+$B>e5-$N$h$&$J5!G=$K$h$C$F%Y%/%?!<HG%G%P%$%9$O%i%9%?!<%G%P%$%9$HHf3S$9$k$H<!$N$h$&$JFCD'$,$"$j$^$9!#(B($BB?>/$NNc30$O$"$j$^$9!#(B)
+</P>
+<UL>
+  <LI>$B%W%j%s%?B&$NI,MW%a%b%jNL$,>/$J$/$F$9$`>l9g$,$"$k(B
+  <LI>$B05=L$r9T$J$C$F$$$J$$$K$b4X$o$i$:!"%G!<%?NL$,>.$5$$!#(B
+  <LI>$B0u:~;~4V$,C;=L$5$l$k>l9g$,$"$k!#FC$K(B lips4 $B$H(B lips4v $B$N%+%i!<=PNO$rHf3S$9$k$H05E]E*$J:9$,$G$k!#(B
+  <LI>$B0u;zNN0h$r%a%b%j$K3NJ]$7$J$/$F$$$$$N$G!"(B Ghostscript $B$N5/F0;~4V$,Hs>o$KC;$$!#$^$?(B Ghostscript $B<+BN$N;HMQ%a%b%jNL$b>/$J$$!#(B
+  <LI>$B%i%9%?!<HG%G%P%$%9$O0u:~B.EY$NN'B.CJ3,$,(B I/O $B$K$"$k$,!"(B
+      $B%Y%/%?!<HG$O%W%j%s%?FbIt$NIA2h%k!<%A%s$K$"$k$?$a!"(B
+      $B9bB.$J(B CPU $B$rEk:\$7$F$$$k%W%j%s%?$[$IB.$/$J$k!#(B
+</UL>
+<HR>
+<H3><A HREF="#i_l3vmono" NAME="l3vmono">LIPS IV $B0J30%I%i%$%P$N%Y%/%?!<HG$O:n$i$J$$$N(B?</A></H3>
+<P>
+$B:n$j$^$;$s!#$h$j@53N$K$$$&$H:n$l$^$;$s!#(B
+$B%Y%/%?!<HG%I%i%$%P$r:n$k$?$a$K$O(B PDL $B$,(B PostScript $B$K6a$$5!G=$r$b$C$F(B
+$B$$$J$1$l$P$$$1$^$;$s$,!"(BLIPS II+$B!"(BLIPS III$B!"(BLIPS IVc$B!"(BESC/Page$B!"(BNPDL
+$B$G$O5!G=$,B-$i$J$$$N$G:n$l$J$$$N$G$9!#(B
+</P>
+<HR>
+<H3><A HREF="#i_lbp2030" NAME="lbp2030">lbp2030.dev $B$O$I$3$$$C$?$N(B?</A></H3>
+<P>
+lbp2030.dev $B$O(B lips4.dev $B$N%+%i!<=PNO$H=PNO$9$kFbMF$,F1$8$K$J$C$?$N$GGQ;_$7$^$7$?!#(B
+$B$7$+$7$J$,$i!"(BColor LASER SHOT $B$G=PNO$9$k>l9g$O(B $B%Y%/%H%kHG%G%P%$%9$N(B lips4v.dev
+$B$G=PNO$9$k$[$&$,(B 10 $BG\0J>eB.$$$H;W$$$^$9!#(B
+</P>
+<HR>
+<H3><A HREF="#i_fig" NAME="fig">lips3fig$B!"(Blips4cfig$B!"(Blips4fig $B$,$J$$$s$@$1$I(B</A></H3>
+<P>
+*fig.dev $B$O(B dvipr $B$G$7$+MQ$$$i$l$^$;$s!#$^$?!"(Bdvipr $B<+BN$O$9$G$K;~BeCY$l$N(B
+$B%=%U%H%&%'%"$K$J$j$D$D$"$j$^$9!#(B
+$B$h$C$F%5%]!<%H$7$J$$$3$H$K$7$^$7$?!#(B
+</P>
+<HR>
+<H3><A HREF="#i_lips2p" NAME="lips2p">$B$I$&$7$F(B LIPS II+ $BBP1~%I%i%$%P$O(B lips2+ $B$d(B lips2plus $B$H$$$&L>A0$8$c$J$$$N(B?</A></H3>
+<P>
+Ghostscript $B$G$O%G%P%$%9$NL>A0$O(B1$B$+$i(B8$BJ8;z$H7h$^$C$F$$$^$9!#(B
+$B$^$?!"%"%s%@!<%9%3%"(B(_)$B0J30$N5-9f$O;H$($J$$$3$H$K$J$C$F$$$^$9!#(B
+</P>
+<HR>
+<H2><A HREF="#i_thanks" NAME="thanks">$B<U<-(B</A></H2>
+<P>
+$B0KF#>M@2;a$K$O05=L%k!<%A%sItJ,$NDs6!!"%9!<%Q!<%U%!%$%s(B LIPS $B$N%F%9%H$J$I$r<jEA$C$F$$$?$@$-$^$7$?!#(B
+$B$^$?!"(B<A HREF="#hireso">LIPS IV $B=PNO$K$*$1$k9b2rA|EY0u;z$K4X$9$kCm0U(B</A>$B$b0KF#;a$,=q$+$l$?J8=q$G$9!#(B
+</P>
+<P>
+$BFsLZ5*9T;a$K$O%W%m%0%i%_%s%0>e$NAjCL$K$N$C$F$$$?$@$-$^$7$?!#(B
+$B$^$?%Y%/%?!<HG%G%P%$%9$NIJ<A8~>e$K6(NO$7$F$$$?$@$-$^$7$?!#(B
+</P>
+<P>
+$B@.>>9(;a:n$N(B Ghostscript $B%I%i%$%P(B epag-3.08 $B$N%3!<%I$+$i=PNO%"%k%4%j%:%`ItJ,$HMQ;f%5%$%:7hDjItJ,$rMxMQ$5$;$F$$$?$@$-$^$7$?!#(B
+</P>
+<P>
+$BEOIt=$;a:n$N(B Ghostscript $B%I%i%$%P(B gdevnpdl-1.5 $B$N%3!<%I$r$b$H$K(B npdl $B%I%i%$%P$r:n@.$5$;$F$$$?$@$-$^$7$?!#(B
+</P>
+<P>
+$B:XF#1QIW;a$N(B Ghostscript $B%I%i%$%P(B gdevnpdl-1.5 $B$X$N(B $BN>LL0u:~BP1~%Q%C%A$rMxMQ$5$;$F$$$?$@$-$^$7$?!#(B
+</P>
+<P>
+$B$3$N%=%U%H%&%'%"$N2~A1$K4X$7$F!"0J2<$NJ}!9$+$i5.=E$J0U8+$r$$$?$@$-$^$7$?!#(B
+</P>
+<P>
+$BB@EDK'I'!"@P4]E/Li!";38}0lO:!"0KF#D>;K!"C]LnLP<#!"7'C+@5O/!";3Fb?N!"(B $B;{@n0&0u!";04d9,IW!"[X3@>-OB(B($B7I>NN,(B)
+</P>
+<HR>
+<H2><A HREF="#i_reference" NAME="reference">$B;29MJ88%(B</A></H2>
+<OL>
+  <LI>PostScript Language Reference Manual SECOUND EDITION, Adobe Systems Incorporated
+  <LI>LASER SHOT $B%W%m%0%i%^!<%:%^%K%e%"%k(B $B%=%U%H%&%'%"35@b=q(B 4.1, Canon
+  <LI>LASER SHOT $B%W%m%0%i%^!<%:%^%K%e%"%k(B $B%=%U%H%&%'%"35@b=q(B 4.2, Canon
+  <LI>LASER SHOT $B%W%m%0%i%^!<%:%^%K%e%"%k(B $B%3%^%s%I%j%U%!%l%s%9(B 4.1, Canon
+  <LI>LASER SHOT $B%W%m%0%i%^!<%:%^%K%e%"%k(B $B%3%^%s%I%j%U%!%l%s%9(B 4.2, Canon
+  <LI>LASER SHOT $B%W%m%0%i%^!<%:%^%K%e%"%k(B $B%/%C%/%V%C%/(B 4.1, Canon
+  <LI>LASER SHOT $B%W%m%0%i%^!<%:%^%K%e%"%k(B $B%/%C%/%V%C%/(B 4.2, Canon
+  <LI>ESC/Page $B%j%U%!%l%s%9%^%K%e%"%k(B $BBh(B4$BHG(B, EPSON
+  <LI>EPSON Remote $B%b!<%I(B(P) $B%j%U%!%l%s%9%^%K%e%"%k(B, EPSON
+  <LI>$BF|K\8l%Z!<%8%W%j%s%?8@8l(B NPDL(Level2) $B%j%U%!%l%s%9%^%K%e%"%k(B
+      (PC-PRNPDL2-RM Rev.02), NEC
+</OL>
+<HR>
+<P>
+<!-- hhmts start -->
+Last modified: Tue Jun 22 03:26:59 JST 1999
+<!-- hhmts end -->
+</P>
+<ADDRESS>
+$B@iMUBg3XLt3XItLtIJJ*M}2=3X8&5f<<(B $BBg?95*?M(B
+<A HREF="mailto:ohmori@p.chiba-u.ac.jp">&lt;URI:mailto:ohmori@p.chiba-u.ac.jp&gt;</A>
+</ADDRESS>
+</BODY>
+</HTML>
diff -urN -x .svn espgs-8.15rc2/addons/japanese/doc/gdevmag.txt trunk/addons/japanese/doc/gdevmag.txt
--- espgs-8.15rc2/addons/japanese/doc/gdevmag.txt	1970-01-01 01:00:00.000000000 +0100
+++ trunk/addons/japanese/doc/gdevmag.txt	2005-03-14 00:03:52.025771812 +0100
@@ -0,0 +1,40 @@
+■                                                                    ■
+■                 鮪フォーマットドライバ version 1.0                 ■
+■                    Copyright (C) 1994 淺山和典                     ■
+■                                                                    ■
+
+========================================================================
+● １． 概要
+========================================================================
+
+まぐろーだー (.mag) フォーマットの画像データを出力するためのドライバです。
+16 色と 256 色に対応しています。
+
+========================================================================
+● ２． 組み込み
+========================================================================
+
+gdevmag.c を他のソースプログラムと同じディレクトリに置き、Makefile の
+DEVICE_DEVS (または、DEVICE_DEVS1〜9) に mag16.dev (16 色)、
+mag256.dev(256 色) を追加し、Makefile に gdevmag.mak の内容を追加して
+make を実行してください。
+
+========================================================================
+● ３． 使い方
+========================================================================
+
+BMP や PCX などの他の画像フォーマットドライバと同様です。gs を起動すると
+きに -sDEVICE=mag16、-sDEVICE=mag256 というオプションを付けてください。
+
+  (例) gs -dNOPAUSE -sDEVICE=mag16 -sOutputFile=golfer.mag -- golfer.ps
+
+    ※一つの *.mag ファイルには一つの画像しか含めることが出来ませんから、
+      複数ページから成る PostScirpt コードを鮪形式に変換する場合には
+      -sOutputFile オプションで複数のファイルに出力するように指定してく
+      ださい。
+
+        (例) gs -dNOPAUSE -sDEVICE=mag256 -sOutputFile=lines%d.mag -- lines.ps
+
+                                            淺山 和典 (ASAYAMA Kazunori)
+                                                    TPM03937@pcvan.or.jp
+                                               GHF01532@niftyserve.or.jp
diff -urN -x .svn espgs-8.15rc2/addons/japanese/doc/gdevmd2k.txt trunk/addons/japanese/doc/gdevmd2k.txt
--- espgs-8.15rc2/addons/japanese/doc/gdevmd2k.txt	1970-01-01 01:00:00.000000000 +0100
+++ trunk/addons/japanese/doc/gdevmd2k.txt	2005-03-14 00:03:51.623784809 +0100
@@ -0,0 +1,179 @@
+
+	ALPS MD series printer driver for Ghostscript 5.xx
+
+							1999/ 4/18
+							1999/ 5/ 2 更新
+
+概要
+---
+  本ドライバは Ghostscript 5.10/5.50(/5.82) で ALPS MD シリーズプリンターの
+出力をするためのドライバです。以下のような機能を備えています。
+
+	カラー／モノクロ印刷が可能
+	300dpi, 600dpi, 1200x600dpi に対応
+	用紙の種類・サイズの指定が可能
+	Floyd-Steinberg dithering が可能
+	dithering 使用時に色の濃度調整が可能
+
+現在、MD-2000/2010/4000/1300/1500/5000 で動作が確認されています。(md2kのみ)
+
+
+インストール
+---
+1. ghostscript をコンパイルするのに必要なソース類を展開し、
+   適宜必要なパッチを当てます。
+2. gdevmd2k.c を gs のソースのあるディレクトリにコピーします。
+3. gs5.10 の場合は、gdevmd2k.dev を Makefile に追加します。
+   gs5.50 の場合は、gdevmd2k.mak-5.50 を contrib.mak に追加します。
+   (gs5.8x の場合は、gdevmd2k.mak-5.8x を contrib.mak に追加)
+4. 自分のサイト用に Makefile を調整し、 DEVICE_DEVS に md2k.dev を追加します。
+   MD-5000 を使用する場合は、md5k.dev を追加します。
+5. make
+
+
+使用方
+---
+  デバイスの指定
+	  gs を実行する際に、-sDEVICE オプションで以下のいずれかのデバイスを
+	選択することで、ALPS MD プリンター用の出力が生成されます。
+
+	-sDEVICE=md2k
+		MD-2000/4000/1000 等、MD-5000 以前の MD シリーズに対応した
+		形式の出力を行います。(MD-5000 でも出力可能です)
+	-sDEVICE=md5k
+		MD-5000 専用の形式で出力します。エコブラックモードを使用する
+		場合は、こちらを指定する必要があります。
+	(注) md5k.dev は99/5/2現在、実際のプリンターでテストされていません。
+	     MD-5000 で、本デバイスをテストして下さった方は是非結果を
+	     お知らせ下さい。
+
+  カラー／モノクロ・dithering の選択
+	-dBitsPerPixel=1   通常のモノクロ印刷
+	-dBitsPerPixel=4   通常のカラー印刷    (default)
+	-dBitsPerPixel=8   Floyd-Steinberg dithering を用いたモノクロ印刷
+	-dBitsPerPixel=32  Floyd-Steinberg dithering を用いたカラー印刷
+
+	(例) tiger.ps をモノクロ・dithering 使用で出力
+	    gs -q -dNOPAUSE -sDEVICE=md2k -dBitsPerPixel=8 \
+	       -sOutputFile=- tiger.ps -c quit | lpr
+
+	-dColor, -dDither を使用しても同様の設定が可能です。
+		-dColor=false	モノクロ
+		-dColor(=true)	カラー
+		-dDither=false	ditheringしない
+		-dDither(=true)	dithering を使用
+
+	* カラー印刷を選択しても PS ファイルがモノクロの場合には、
+	  CMYのインクリボンは使用しません。
+	* dithering を使用すれば、写真等の画像はより綺麗に印刷されるはず
+	  ですが、画像によっては使用しない方が綺麗な場合もあります。
+
+  解像度の選択
+	-r300		300dpi
+	-r600		600dpi (default)
+	-r1200x600	1200x600dpi
+
+	(例) 1200x600dpi で出力
+	    gs -q -dNOPAUSE -sDEVICE=md2k -r1200x600 -dBitsPerPixel=1 \
+	       -sOutputFile=- tiger.ps -c quit | lpr
+
+	* MD-2000 でも、カラー 1200x600dpi が一応指定できますが、
+	  画質はほとんど 600dpi と変わりません。
+
+  用紙指定
+	  用紙の種類を指定します。Windows のドライバと異なり、
+	解像度は用紙の種類から自動的に決定されません。
+	解像度は -r オプションで別途指定して下さい。
+	(注) アイロンシール、レベカフリー等、動作確認していないものも
+	     あります。
+
+	-sMediaType=PlainPaper		コピー紙 (default)
+	-sMediaType=IronSeal		アイロンシール
+	-sMediaType=RebecaFree		レベカフリー
+	-sMediaType=CardBoard		厚紙
+	-sMediaType=PostCard		はがき
+	-sMediaType=FinePaper		上質紙
+	-sMediaType=CoatedFilm		光沢フィルム
+	-sMediaType=GlossyPaper		光沢紙
+	-sMediaType=TransparencyFilm	OHP用紙 (MD-2000 以外)
+	-sMediaType=OHP			  〃
+	-sMediaType=OHP_MD2000		OHP (MD-2000で専用インクを使用する場合)
+
+  用紙サイズの指定
+	-sPAPERSIZE=letter	レターサイズ
+	-sPAPERSIZE=a4		A4
+	-sPAPERSIZE=b5		B5
+	-sPAPERSIZE=postcard	はがき (*)
+	-d.MediaSize='{xx yy}'	任意サイズの指定 (xx, yy は 1/72 inch)
+
+	(*) gdevlips に含まれる gs_statd.ps のパッチを当てた場合に
+	    使用可能
+
+  色の濃度調整
+	dithering を使用する場合のみ、以下のoptionで濃淡の調整が可能。
+	数が大きい程、色が濃く出力されます。
+
+	-dBlack=0-2048		(default 1024)
+	-dCyan=0-2048		(default 1024)
+	-dMagenta=0-2048	(default 1024)
+	-dYellow=0-2048		(default 1024)
+
+	(例) シアンを濃く、マゼンタを薄く印刷する
+	    gs -q -dNOPAUSE -sDEVICE=md2k -dBitsPerPixel=32 \
+	       -dCyan=1200 -dMagenta=800 -sOutputFile=- tiger.ps -c quit
+
+  その他
+	-dManualFeed	手差し印刷する場合に指定します。
+
+	-dEcoBlack	エコブラック印刷を行います。
+			デバイスに md5k を使用した時のみ有効です。
+
+	-dReverseSide	裏面に印刷を行う際に、カール矯正を禁止するため
+			指定します。
+
+
+変更履歴
+---
+1999-05-02	Ver.0.2a
+	* MD-5000 用デバイス md5k の追加
+	* 用紙指定オプション -sMediaType の追加	            
+	* オプション -dManualFeed, -dEcoBlack, -dReverseSide の追加
+	* カラー・dithering の有無を -dBitsPerPixel で指定するよう
+	  README を変更
+	* -dColor, -dDither を int 型から bool 型に変更
+	* -dBitsPerPixel=1 の時、余白をスキップしないバグを修正
+	* 用紙サイズに letter を追加
+	* MD-2000 での OHP 出力に対応
+
+1999-04-18	Ver.0.1
+	* MD-2000 対応の gdevmd2k-0.1 を公開
+
+
+TODO (or NOT TODO ?)
+---
+* 光沢印刷など特殊なモードへの対応
+* dithering 時の画質の向上
+
+
+謝辞
+---
+    Floyd-Steinberg dithering のアルゴリズムは、George Cameron 氏の書かれた
+  gdevcdj.c を参考にさせて頂きました。
+
+    MD-5000 用ドライバ gdevalps の作者 Shinya Uminoさんからは
+  MD-5000 での動作報告と本ドライバに関する御意見を頂きました。
+  本ドライバの MD-5000 対応部分は gdevalps を元に作られました。
+
+    gdevlips の作者 大森紀人さんからはカラーの設定等について御意見を
+  頂きました。また、gs のオプションについては、gdevlips を参考にさせて
+  頂きました。
+
+    Kousuke Ikeda さん、福居毅至さん、清水健二さん、MIHIRA Yoshiro さん
+  からは、MD-1300, MD-1500, MD-4000 での動作報告を頂きました。
+  
+---
+  本ドライバに関する御意見、バグ報告、ALPS MD 各機種でのテスト結果等
+ありましたら、メールにて御連絡願います。
+
+檜垣 将和
+Masakazu Higaki	<higamasa@dd.mbn.or.jp>
diff -urN -x .svn espgs-8.15rc2/addons/japanese/doc/gdevmjc.txt trunk/addons/japanese/doc/gdevmjc.txt
--- espgs-8.15rc2/addons/japanese/doc/gdevmjc.txt	1970-01-01 01:00:00.000000000 +0100
+++ trunk/addons/japanese/doc/gdevmjc.txt	2005-03-14 00:03:52.031771618 +0100
@@ -0,0 +1,58 @@
+gdevmjc-0.8no2 大森紀人 ohmori@p.chiba-u.ac.jp
+
+このドライバは gdevmjc-0.8 をもとにして作られています。
+色あいなどは gdevmjc-0.8 そのままです。
+また、Ghostscript 5.10 で動作させることを前提としています。
+
+1. 対応デバイス
+mj700v2c : EPSON MachJet シリーズで CMYK 4色を印刷できるカラー用のドライバ
+mj500c   : EPSON MachJet シリーズで CMY or K, CMY + K 用のプリンタ用のドライバ
+mj6000c  : EPSON MJ-830C/MJ-930C/MJ-6000C
+           (モノクロ印刷時の高速化に対応している)
+mj8000c  : EPSON MJ-8000C
+           (mj6000c と A2 サイズのマージンが異なる)
+
+**************************************************************
+*※ CMY or K プリンタ: MJ-500C, MJ-510C                      *
+*   CMY + K プリンタ: MJ-800C, MJ-3000C                      *
+*    (これは普通紙には CMYK 印刷できない仕様になっています。)*
+**************************************************************
+
+またカラーに対応していない MachJet でも -dBitsBitsPerPixel=8 を
+指定すればモノクロで使えるようです。
+
+2. 対応解像度
+mj700v2c, mj6000c, mj8000c : 180x180 dpi (-r180 オプション)
+                             360x360 dpi (-r360 オプション) - デフォルト
+                             720x720 dpi (-r720 オプション)
+mj500c                     : 360x360 dpi (-r360 オプション) - デフォルト
+
+
+3. カラー/モノクロ切替え
+-dBitsPerPixel=8     モノクロ印刷
+-dBitsPerPixel=32    カラー印刷 (デフォルト)
+
+4. その他のオプション
+-dMicroweave         マイクロウィーブをオンにする。
+                     (180 dpi ではマイクロウィーブは使えません)
+                     デフォルトでオンなのでオフにするためには、
+                     -dMicroweave=false オプションを使用してください。
+-dUnidirectional     単方向印字にする。
+-dDotSize            ドットサイズを制御する。
+-dDensity            全体の濃さを調整する - デフォルト 1024
+-dCyan               シアンの濃さを調整する - デフォルト 1024
+-dMagenta            マゼンタの濃さを調整する - デフォルト 1024
+-dYellow             黄色の濃さを調整する - デフォルト 1024
+-dBlack              黒色の濃さを調整する - デフォルト 1024
+
+モノクロ印刷時には -dDensity は働きません。-dBlack のみで色調整を
+してください。
+
+5. 最高画質
+このドライバで最高画質をだすためには
+-dMicroweave -dUnidirectional オプションを指定してください。
+
+6. gdevmjc-0.8 のバグで修正したもの
+○Compaq Tru64 UNIX、Alpha Linux 出力がおかしくなるバグ
+○モノクロ印刷時に色調整ができないバグ
+
diff -urN -x .svn espgs-8.15rc2/addons/japanese/doc/gdevml6.txt trunk/addons/japanese/doc/gdevml6.txt
--- espgs-8.15rc2/addons/japanese/doc/gdevml6.txt	1970-01-01 01:00:00.000000000 +0100
+++ trunk/addons/japanese/doc/gdevml6.txt	2005-03-14 00:03:51.674783160 +0100
@@ -0,0 +1,47 @@
+
+  MICROLINE620CL 用 ghostscript ドライバ
+
+					Mar. 16, 1998	N.Tagawa
+
+	$Id$
+
+
+  このドライバは、沖データの MICROLINE620CL を ghostscript で使うため
+のものです。gs は、5.10 に対応しており、Linux-2.0.33(Debian-1.3.1) で
+動作を確認しています。
+
+
+  (1) コンパイル方法
+  他のプリンタドライバと同様の手順でコンパイルできるはずです。
+gdevml6.c ファイルを gs のディレクトリに置き、gdevml6.mak の内容を 
+devs.mak の適当な場所に追加します。
+  gcc-head.mak などの DEVICE_DEVS3 あたりに ml600.dev を追加し、
+tar_cat を実行します。ここらへんは、環境によって変わってくるので、gs 
+に付属のドキュメントを参考にして下さい。後は make でコンパイルできるは
+ずです。
+
+
+  (2) 使い方
+  デバイスとして -sDEVICE=ml600 を指定します。デフォルトの解像度は 600
+x 600 DPI ですが、-r オプションで解像度を変える事ができます。-r300 で 
+300 DPI、-r600x1200 で 600 x 1200 DPI になります。
+
+  あまり細かい事はわからないのですが、トレーの切替えや、用紙の厚さなど
+も変えられるはずです。ただ、PS からどうやって指定すればいいかわからな
+いので、とりあえずデフォルトにしてあります。年賀状を印刷したい時は、コー
+ドを変更して再コンパイルして下さい。^^;
+
+
+  (3) その他
+  このドライバは、MICROLINE620CL 用ですが、たぶん MICROLINE600CL でも
+動くと思います(両方共 IPL だそうですから)。ML-4w で動くかどうかはわか
+りません。持っている人がいたらぜひ試してみて下さい。
+
+  このドライバは無保証です、が、バグの指摘等あればなるべく対応したいと
+思っていますので、よろしくお願いします。
+
+
+  では、お楽しみ下さい:-）
+
+
+					田川 典生(tagawa@tcp-ip.or.jp)
diff -urN -x .svn espgs-8.15rc2/addons/japanese/doc/gdevp201.txt trunk/addons/japanese/doc/gdevp201.txt
--- espgs-8.15rc2/addons/japanese/doc/gdevp201.txt	1970-01-01 01:00:00.000000000 +0100
+++ trunk/addons/japanese/doc/gdevp201.txt	2005-03-14 00:03:52.038771392 +0100
@@ -0,0 +1,30 @@
+
+	gdevp201.c  -  PC-PR201用デバイスドライバ
+
+
+○インストール方法
+
+1. gdevp201.c を gs241 のソースプログラムがあるディレクトリにコピーし
+て下さい。
+
+2. Makefile に gdevp201.mak を追加して下さい。
+
+3. Makefile の DEVICE_DEVS に pr201.dev を加えて下さい。
+
+    例) DEVICE_DEVS=pc98.dev pr201.dev
+			     ^^^^^^^^^
+4. make コマンドで gs をコンパイルし、インストールして下さい。
+
+
+○使い方
+
+＊デバイスの選択は -sDEVICE オプションによって行ないます。
+
+    例) gs -sDEVICE=pr201	(pr201を指定)
+	gs -sDEVICE=pc98	(pc98を指定)
+
+
+
+				片山 紀生(katayama@nacsis.ac.jp)
+
+
diff -urN -x .svn espgs-8.15rc2/addons/japanese/doc/gs261j.euc trunk/addons/japanese/doc/gs261j.euc
--- espgs-8.15rc2/addons/japanese/doc/gs261j.euc	1970-01-01 01:00:00.000000000 +0100
+++ trunk/addons/japanese/doc/gs261j.euc	2005-03-14 00:03:52.013772200 +0100
@@ -0,0 +1,559 @@
+Ghostscript version 2.6.1 日本語化パッケージ gs261j
+Version 1.0 Jan.11,1994 by 片山紀生 (katayama@nacsis.ac.jp)
+Copyright (C) 1991,1992,1993,1994 Norio Katayama.
+
+
+○機能
+
+  1. Ghostscriptの日本語への拡張
+    a. 複合フォントのサポート
+    b. 文字メトリックス(Metrics, Metrics2, CDevProc)のサポート
+    c. 縦書きモードのサポート
+
+  2. 漢字フォントのサポート
+    a. X11R5 PCFフォントファイルからの読出し
+    b. X11R4 SNFフォントファイルからの読出し
+    c. Sony(TM)ベクターフォントファイルからの読出し
+    d. Zeit(TM)フォーマットフォントファイルからの読出し
+		作者: 川本琢二(Ext)さん、井上康成(K-ras)さん
+    e  Zeit(TM) JG フォーマットフォントファイルからの読出し
+		作者: 淺山和典さん
+    f. 日本語TeX PKフォントファイルからの読出し
+
+  3. デバイスドライバ
+    a. gdevnwp (Sony NWP-533/537 プリンタ)
+    b. gdevlips (Canon LIPS-II/II+/III プリンタ)
+		作者: 倉島顕尚さん
+    c. gdevp201 (NEC PC-PR201 プリンタ)
+    d. gdevp150 (NEC PC-PR150 プリンタ)
+                作者: 甲本卓也さん
+    e. gdevepag (ESC/Page)
+                作者: 成松 宏さん
+    f. gdevj100 (Star JJ-100 プリンタ)
+		作者: 横山和由さん
+    g. gdev10v  (Canon BJ10v プリンタ)
+                作者: 岩井輝男さん、前田敦司さん、松井孝雄さん
+
+
+
+○動作確認
+
+  +--------------+-----------------+-----------------+-------------+
+  |  OS          |  Machine        |  Compiler       |  Device     |
+  +--------------+-----------------+-----------------+-------------+
+  | SunOS 4.1.3  | SPARC Station 2 | cc -O  / gcc -O | X11         |
+  +--------------+-----------------+-----------------+-------------+
+
+
+
+○コメント
+
+◇ DJ's GPP を使ってコンパイルするには、淺山和典さんが作られた
+『Ghostscript 2.6.1 DJ's GPP 化パッケージ』を利用することで可能です。
+PC-VAN のサイエンス SIG (SSCIENCE) や Nifty Serve のソフトウェア工房
+(FLABO) から入手できるようになるそうです。
+ 淺山さんのメールアドレスは、NIFTY: GHF01532, PC-VAN: TPM03937 です。
+
+◇ zkfjtex.c など一部のプログラムは char 型が signed char 型であること
+を前提としています。そのため、MIPS 系のコンパイラなど char を unsigned
+char として処理するコンパイラについては -signed オプションか何かを用い
+て char を signed char として処理するように設定して下さい。
+
+◇ X11R5 PCFフォントまたはX11R4 SNFフォントを利用する際、X11環境(サー
+バ、共有ライブラリなど)は必要ありません。フォント・ファイルさえ読み込
+むことができれば漢字を表示することができます。
+
+◇ 質問、要望、バグリポート、改良案など歓迎します。
+   JUNET: katayama@nacsis.ac.jp	NIFTY: NBB01613
+
+
+
+○ご注意
+
+◇この日本語化パッケージには、市販の漢字フォントファイルのデータを読出
+す機能が含まれていますが、それらを利用する際には販売元のライセンス規定
+にふれぬようご注意下さい。(参照 『○漢字フォントのライセンスについて』)
+
+◇この日本語化パッケージは、オフィシャルなものではありませんから、オリ
+ジナルのバックアップを取ってから作業を行なって下さい。
+
+◇このパッケージの使用により生じた問題に関しては、当方では一切責任を負
+いかねますのであらかじめご了承願います。
+
+◇このパッケージの複写、修正、再配布は、営利目的でない場合に限り自由に
+行なって構いません。
+
+
+
+○インストール方法(UNIX)
+
+[1] Ghostscriptのコンパイルとインストール
+
+(1) Ghostscript version 2.6.1 のソースファイルを用意して下さい。
+    このパッケージは以下のパッチをあてたソースファイルを前提にしています。
+        ghostscript-2.6.1.fix-01.gz
+        ghostscript-2.6.1.fix-02.gz
+        ghostscript-2.6.1.fix-03.gz
+        ghostscript-2.6.1.fix-04.gz
+
+(2) ソースファイルを用意したディレクトリで、このパッケージを展開して下
+さい。
+
+(3) パッチファイル`gs261j.diff'をオリジナルソースファイルにあてて下さい。
+
+(4) unix-cc.mak, unix-gcc.mak, unix-ansi.mak のいずれかを Makefile に
+コピーし、各サイトの環境に合わせて編集して下さい。特に、次の四つの設定
+を行なって下さい。
+
+ 1. prefix, exec_prefix, bindir, datadir, gsdatadir マクロによって、
+  Ghostscript をインストールするディレクトリを指定して下さい。
+
+  例) 標準設定の場合
+
+	prefix = /usr/local
+	exec_prefix = $(prefix)
+	bindir = $(exec_prefix)/bin
+	datadir = $(prefix)/lib
+	gsdatadir = $(datadir)/ghostscript
+
+
+ 2. 各サイトの環境に合わせて CFLAGS, LDFLAGS, EXTRALIBS, XINCLUDE,
+  XLIBDIRS マクロを設定して下さい。
+
+
+ 3. FEATURE_DEVS に、使いたい漢字フォントに合わせて以下の名前を加えて
+  下さい。
+
+	kfpcf.dev	X11R5 PCFフォントファイル
+	kfsnf.dev	X11R4 SNFフォントファイル
+	kfsony.dev	Sonyベクターフォントファイル
+	kfzeit.dev	Zeitフォーマットフォントファイル
+	kfztbez.dev	Zeit JG フォーマットフォントファイル
+	kfjtex.dev	日本語TeX PKフォントファイル
+
+  例) PCFフォントファイル、SNFフォントファイル、Zeitフォーマットフォン
+      トファイル、Zeit JG フォーマットフォントファイル、日本語TeX PKフォ
+      ントファイルを使えるようにする場合
+
+	FEATURE_DEVS=filter.dev dps.dev level2.dev kanji.dev \
+		     kfpcf.dev kfsnf.dev kfzeit.dev kfztbez.dev kfjtex.dev
+	
+      Sonyベクターフォントファイルのみを使用する場合
+
+	FEATURE_DEVS=filter.dev dps.dev level2.dev kanji.dev \
+		     kfsony.dev
+
+      PCFフォントファイル、SNFフォントファイル、Zeitフォーマットフォン
+      トファイル、Zeit JG フォーマットフォントファイル、日本語TeX PKフォ
+      ントファイル、Sonyベクターフォントファイルを使えるようにする場合
+
+	FEATURE_DEVS=filter.dev dps.dev level2.dev kanji.dev \
+		     kfpcf.dev kfsnf.dev kfzeit.dev kfztbez.dev kfjtex.dev \
+                     kfsony.dev
+
+
+ 4. DEVICE_DEVS に、使いたいデバイスドライバを並べて下さい。
+
+  例) X11用のデバイスドライバを使うとき
+
+	DEVICE_DEVS=x11.dev
+
+    このパッケージに含まれているデバイスドライバを使用するときには、
+  drivers ディレクトリにある各ドライバのドキュメントを参照して下さい。
+
+
+(5) make コマンドで gs をコンパイルし、make install でインストールして
+下さい。
+
+(6) Makefile の gsdatadir マクロによって指定したディレクトリの下に 
+ghostscript-fonts-2.6.1.tar.gz を展開して下さい。
+
+  例) gsdatadir が標準設定の /usr/local/lib/ghostscript であるとき
+
+	% cd /usr/local/lib/ghostscript
+	% gunzip < ghostscript-fonts-2.6.1.tar.gz | tar xvf -
+
+
+[2] 漢字フォントのコンフィギュレーション
+
+(1) Makefile の gsdatadir マクロによって指定したディレクトリの下に
+kanji というサブディレクトリがあるので、そのディレクトリに移動して下さい。
+
+  例) gsdatadir が標準設定の /usr/local/lib/ghostscript であるとき
+
+	% cd /usr/local/lib/ghostscript
+	% cd kanji
+
+
+(2) 下に列挙したテンプレートファイルの中から使いたいフォントに応じて、
+いずれかをコピーし kconfig.ps をつくって下さい。
+
+	pcf.ps	 X11R5 PCFフォントファイル用
+	snf.ps	 X11R4 SNFフォントファイル用
+	sony.ps	 Sonyベクターフォントファイル用
+	zeit.ps	 Zeitフォーマットフォントファイル用
+        ztbez.ps Zeit JG フォーマットフォントファイル用
+	jtex.ps  日本語TeX PKフォントファイル用
+
+(3) kconfig.ps を各サイトの環境に合わせて編集して下さい。通常、変更し
+なければならないのはフォントファイル名だけです。
+
+  kconfig.ps の詳細については「○漢字コンフィギュレーションファイルに
+ついて」を参照して下さい。
+
+
+[3] 漢字フォントの表示テスト
+
+  サンプルプログラムを gs に実行させ、漢字フォントが正しく表示されるこ
+とを確かめて下さい。
+
+	hankaku.ps	半角文字の一覧を表示します。
+	allkanji.ps	全角漢字の一覧を表示します。
+	fmaptype.ps	複合フォントのフォントマッピングのテストです。
+	vchars.ps	縦書き文字の一覧を表示します。
+	article9.ps	日本国憲法の第九条です。
+
+  サンプルプログラムは、漢字フォントディレクトリにあるのでディレクトリ
+パスを指定する必要はありません。
+
+	例) % gs hankaku.ps
+
+(注) マシンの製造元から提供されているSNFファイルを使用した場合、文字が
+   正しく表示されないことがあります。これは、bdftosnf.h のデフォルト値
+	#define DEFAULTGLPAD		1
+	#define DEFAULTBITORDER		MSBFirst
+	#define DEFAULTBYTEORDER	MSBFirst
+	#define DEFAULTSCANUNIT		1
+   が、SNFファイルのフォーマットと一致してないことが原因と考えられます。
+   もし、文字の表示が正しくない場合には、zkfsnf.c の37行め〜53行めを変
+   更してみることをお勧めします。
+
+
+
+○漢字コンフィギュレーションファイルについて
+
+  このファイルは漢字フォントを定義するためのものです。デフォルトでは、
+kconfig.ps という名前のファイルが使われますが、コマンド・オプションに
+よって変更することもできます。
+
+
+[1] 漢字フォントの定義
+
+  漢字フォントの定義は次のフォーマットによって行ないます。
+
+	フォント名  ユニークID  [ フォントファイル名 ]  コマンド
+
+  ◎フォント名
+	定義する漢字フォントの名前です。標準的な名前は、/Ryumin-Light 
+      と /GothicBBB-Medium の二つです。
+
+  ◎ユニークID
+	定義する漢字フォントを識別するための番号です。取り敢えず、
+      4300000番台から200おきに指定すればよいでしょう。
+
+  ◎フォントファイル名
+	使用するフォントファイルの名前です。このフィールドは、コマンド
+      によって書式が異なります。テンプレートファイルのコメントを参照し
+      て下さい。
+
+  ◎コマンド
+	漢字フォントを定義するためのコマンドです。
+
+  例えば、"/usr/lib/X11/fonts/misc/k24.pcf"という名前のX11R5 PCFフォン
+トファイルを利用して /Ryumin-Light という漢字フォントを定義するときに
+は、次の文を漢字コンフィギュレーションファイルに書いておきます。
+
+  /Ryumin-Light  4300000 (/usr/lib/X11/fonts/misc/k24.pcf) pcfkanji
+
+  この文を書くことによって、以下の漢字フォントが利用できるようになりま
+す。
+
+    /Ryumin-Light.r##	(## = 21〜7E)		横書きJISコード漢字
+    /Ryumin-Light.r##v	(## = 21, 22, 24, 25)	縦書きJISコード漢字
+    /Ryumin-Light.sr##	(## = 81〜9F, E0〜EA)	横書きシフトJIS漢字
+    /Ryumin-Light.sr##v	(## = 81〜83)		縦書きシフトJIS漢字
+
+    /Ryumin-Light.Roman		半角英数
+    /Ryumin-Light.Hiragana	半角ひらがな
+    /Ryumin-Light.Katakana	半角カタカナ
+    /Ryumin-Light.Hankaku	半角英数・ひらがな・カタカナ
+    /Ryumin-Light.SuppK		シフトJIS用半角カタカナ
+
+    /Ryumin-Light-H		横書きJISコード漢字
+    /Ryumin-Light-V		縦書きJISコード漢字
+    /Ryumin-Light-Ext-H		横書き拡張JISコード漢字
+    /Ryumin-Light-Ext-V		縦書き拡張JISコード漢字
+    /Ryumin-Light-EUC-H		横書きEUCコード漢字
+    /Ryumin-Light-EUC-V		縦書きEUCコード漢字
+    /Ryumin-Light-RKSJ-H	横書き半角英数・片仮名・シフトJIS漢字
+    /Ryumin-Light-RKSJ-V	縦書き半角英数・片仮名・シフトJIS漢字
+    /Ryumin-Light-83pv-RKSJ-H	横書き半角英数・片仮名・シフトJIS漢字
+
+  拡張JISコード用の漢字フォントも定義されますが、出力される文字は当然
+フォントファイルの内容によって決まります。したがって、フォントファイル
+に含まれない文字は表示されませんし、JIS-78になるかJIS-83になるかもフォ
+ントファイルに依存します。
+
+
+[2] 漢字フォントの別名の定義
+
+  漢字フォントに別名を定義するときには、copyfont というオペレータを使い
+ます。copyfont のフォーマットは次の通りです。
+
+  既存のフォント名	別名	copyfont
+
+例えば、/GothicBBB-Medium-83pv-RKSJ-H の別名として /ChuGothicBBB-Medium を
+定義するときには、漢字コンフィギュレーションファイルに次のように書きます。
+
+  /GothicBBB-Medium-83pv-RKSJ-H	/ChuGothicBBB-Medium	copyfont
+
+
+
+○コマンドオプション
+
+gs コマンドのオプションとして以下のものが使えます。
+
+    -dNOKANJI		漢字フォントを定義しなくなります。
+    -sKCONFIG=pcf.ps	漢字コンフィギュレーションファイルを指定します。
+
+
+
+○漢字フォントのライセンスについて
+
+以下は漢字フォントのライセンスについての情報です。参考にして下さい。
+
+
+◇ Zeit「書体倶楽部」
+
+  Zeitファイル用のプログラムを作られた川本さんが問い合わせて下さったと
+ころ、「フォントデータの読出しは、ユーザが書体倶楽部を購入しフリーウェ
+アによって読出すのであれば構わない」という回答だったそうです。
+
+
+◇ 大日本印刷「JTeX用フォント」
+
+  筑波大学の木本豪さんが大日本印刷に問い合わせて下さったところ、「もと
+もとのライセンス契約がTeX用となっているので、新たな形態で使用する場合
+大日本印刷の方へ連絡する必要がある」という回答だったそうです。
+
+以下は、木本さんのメールからの引用です。
+
+大日本印刷のフォントを使うにあたっては、
+---- ここから ----
+
+「TeX のフォントを GhostScript のソフトウエアで使うために
+こうこうします」
+という旨のメモを、下記に送ってくれればいいそうです。
+
+〒162-01 新宿区市ヶ谷加賀町 1-1-1 
+大日本印刷（株） CTS 事業部 CTS 開発本部システム開発第 1 部
+斉藤 雅
+
+  そうすれば、（すでに大日本印刷の手元にある）使用許諾契約書
+に添付しておく、とのことです。
+  （すでにライセンスを持っていると言う前提で話をしました。）
+  PK を変換して使うか、GhostScript の方を PK に対応させて
+使うか、ということについても、上のメモに実際の使用形態を
+書けばどちらでもかまわないそうです。
+
+---- ここまで ----
+
+
+
+○謝辞
+
+このパッケージを作成するにあたっては以下の方々にご協力を頂きました。
+この場をかりてお礼申し上げます。ありがとうございました。
+
+gs23j10 の開発に協力して下さった方
+	IMAGICAの井川さん
+	東工大の鵜飼さん
+	豊橋技科大の大見嘉弘さん
+	古河電工の大山哲弥さん
+	東大の倉島顕尚さん
+	電通大の桑田正行さん
+	慶応の中丸幸治さん
+	富士通国際研の野呂さん
+	大阪電通大の南野さん
+
+Zeitフォーマットファイル用の漢字フォントプログラムを作られた方
+	井上康成さん		
+	松下電器の川本琢二さん
+
+Zeit JG フォーマットファイル用の漢字フォントプログラムを作られた方
+	淺山 和典さん
+
+Canon LIPS-II/II+/III プリンタ用ドライバを作られた方  
+	日本電気の倉島顕尚さん
+
+NEC PC-PR150 プリンタ用ドライバを作られた方
+	神戸大学の甲本卓也さん
+
+ESC/Page 用ドライバを作られた方
+	日本電気アイシーマンコンシステム九州LSI開発センターの成松 宏さん
+
+Star JJ-100 プリンタ用ドライバを作られた方
+	横山和由さん
+
+Canon BJ10v プリンタ用ドライバを作られた方
+	慶応大学の岩井輝男さん、前田敦司さん、松井孝雄さん
+
+
+
+○ファイル・リスト
+
+gs261j.doc		ドキュメント(英語)
+gs261j.jis		ドキュメント(JIS)
+gs261j.sj		ドキュメント(シフトJIS)
+gs261j.euc		ドキュメント(EUC)
+
+gs261j.diff		Ghostscript Ver. 2.6.1 差分ファイル
+
+zcomp.c			複合フォントオペレータ定義プログラム
+kfutil.c		漢字フォントユーティリティプログラム
+zkfimpath.c		イメージパスオペレータ定義プログラム
+
+zkfpcf.c		PCFフォント用オペレータ定義プログラム
+zkfsnf.c		SNFフォント用オペレータ定義プログラム
+zkfsony.c	       	Sony(TM)ベクターフォント用オペレータ定義プログラム
+zkfzeit.c		Zeit(TM)フォント用オペレータ定義プログラム
+zkfztbez.c		Zeit(TM) JG フォント用オペレータ定義プログラム
+zkfjtex.c		日本語TeX PKフォント用オペレータ定義プログラム
+
+drivers/
+    gdevnwp/		Sony NWP-533/537 プリンタ用ドライバ
+    gdevlips/		Canon LIPS-II/II+/III プリンタ用ドライバ
+    gdevp201/		NEC PC-PR201 プリンタ用ドライバ
+    gdevp150/		NEC PC-PR150 プリンタ用ドライバ
+    gdevepag/		ESC/Page 用ドライバ
+    gdevj100/		Star JJ-100 プリンタ用ドライバ
+    gdev10v/            Canon BJ10v プリンタ用ドライバ
+
+kanji/
+    kinit.ps		漢字化用プログラム
+    metrics2.ps		縦書き用プログラム
+    kbitmap.ps		ビットマップ漢字フォント用プログラム
+    koutline.ps		アウトラインフォント用プログラム
+    kbase.ps		漢字ベースフォント定義用プログラム
+    kcomp.ps		漢字複合フォント定義用プログラム
+    kmapping.ps		漢字JISコードマッピング用プログラム
+
+    kfpcf.ps		X11R5 PCFフォント用プログラム
+    kfsnf.ps		X11R4 SNFフォント用プログラム
+    kfsony.ps	       	Sony(TM)ベクターフォント用プログラム
+    kfzeit.ps		Zeit(TM)フォント用プログラム
+    kfztbez.ps		Zeit(TM) JG フォント用プログラム
+    kfjtex.ps		日本語TeX PKフォント用プログラム
+
+    pcf.ps		X11R5 PCFフォント用テンプレートファイル
+    snf.ps		X11R4 SNFフォント用テンプレートファイル
+    sony.ps		Sony(TM)ベクターフォント用テンプレートファイル
+    zeit.ps		Zeit(TM)ベクターフォント用テンプレートファイル
+    ztbez.ps		Zeit(TM) JG フォント用テンプレートファイル
+    jtex.ps		日本語TeX PKフォント用テンプレートファイル
+
+    hankaku.ps		半角文字表示サンプル
+    allkanji.ps		全漢字表示サンプル
+    fmaptype.ps		複合フォントマッピングサンプル
+    vchars.ps		縦書き文字のサンプル
+    article9.ps		縦書き文章のサンプル
+
+include.pcf/		PCFフォント用ヘッダファイルを格納したディレクトリ
+include.snf/		SNFフォント用ヘッダファイルを格納したディレクトリ
+
+
+
+○バージョンについて
+
+gs23j10 (Oct. 4, 1991)
+    Ghostscript ver. 2.3用 日本語化パッケージ
+
+gs23j11 (Dec.24, 1991)
+    漢字フォントファイル名を検索するハッシュルーチンのバグを修正した。
+    変数名 index と関数名 index とが衝突する問題を回避した。
+
+gs23j12 (Jan.17, 1992)
+    フォントメトリックスを単一の数値で指定したときエラーが起こるバグを
+  修正した。
+
+
+gs24j10 (May.15, 1992)
+    Ghostscript ver. 2.4.1用 日本語化パッケージ
+
+gs241j11 (Jul. 1, 1992)
+    gs24j10 のバグを修正した。
+
+
+gs261j01b (Aug.20, 1993)
+    Ghostscript ver. 2.6.1用 日本語化パッケージ βバージョン
+
+gs261j10 (Jan.11, 1994)
+    Ghostscript ver. 2.6.1用 日本語化パッケージ
+
+
+
+○差分について
+
+bfont.h
+  make_composite_font(), make_descender_fonts()のプロトタイプ宣言を追加。   
+
+gs_init.ps
+  オリジナルのフォントオペレータを複合フォントオペレータに置換。
+  kinit.ps および metrics2.ps を読み込む用に変更。
+
+gs_fonts.ps
+  QUIET モードで、かつ、フォントファイルが見つからないとき、フォント名を
+  スタックに残してしまうという不具合の修正。
+
+gschar.c
+  gs_setcachedevice2 を修正。縦書きフォント(WMode=1)に対応。
+  gs_setrootfont(), gs_currentrootfont()を定義。
+
+gschar.h
+  gs_setrootfont(), gs_currentrootfont()のプロトタイプ宣言を追加。   
+
+gsfont.c
+  キャッシュサイズを拡大。
+  UniqueID を持たないはずの複合フォントを、ベースフォント同様キャッシュ
+してしまうという不具合の修正。
+
+gzstate.h
+  状態として、rootfont を追加。
+
+zchar2.c
+  zrootfont() が gs_currentrootfont() を使うように変更。
+
+zfont.c
+  ルートフォントに対応するため、zsetfontを変更。
+  複合フォントに対して makefont を行なう際、make_composite_font()を呼
+ぶように変更。
+  make_composite_font()を定義。
+	
+zfont0.c
+  zbuildfont0の最後で、make_descender_fonts()を呼ぶように変更。
+  make_descender_fonts()を定義。
+
+zfont2.c
+  makefontキャッシュの効率化のため偽UniqueIDを生成するよう変更。
+
+gs.mak
+  複合フォント機能、漢字フォント機能を追加。
+
+cc-head.mak
+gcc-head.mak
+ansihead.mak
+  GS_LIB_DEFAULT に $(gsdatadir)/kanji を追加。
+  コンパイル・オプションに -DCOMPFONT -DWMODE -DKANJI を追加。
+  FEATURE_DEVS に kanji.dev kfpcf.dev kfsnf.dev kfzeit.dev kfztbez.dev
+  kfjtex.dev を追加。
+
+unixhead.mak
+  暗黙のルール `.c.o' の依存ファイル $(AK) を削除。
+
+unixtail.mak
+  出力される実行ファイルの名前を `gs' から $(GS)$(XE) に変更。
+
+unix-cc.mak
+unix-gcc.mak
+unix-ansi.mak
+  gs.mak, cc-head.mak, gcc-head.mak, ansihead.mak に合わせて変更。
diff -urN -x .svn espgs-8.15rc2/addons/japanese/doc/gs261j.txt trunk/addons/japanese/doc/gs261j.txt
--- espgs-8.15rc2/addons/japanese/doc/gs261j.txt	1970-01-01 01:00:00.000000000 +0100
+++ trunk/addons/japanese/doc/gs261j.txt	2005-03-14 00:03:52.029771683 +0100
@@ -0,0 +1,494 @@
+Ghostscript Kanji Package gs261j
+Version 1.0 Jan.11,1994 by Norio KATAYAMA (katayama@nacsis.ac.jp)
+Copyright (C) 1991,1992,1993,1994 Norio Katayama.
+This document is translated into English on Jan.11,1994.
+
+
+Features
+========
+
+  1. Support for Japanese.
+    a. composite fonts.
+    b. font metrics (Metrics, Metrics2, CDevProc).
+    c. vertical writing (WMode).
+
+  2. Support for Kanji font files.
+    a. X11R5 PCF font files.
+    b. X11R4 SNF font files.
+    c. Sony(TM) vector font files.
+    d. Zeit(TM) format font files.
+		Authors:  Takuji KAWAMOTO, and Yasunari INOUE.
+    e. Zeit(TM) JG format font files.
+		Author:  Kazunori ASAYAMA
+    f. JTeX PK font files.
+
+  3. Device drivers.
+    a. gdevnwp (Sony NWP-533/537 printer)
+    b. gdevlips (Canon LIPS-II/II+/III printer)
+		Author:  Akihisa KURASHIMA
+    c. gdevp201 (NEC PC-PR201 printer)
+    d. gdevp150 (NEC PC-PR150 printer)
+		Author:  Takuya KOUMOTO
+    e. gdevepag (ESC/Page)
+		Author:  Hiroshi NARIMATSU
+    f. gdevj100 (Star JJ-100 printer)
+		Author:  Caz Yokoyama
+    g. gdev10v  (Canon BJ10v printer)
+                Authors:  Teruo IWAI, Atusi MAEDA, Takao MATUI
+
+
+Tested Environments
+===================
+
+  +--------------+-----------------+-----------------+-------------+
+  |  OS          |  Machine        |  Compiler       |  Device     |
+  +--------------+-----------------+-----------------+-------------+
+  | SunOS 4.1.3  | SPARC Station 2 | cc -O  / gcc -O | X11         |
+  +--------------+-----------------+-----------------+-------------+
+
+
+
+Notes
+=====
+
+Any questions, requests, and bug reports are welcomed.
+  JUNET: katayama@nacsis.ac.jp	NIFTY: NBB01613
+
+
+
+Notices
+=======
+
+Sony vector font files, Zeit format font files, and JTeX PK font files
+are commercial products. Please be careful not to violate their
+licenses.
+
+This Kanji package is not an official patch. Therefore you should keep
+the original distribution.
+
+No author takes responsibility for the consequences of using this
+package.
+
+Everyone is permitted to copy, modify and redistribute this package
+only for nonprofit use.
+
+
+How to install (UNIX)
+=====================
+
+[1] Building Ghostscript
+
+(1) Extract source files from the original distribution of Ghostscript
+    version 2.6.1.
+    This package is based on the source files to which the following
+    patches are applied.
+        ghostscript-2.6.1.fix-01.gz
+        ghostscript-2.6.1.fix-02.gz
+        ghostscript-2.6.1.fix-03.gz
+        ghostscript-2.6.1.fix-04.gz
+
+(2) Extract the contents of this package in the directory containing
+    the original source files.
+
+(3) Apply a patch file `gs261j.diff' to the original source files.
+
+(4) Copy unix-cc.mak, unix-gcc.mak or unix-ansi.mak onto Makefile, and
+    edit it appropriately. At least four configurations described
+    below must be done.
+
+ 1. Set prefix, exec_prefix, bindir, datadir, and gsdatadir macros to
+    specify the directory to which Ghostscript will be installed.
+
+
+ 2. Set CFLAGS, LDFLAGS, EXTRALIBS, XINCLUDE, and XLIBDIRS macros to
+    configure compilation options.
+    
+ 3. Choose the features of Kanji font files to be included and add
+    some of the symbols listed below to FEATURE_DEVS.
+
+	kfpcf.dev	X11R5 PCF font files.
+	kfsnf.dev	X11R4 SNF font files.
+	kfsony.dev	Sony vector font files.
+	kfzeit.dev	Zeit format font files.
+	kfztbez.dev	Zeit JG format font files.
+	kfjtex.dev	JTeX PK font files.
+
+  Examples)
+      To include the features of PCF font files, SNF font files, Zeit
+      format font files, Zeit JG format font files, and JTeX PK font files.
+
+	FEATURE_DEVS=filter.dev dps.dev level2.dev kanji.dev \
+		     kfpcf.dev kfsnf.dev kfzeit.dev kfztbez.dev kfjtex.dev
+	
+      To include the feature of Sony vector font files only.
+
+	FEATURE_DEVS=filter.dev dps.dev level2.dev kanji.dev \
+		     kfsony.dev
+
+      To include the features of PCF font files, SNF font files, Zeit
+      format font files, Zeit JG format font files, JTeX PK font files,
+      and Sony vector font files.
+
+	FEATURE_DEVS=filter.dev dps.dev level2.dev kanji.dev \
+		     kfpcf.dev kfsnf.dev kfzeit.dev kfztbez.dev kfjtex.dev \
+                     kfsony.dev
+
+
+ 4. Choose the devices to be included and add the symbols for them to
+    DEVICE_DEVS.
+
+  Example)
+      To include the device driver of X11.
+
+	DEVICE_DEVS=x11.dev
+
+    If you want to use the device drivers contained in this package,
+    see documents in the `drivers' subdirectory.
+
+
+(5) MAKE and install Ghostscript.
+
+(6) Extract font files from ghostscript-fonts-2.6.1.tar.gz into the
+    directory specified by the gsdatadir macro in Makefile.
+
+  Example)
+      When gsdatadir is the default value (/usr/local/lib/ghostscript) :
+
+        % cd /usr/local/lib/ghostscript
+        % gunzip < ghostscript-fonts-2.6.1.tar.gz | tar xvf -
+
+
+[2] Configuring Kanji Fonts
+
+(1) Change the working directory to the `kanji' directory which is a
+    subdirectory of the directory specified by the gsdatadir macro in
+    Makefile.
+
+  Example)
+      When gsdatadir is the default value (/usr/local/lib/ghostscript) :
+
+        % cd /usr/local/lib/ghostscript
+        % cd kanji
+
+(2) Copy one of the following template files onto `kconfig.ps'.
+
+	pcf.ps	 for X11R5 PCF font files.
+	snf.ps	 for X11R4 SNF font files.
+	sony.ps	 for Sony vector font files.
+	zeit.ps	 for Zeit format font files.
+	ztbez.ps for Zeit JG format font files.
+	jtex.ps  for JTeX PK font files.
+
+(3) Edit `kconfig.ps' appropriately. Normally, you have only to change
+    the names of font files.
+
+  The details of `kconfig.ps' are described in the section ``Kanji
+  Configuration File''.
+
+
+[3] Testing Kanji fonts.
+
+  Execute the following sample programs with gs and verify Kanji fonts
+  are displayed correctly.
+
+	hankaku.ps	A list of half-width Kanji characters.
+	allkanji.ps	A list of Kanji characters.
+	fmaptype.ps	A test program of the composite font mapping.
+	vchars.ps	A list of characters for vertical writing.
+	article9.ps	Article 9 of the Constitution of Japan.
+
+  Because sample programs are contained in the Kanji library directory,
+  you need not specify a directory path.
+
+	Example)
+	    % gs hankaku.ps
+
+Note
+----
+   If you use X11R4 SNF font files which are provided by manufactures
+   (i.e. not made from the MIT distribution), it is possible that
+   Kanji characters are not displayed correctly. This is because the
+   SNF format is dependent on X server and the default values defined
+   in bdftosnf.h is not appropriate to the server. Edit lines from 37
+   to 53 in zkfsnf.c to solve this problem.
+
+
+
+Kanji Configuration File
+========================
+
+  Kanji fonts for Ghostscript are defined in the Kanji configuration
+  file. The name of this file is `kconfig.ps' by default, but it can
+  be changed by -sKCONFIG switch (see the section `Command switches').
+
+[1] Definition of Kanji Fonts
+
+  Kanji fonts are defined in the following format.
+
+	FontName  UniqueID  [ FileName ]  Operator
+
+    FontName
+	is a name of the Kanji font to be defined.
+        `/Ryumin-Light' and `/GothicBBB-Medium' are standard Kanji fonts.
+
+    UniqueID
+	is a unique identifier of the font.
+	Normally, the identifiers may be set from 4300000 with 200
+        differences.
+
+    FileName
+	is the name of the font file to be used.
+	The rule of this field is determined by `Operator', so see
+        comments in the template files for details
+
+    Operator
+	is a Ghostscript operator to define Kanji font.
+
+  For example, if you want to define a Kanji font with a name
+  `/Ryumin-Light' using a X11R5 PCF font file whose path name is
+  "/usr/lib/X11/fonts/misc/k24.pcf", you will write the following line
+  in the Kanji configuration file.
+
+  /Ryumin-Light  4300000 (/usr/lib/X11/fonts/misc/k24.pcf) pcfkanji
+
+  With this line, the following Kanji fonts will be available.
+
+    /Ryumin-Light.r##	(## = 21 - 7E)		horizontal JIS  base Kanji
+    /Ryumin-Light.r##v	(## = 21, 22, 24, 25)	vertical   JIS  base Kanji
+    /Ryumin-Light.sr##	(## = 81 - 9F, E0 - EA)	horizontal SJIS base Kanji
+    /Ryumin-Light.sr##v	(## = 81 - 83)		vertical   SJIS base Kanji
+
+    /Ryumin-Light.Roman		half-width alphanumeric characters
+    /Ryumin-Light.Hiragana	half-width Hiragana
+    /Ryumin-Light.Katakana	half-width Katakana
+    /Ryumin-Light.Hankaku	half-width alphanumerics, Hiragana, Katakana
+    /Ryumin-Light.SuppK		half-width Katakana for SJIS
+
+    /Ryumin-Light-H		horizontal JIS          Kanji
+    /Ryumin-Light-V		vertical   JIS          Kanji
+    /Ryumin-Light-Ext-H		horizontal Extended JIS Kanji
+    /Ryumin-Light-Ext-V		vertical   Extended JIS Kanji
+    /Ryumin-Light-EUC-H		horizontal EUC          Kanji
+    /Ryumin-Light-EUC-V		vertical   EUC          Kanji
+    /Ryumin-Light-RKSJ-H	horizontal Roman, Katakana, SJIS Kanji
+    /Ryumin-Light-RKSJ-V	vertical   Roman, Katakana, SJIS Kanji
+    /Ryumin-Light-83pv-RKSJ-H	horizontal Roman, Katakana, SJIS Kanji
+
+  Although Kanji fonts in Extended JIS Encoding are defined,
+  characters to be displayed are determined by the contents of font
+  files. For the same reason, the Kanji encoding such as JIS-78 and
+  JIS-83 are also determined by font files.
+
+[2] Definition of Aliases
+
+  An operator `copykanji' can be used to define aliases of Kanji fonts.
+  The following is the format of `copykanji'.
+
+	FontName   NewName  copykanji
+
+  For example, the following line defines an alias `/ChuGothicBBB-Medium'
+  for the font `/GothicBBB-Medium-83pv-RKSJ-H'.
+
+	/GothicBBB-Medium-83pv-RKSJ-H  /ChuGothicBBB-Medium  copykanji
+
+
+Command Switches
+================
+
+New command switches are available.
+
+    -dNOKANJI		Suppress installing Kanji fonts.
+    -sKCONFIG=foo.ps	Define the name of the Kanji configuration file.
+
+
+Acknowledgements
+================
+
+In developing this package I obtained cooperation from the following
+persons. I make my acknowledgement with thanks to them.
+
+Cooperators in developing gs23j10.
+	IKAWA, Takanori UGAI, Yoshihiro OHMI, Tetsuya OHYAMA, 
+        Akihisa KURASHIMA, Masayuki KUWADA, NAKAMARU, NORO, 
+	and Hisashi MINAMINO
+
+Authors of the feature of Zeit format font files.
+	Takuji KAWAMOTO, and Yasunari INOUE
+
+Author of the feature of Zeit JG format font files.
+	Kazunori ASAYAMA
+
+Author of the Canon LIPS-II/II+/III printer driver.
+	Akihisa KURASHIMA
+
+Author of the NEC PC-PR150 printer printer driver.
+	Takuya KOUMOTO
+
+Author of the ESC/Page printer driver.
+	Hiroshi NARIMATSU
+
+Author of the Star JJ-100 printer driver.
+	Caz Yokoyama
+
+Author of the Canon BJ10v printer driver.
+	Teruo IWAI, Atusi MAEDA, Takao MATUI
+
+
+File List
+=========
+
+gs261j.doc		Document of this package (English)
+gs261j.jis		Document of this package (Japanese in JIS Kanji)
+gs261j.sj		Document of this package (Japanese in SJIS Kanji)
+gs261j.euc		Document of this package (Japanese in EUC Kanji)
+
+gs261j.diff		Patch file for Ghostscript version 2.4.1
+
+zcomp.c			C program defining composite font operators.
+kfutil.c		C program defining Kanji font utilities.
+zkfimpath.c		C program defining imagepath operator.
+
+zkfpcf.c		C program defining PCF font file operator.
+zkfsnf.c		C program defining SNF font file operator.
+zkfsony.c	       	C program defining Sony vector font file operator.
+zkfzeit.c		C program defining Zeit font file operator.
+zkfztbez.c		C program defining Zeit JG font file operator.
+zkfjtex.c		C program defining JTeX PK font file operator.
+
+drivers/
+    gdevnwp/		Sony NWP-533/537 printer driver
+    gdevlips/		Canon LIPS-II/II+/III printer driver
+    gdevp201/		NEC PC-PR201 printer driver
+    gdevp150/		NEC PC-PR150 printer driver
+    gdevpag/		ESC/Page printer driver
+    gdevj100/		Star JJ-100 printer driver
+    gdev10v/            Canon BJ10v printer
+
+kanji/
+    kinit.ps		GS program for Kanji environment.
+    metrics2.ps		GS program for vertical writing.
+    kbitmap.ps		GS program for bitmap Kanji fonts.
+    koutline.ps		GS program for outline Kanji fonts.
+    kbase.ps		GS program for defining Kanji base fonts.
+    kcomp.ps		GS program for defining Kanji composite fonts.
+    kmapping.ps		GS program for the mapping from symbols to JIS codes.
+
+    kfpcf.ps		GS program for X11R5 PCF font files.
+    kfsnf.ps		GS program for X11R4 SNF font files.
+    kfsony.ps	       	GS program for Sony vector font files.
+    kfzeit.ps		GS program for Zeit format font files.
+    kfztbez.ps		GS program for Zeit JG format font files.
+    kfjtex.ps		GS program for JTeX PK font files.
+
+    pcf.ps		Template file for X11R5 PCF font files.
+    snf.ps		Template file for X11R4 SNF font files.
+    sony.ps		Template file for Sony vector font files.
+    zeit.ps		Template file for Zeit format font files.
+    ztbez.ps		Template file for Zeit JG format font files.
+    jtex.ps		Template file for JTeX PK font files.
+
+    hankaku.ps		Sample of half-width Kanji characters.
+    allkanji.ps		Sample of Kanji characters.
+    fmaptype.ps		Sample of the composite font mapping.
+    vchars.ps		Sample of characters for vertical writing.
+    article9.ps		Sample of vertical writing.
+
+include.pcf/		Directory containing header files for PCF fonts.
+include.snf/		Directory containing header files for SNF fonts.
+
+
+History
+=======
+
+gs23j10 (Oct. 4, 1991)
+    Kanji package for Ghostscript version 2.3.
+
+gs23j11 (Dec.24, 1991)
+
+gs23j12 (Jan.17, 1992)
+
+
+gs24j10 (May.15, 1992)
+    Kanji package for Ghostscript version 2.4.1.
+
+gs241j11 (Jul. 1, 1992)
+
+
+gs261j01b (Aug.20, 1993)
+    Kanji package for Ghostscript version 2.6.1. (beta version)
+
+gs261j10 (Jan.11, 1994)
+    Kanji package for Ghostscript version 2.6.1.
+
+
+Patches
+=======
+
+bfont.h
+  The prototype declaration of make_composite_font() and
+  make_descender_fonts() are added.
+
+gs_init.ps
+  Base font operators are replaced with composite font operators.
+  `kinit.ps' and `metrics2.ps' are invoked.
+
+gs_fonts.ps
+  The problem is fixed that the findfont operator leaves a font name
+  in the stack when it is in QUIET mode and the font file is not found.
+  
+gschar.c
+  gs_setcachedevice2() is adapted to the vertical writing.
+  The vertical writing feature is implemented.
+  gs_setrootfont() and gs_currentrootfont() are defined.
+
+gschar.h
+  The prototype declaration of gs_setrootfont() and gs_currentrootfont()
+  are added.
+
+gsfont.c
+  The font cache is enlarged for the efficiency of Kanji fonts.
+  The problem is fixed that composite fonts, which have no UniqueID,
+  are cached by makefont.
+
+gzstate.h
+  rootfont is added into the graphics state.
+
+zchar.c
+  zrootfont() is changed to call gs_currentrootfont().
+
+zfont.c
+  zsetfont() is adapted to rootfont.
+  make_font() calls make_composite_font() when it transforms composite
+  fonts.
+  make_composite_font() is defined.
+	
+zfont0.c
+  zbuildfont0() is changed to call make_descender_fonts().
+  make_descender_fonts() is defined.
+
+zfont2.c
+  A `fake UniqueID' facility is implemented to enhance the efficiency
+  of the `makefont' cache.
+
+gs.mak
+  The features of composite fonts and Kanji fonts are added.
+
+cc-head.mak
+gcc-head.mak
+ansihead.mak
+  `$(gsdatadir)/kanji' is added to the GS_LIB_DEFAULT macro.
+  `-DCOMPFONT -DWMODE -DKANJI' is added to the compilation flags.
+  `kanji.dev kfpcf.dev kfsnf.dev kfzeit.dev kfztbez.dev kfjtex.dev' is
+  added to the FEATURE_DEVS macro.
+
+unixhead.mak
+  The dependency `$(AK)' is removed from the implicit rule `.c.o'.
+
+unixtail.mak
+  The name of the output file is changed from `gs' to` $(GS)$(XE)'.
+
+unix-cc.mak
+unix-gcc.mak
+unix-ansi.mak
+  These files are updated according to the changes of gs.mak,
+  cc-head.mak, gcc-head.mak, and ansihead.mak.
diff -urN -x .svn espgs-8.15rc2/addons/japanese/doc/README.gs550j trunk/addons/japanese/doc/README.gs550j
--- espgs-8.15rc2/addons/japanese/doc/README.gs550j	1970-01-01 01:00:00.000000000 +0100
+++ trunk/addons/japanese/doc/README.gs550j	2005-03-14 00:03:52.040771327 +0100
@@ -0,0 +1,35 @@
+GNU Ghostscript version 5.50 日本語化パッチ gs550j
+Version 0.3 Jun. 22, 1999 by 大森紀人 (ohmori@p.chiba-u.ac.jp)
+Copyright (C) 1996-1999 Daisuke SUZUKI.
+Copyright (C) 1999 Norihito Ohmori.
+
+●はじめに
+
+このパッチは片山紀生(katayama@nacsis.ac.jp)さんの作成された、
+ghostscript-2.6.1 日本語化パッケージのドライバと、淺山和典さんの
+作成された 日本語 Font Driver on VFlib version 1.0 を ghostscript 5.50 に
+対応させた 田中哲 <akr@jaist.ac.jp> さんの gs5.50-vflib-1.1
+を基本部分に利用し、いくつかのパッチをあて、多くのプリンタドライバ群を
+同梱したものです。
+
+
+●Changes
+・gs550j03
+  gdevlips-2.3.3 (Update for lips4v.dev bugfix)
+・gs550j02
+  gdevlbp3-0.2 (Update)
+・gs550j01
+  最初のリリース
+
+
+●最後に
+
+このパッチに関する著作権その他は GPL に従います。
+また、このパッチは無保証です。これを使ったことによりなんらかの不具合が
+発生したとしても作者はなんらの責任も負いません。
+
+
+●謝辞
+
+各ドライバを公開して頂いた作者の皆様に感謝します。
+また、テストをしてくださった皆様、本当にありがとうございました。
diff -urN -x .svn espgs-8.15rc2/addons/japanese/dviprlib.c trunk/addons/japanese/dviprlib.c
--- espgs-8.15rc2/addons/japanese/dviprlib.c	1970-01-01 01:00:00.000000000 +0100
+++ trunk/addons/japanese/dviprlib.c	2005-03-14 00:03:52.504756326 +0100
@@ -0,0 +1,2834 @@
+/* COPYRIGHT (C) 1990, 1992 Aladdin Enterprises.  All rights reserved.
+   Distributed by Free Software Foundation, Inc.
+   
+   This file is part of Ghostscript.
+   
+   Ghostscript is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility
+   to anyone for the consequences of using it or for whether it serves any
+   particular purpose or works at all, unless he says so in writing.  Refer
+   to the Ghostscript General Public License for full details.
+   
+   Everyone is granted permission to copy, modify and redistribute
+   Ghostscript, but only under the conditions described in the Ghostscript
+   General Public License.  A copy of this license is supposed to have been
+   given to you along with Ghostscript so you can know your rights and
+   responsibilities.  It should be in a file named COPYING.  Among other
+   things, the copyright notice and this notice must be preserved on all
+   copies.  */
+
+/* dviprlib.c */
+
+#include "stdio_.h"
+#include "ctype_.h"
+#include "malloc_.h"
+#include "string_.h"
+#include "gstypes.h"
+#include "gsmemory.h"
+#include "gp.h"
+
+/* include library header. */
+#define dviprlib_implementation
+#include "dviprlib.h"
+
+/* The remainder of this file is a copy of the library for dviprt. */
+
+
+/***** From rcfg.c *****/
+/* $Id$ */
+
+
+/*--- forward declarations ---*/
+private int dviprt_read_S_cfg(dviprt_cfg_t *,dviprt_cfg_i *);
+private int dviprt_read_QR_cfg(dviprt_cfg_t *,dviprt_cfg_i *);
+     
+/*--- library functions ---*/
+int 
+dviprt_readcfg(char *ifname,dviprt_cfg_t *pcfg,uchar *pcodebuf,int codebuf_s,
+    uchar *pworkbuf,int workbuf_s)
+{
+  int code;
+  int ver;
+  dviprt_cfg_i info;
+  
+  info.fname = ifname;
+  info.line_no = -1;
+  if (ifname) {
+    info.file = fopen(ifname,gp_fmode_rb);
+    if (info.file == NULL) {
+      dviprt_printcfgerror(&info,"Cannot open.\n",-1);
+      return CFG_ERROR_FILE_OPEN;
+    }
+  }
+  else {
+    info.file = stdin;
+  }
+  
+  fseek(info.file,16,0);
+  ver = fgetc(info.file);
+  fseek(info.file,0,0);
+  info.codebuf = pcodebuf;
+  info.readbuf = pworkbuf;
+  info.codebuf_size = codebuf_s;
+  info.readbuf_size = workbuf_s;
+  code = (ver == 'S') ? dviprt_read_S_cfg(pcfg,&info) 
+    : dviprt_read_QR_cfg(pcfg,&info);
+  
+  if (ifname) fclose(info.file);
+  return code;
+}
+
+/*--- internal routines ---*/
+private int 
+dviprt_read_S_cfg(dviprt_cfg_t *pcfg,dviprt_cfg_i *pinfo)
+{
+  FILE *ifp;
+  long intoff,stroff,codeoff;
+  int i,count;
+  uchar *pbuf,*rbuf;
+  int code;
+  char *ptype;
+  int n;
+  
+  if ((code = dviprt_setcfgbuffer_(pinfo,100,0)) < 0) return code;
+  dviprt_initcfg_(pcfg,pinfo);
+  
+  ifp = pinfo->file;
+  rbuf = pinfo->readbuf;
+  
+  if (fread(rbuf,20,1,ifp) < 1) {
+    dviprt_printcfgerror(pinfo,"Read error.\n",-1);
+  }
+  if (rbuf[17] != 0xff || rbuf[18] != 0xff) {
+  not_cfg:
+    dviprt_printcfgerror(pinfo,"This file does not seem *.CFG.\n",-1);
+    return CFG_ERROR_OTHER;
+  }
+  if (memcmp(rbuf,CFG_MAGIC_NUMBER,2))
+    goto not_cfg;
+  pcfg->version = rbuf[2] | ((uint)rbuf[3] << 8);
+  if (pcfg->version > CFG_VERSION) {
+    sprintf(dviprt_message_buffer,
+	    "This *.CFG file is too new version(ver.%u).\n",pcfg->version);
+    dviprt_printcfgerror(pinfo,dviprt_message_buffer,-1);
+    return CFG_ERROR_OTHER;
+  }
+  
+#define bytes2long(p) ((p)[0] | ((long)(p)[1]<<8) | \
+		       ((long)(p)[2]<<16) | ((long)(p)[3]<<24))
+  intoff = bytes2long(rbuf+4);
+  stroff = bytes2long(rbuf+8);
+  codeoff = bytes2long(rbuf+12);
+#undef bytes2long
+  
+  fseek(ifp,intoff,0);
+  count = fgetc(ifp);
+  fread(rbuf,count*3,1,ifp);
+  
+  pbuf = rbuf;
+  for (i=0;i<count;i++) {
+    n = pbuf[0];
+    if (n >= CFG_INTEGER_TYPE_COUNT) {
+      ptype = "integer";
+    unknown_no:
+      sprintf(dviprt_message_buffer,
+	      "Unknown %s type value No.%d is found.\n",ptype,n);
+      dviprt_printcfgerror(pinfo,dviprt_message_buffer,-1);
+      return CFG_ERROR_OTHER;
+    }
+    pcfg->integer[n] = pbuf[1] | ((uint)pbuf[2]<<8);
+    pbuf += 3;
+  }
+  
+  fseek(ifp,stroff,0);
+  count = fgetc(ifp);
+  pbuf = NULL;
+  for (i=0;i<count;i++) {
+    int l;
+    fread(rbuf,3,1,ifp);
+    n = rbuf[0];
+    l = rbuf[1] | ((uint)rbuf[2]<<8);
+    if (n >= CFG_STRINGS_TYPE_COUNT) {
+      ptype = "strings";
+      goto unknown_no;
+    }
+    if (pinfo->codebuf == NULL) {
+      pcfg->strings[n] = (uchar *)malloc(l+1);
+      if (pcfg->strings[n] == NULL) {
+      no_memory:
+        dviprt_printcfgerror(pinfo,"Memory exhausted.\n",-1);
+        return CFG_ERROR_MEMORY;
+      }
+    }
+    else {
+      pcfg->strings[n] = pinfo->pcodebuf;
+      pinfo->pcodebuf += (l+1);
+    }
+    fread(pcfg->strings[n],l,1,ifp);
+    *(pcfg->strings[n]+l) = 0;
+  }
+  
+  fseek(ifp,codeoff,0);
+  count = fgetc(ifp);
+  for (i=0;i<count;i++) {
+    int l;
+    fread(rbuf,3,1,ifp);
+    n = rbuf[0];
+    l = rbuf[1] | ((uint)rbuf[2]<<8);
+    
+    if (n >= CFG_PRTCODE_TYPE_COUNT) {
+      ptype = "printer code";
+      goto unknown_no;
+    }
+    if (pinfo->codebuf == NULL) {
+      pcfg->prtcode[n] = (uchar *)malloc(l+1);
+      if (pcfg->prtcode[n] == NULL)
+        goto no_memory;
+    }
+    else {
+      pcfg->prtcode[n] = pinfo->pcodebuf;
+      pinfo->pcodebuf += (l+1);
+    }
+    fread(pcfg->prtcode[n],l,1,ifp);
+    *(pcfg->prtcode[n]+l) = 0;
+    pcfg->prtcode_size[n] = l;
+  }
+  dviprt_resetcfgbuffer_(pinfo);
+  return 0;
+}
+
+private int 
+dviprt_read_QR_cfg(dviprt_cfg_t *pcfg,dviprt_cfg_i *pinfo)
+{
+#define	TYPE_BIT		0xc0
+  
+#define	NO_NUM			0
+#define	BINARY_LTOH		1
+#define	BINARY_HTOL		2
+#define	DECIMAL_3		3
+#define	DECIMAL_4		4
+#define	DECIMAL_5		5
+#define	DECIMAL_V		6
+  
+#define	TOTAL_BYTE		0x80
+#define	ISO_NUMBER		0x40
+#define	DIVIDEBY_2		0x10
+#define	DIVIDE_ALL		0x30
+#define	MULT_CONST		0x08
+  enum {
+    BIT_IMAGE_MODE,
+    NORML_MODE,
+    SEND_BIT_IMAGE,
+    SKIP_SPACES,
+    LINE_FEED,
+    FORM_FEED,
+    AFTER_BIT_IMAGE,
+    BIT_ROW_HEADER,
+  };
+  uchar *cfg_buf,*ptr;
+  int ch, type, f_cont, f_type, pos, i, j, k, lens;
+  int f_r_format;
+  long offset;
+  int old2new[] = {
+    CFG_BIT_IMAGE_MODE,
+    CFG_NORMAL_MODE,
+    CFG_SEND_BIT_IMAGE,
+    CFG_SKIP_SPACES,
+    CFG_LINE_FEED,
+    CFG_FORM_FEED,
+    CFG_AFTER_BIT_IMAGE,
+    CFG_BIT_ROW_HEADER,
+  };
+  
+  ch =dviprt_setcfgbuffer_(pinfo,300,TEMP_CODEBUF_SIZE);
+  if (ch < 0) return CFG_ERROR_MEMORY;
+  dviprt_initcfg_(pcfg,pinfo);
+  cfg_buf = pinfo->readbuf;
+  if (fread(cfg_buf,30,1,pinfo->file) < 1) {
+    dviprt_printcfgerror(pinfo,"Read error.\n",-1);
+  }
+  if (cfg_buf[16] == 'P') {
+    dviprt_printcfgerror(pinfo,"This is made by old version.\n",-1);
+    return CFG_ERROR_OTHER;
+  }
+  else if (cfg_buf[16] == 'Q')
+    f_r_format = 0;
+  else if (cfg_buf[16] == 'R')
+    f_r_format = 1;
+  else
+    f_r_format = -1;
+  if (f_r_format == -1 || cfg_buf[18] != 0xff) {
+    dviprt_printcfgerror(pinfo,"This is not the *.CFG file for dviprt.\n",-1);
+    return CFG_ERROR_OTHER;
+  }
+  cfg_buf[16] = '\0';
+  pcfg->version = 0;
+  if (pinfo->temp_codebuf_f) {
+    pcfg->strings[CFG_NAME] = malloc(strlen(cfg_buf)+1);
+    if (pcfg->strings[CFG_NAME] == NULL) {
+    no_memory:
+      dviprt_printcfgerror(pinfo,"Memory exhausted.\n",-1);
+      return CFG_ERROR_MEMORY;
+    }
+  }
+  else {
+    pcfg->strings[CFG_NAME] = pinfo->pcodebuf;
+    pinfo->pcodebuf += strlen(cfg_buf);
+    pinfo->pcodebuf++;
+  }
+  strcpy(pcfg->strings[CFG_NAME],cfg_buf);
+  
+  pcfg->integer[CFG_UPPER_POS] =
+    (cfg_buf[17] & (CFG_LEFT_IS_LOW|CFG_NON_MOVING));
+  pcfg->integer[CFG_ENCODE] =
+    (cfg_buf[17] & 0x10) ? CFG_ENCODE_HEX : CFG_ENCODE_NULL;
+  pcfg->integer[CFG_PINS] = ((uint) (cfg_buf[17]) & 0x0f);
+  
+  ptr = cfg_buf+23;
+  pcfg->integer[CFG_MINIMAL_UNIT] = (uint)ptr[0] | ((uint)ptr[1]<<8);
+  pcfg->integer[CFG_MAXIMAL_UNIT] = (uint)ptr[2] | ((uint)ptr[3]<<8);
+  pcfg->integer[CFG_DPI] =
+    f_r_format ? ((uint)ptr[4] | ((uint)ptr[5]<<8)) : 180;
+  if (cfg_buf[20])
+    pcfg->integer[CFG_CONSTANT] = cfg_buf[20];
+  offset = cfg_buf[19];
+  fseek(pinfo->file,offset,0);
+  
+  for (i = 0; i <= BIT_ROW_HEADER; i++) {
+    uchar *pstart,*plength;
+    uchar prev = 1;
+    if (pinfo->temp_codebuf_f) {
+      pinfo->pcodebuf = pinfo->codebuf;
+    }
+    pstart = pinfo->pcodebuf;
+    do {
+      lens = fgetc(pinfo->file);
+      if (lens == EOF) break;
+      fread(cfg_buf,lens+3,1,pinfo->file);
+      ptr = cfg_buf;
+      f_cont = *ptr++;
+      pos = *ptr++;
+      f_type = *ptr++;
+      type = f_type & 0x7;
+      
+      for (j = 0; j < lens; j++) {
+	ch = *ptr++;
+	if (pos == j && type != NO_NUM) {
+	  uchar *pfmt = pinfo->pcodebuf++;
+	  plength = pinfo->pcodebuf++;
+	  *pinfo->pcodebuf++ = CFG_VAL_DEFAULT;
+	  *plength = 1;
+	  j++;
+	  ptr++;
+	  switch (type) {
+	  case (BINARY_LTOH):
+	    *pfmt = CFG_FMT_BIT | CFG_FMT_BIN_LTOH | 2;
+	    break;
+	  case (BINARY_HTOL):
+	    *pfmt = CFG_FMT_BIT | CFG_FMT_BIN_HTOL | 2;
+	    break;
+	  case (DECIMAL_3):
+	    *pfmt = CFG_FMT_BIT | CFG_FMT_DECIMAL | 3;
+	    j++;
+	    ptr++;
+	    break;
+	  case (DECIMAL_4):
+	    *pfmt = CFG_FMT_BIT | CFG_FMT_DECIMAL | 4;
+	    j += 2;
+	    ptr += 2;
+	    break;
+	  case (DECIMAL_5):
+	    *pfmt = CFG_FMT_BIT | CFG_FMT_DECIMAL | 5;
+	    j += 3;
+	    ptr += 3;
+	    break;
+	  case (DECIMAL_V):
+	    *pfmt = CFG_FMT_BIT | CFG_FMT_DECIMAL;
+	    j++;
+	    ptr++;
+	    break;
+	  default:
+	    sprintf(dviprt_message_buffer,"Unknown format %02X",type);
+	    dviprt_printcfgerror(pinfo,dviprt_message_buffer,-1);
+	    goto ex_func;
+	  }
+	  if (f_type & TOTAL_BYTE) {
+	    *pinfo->pcodebuf++ = CFG_VAL_PINS_BYTE;
+	    *pinfo->pcodebuf++ = CFG_OP_MUL;
+	    (*plength) += 2;
+	  }
+	  if ((k = (f_type & DIVIDE_ALL)) != 0) {
+	    *pinfo->pcodebuf = 0;
+	    for (; k > 0; k -= DIVIDEBY_2) {
+	      (*pinfo->pcodebuf)++;
+	    }
+	    pinfo->pcodebuf++;
+	    *pinfo->pcodebuf++ = CFG_OP_SHR;
+	    (*plength) += 2;
+	  }
+	  if (f_type & ISO_NUMBER) {
+	    *pfmt |= CFG_FMT_ISO_BIT;
+	  }
+	  if (f_type & MULT_CONST) {
+	    *pinfo->pcodebuf++ = CFG_VAL_CONSTANT;
+	    *pinfo->pcodebuf++ = CFG_OP_MUL;
+	    (*plength) += 2;
+	  }
+	  prev = 1;
+	}
+	else {
+	  if (prev == 1 || *plength >= 127) {
+	    plength = pinfo->pcodebuf++;
+	    *plength = 0;
+	  }
+	  (*plength)++;
+	  *pinfo->pcodebuf++ = ch;
+	  prev = 0;
+	}
+      }
+    } while (f_cont & 0x80);
+    *pinfo->pcodebuf++ = 0;
+    { int n = old2new[i];
+      uint l = pinfo->pcodebuf-pstart;
+      pcfg->prtcode_size[n] = l - 1;
+      if (pinfo->temp_codebuf_f) { /* allocate buffer */
+     	pcfg->prtcode[n] = (uchar *)malloc(l);
+        if (pcfg->prtcode[n] == NULL)
+          goto no_memory;
+	memcpy(pcfg->prtcode[n],pstart,l);
+      }
+      else {
+	pcfg->prtcode[n] = pstart;
+      }
+    }
+  }
+ ex_func:
+  dviprt_resetcfgbuffer_(pinfo);
+  return 0;
+}
+/***** End of rcfg.c *****/
+
+
+/***** From rsrc.c *****/
+/* $Id$ */
+
+
+typedef struct {
+  char *name;
+  signed char type;
+  uchar no;
+  uchar spec_f;
+  uchar req_f;
+  char *info;
+} dviprt_cfg_item_t;
+
+typedef struct {
+  long min;
+  long max;
+} dviprt_cfg_limit_t;
+
+/*--- forward declarations ---*/
+private int dviprt_set_select
+  (dviprt_cfg_item_t *,uchar **,dviprt_cfg_t *,dviprt_cfg_i *);
+private int dviprt_set_integer
+  (dviprt_cfg_item_t *, uchar *, dviprt_cfg_t *,dviprt_cfg_i *);
+private int dviprt_set_strings
+  (dviprt_cfg_item_t *,uchar *,dviprt_cfg_t *,dviprt_cfg_i *);
+private int dviprt_set_rpexpr
+  (dviprt_cfg_item_t *,uchar *,int , dviprt_cfg_t *,dviprt_cfg_i *,int);
+private int dviprt_set_code
+  (dviprt_cfg_item_t *,uchar *,dviprt_cfg_t *,dviprt_cfg_i *);
+
+private long dviprt_oct2long(uchar *,uchar *,uchar **);
+private long dviprt_dec2long(uchar *,uchar *,uchar **);
+private long dviprt_hex2long(uchar *,uchar *,uchar **);
+     
+private int dviprt_printtokenerror(dviprt_cfg_i *,char *,int ,int);
+     
+/*--- macros ---*/
+#define strlcmp(tmplt,str,len) \
+  (!(strncmp(tmplt,str,(int)(len)) == 0 && (int)(len) == strlen(tmplt)))
+#define set_version(pcfg,v) ((pcfg)->version = MAX(v,(pcfg)->version))
+     
+enum {
+  ERROR_UNKNOWN_VALUE,ERROR_UNKNOWN_FORMAT,ERROR_UNKNOWN_ESCSEQ,
+  ERROR_OUTOFRANGE,
+  ERROR_INVALID_VALUE,
+  ERROR_COMPLICATED_EXPR,
+  ERROR_INCOMPLETE,
+};
+
+/*--- library functions ---*/
+int 
+dviprt_readsrc(char *fname,dviprt_cfg_t *pcfg,uchar *pcodebuf,int codebuf_s,
+    uchar *pworkbuf,int workbuf_s)
+{
+  dviprt_cfg_i info;
+  int code;
+  FILE *ifp;
+  dviprt_cfg_item_t *pitem;
+  int enc = CFG_ENCODE_NULL;
+  enum { T_INTEGER,T_STRINGS,T_CODE,T_SELECT,T_UPPERPOS};
+  static dviprt_cfg_limit_t pins_limit = { 8, 128 };
+  static dviprt_cfg_limit_t positive_limit = { 1, 0x7fff };
+  static dviprt_cfg_limit_t nonnegative_limit = { 0, 0x7fff};
+  static dviprt_cfg_item_t dviprt_items[] = {
+    {NULL,T_STRINGS,CFG_NAME,0,1,NULL},
+    {NULL,T_INTEGER,CFG_PINS,0,1,(char*)&pins_limit},
+    {NULL,T_INTEGER,CFG_MINIMAL_UNIT,0,0,(char*)&positive_limit},
+    {NULL,T_INTEGER,CFG_MAXIMAL_UNIT,0,0,(char*)&positive_limit},
+    {NULL,T_INTEGER,CFG_DPI,0,0,(char*)&positive_limit},
+    {NULL,T_INTEGER,CFG_CONSTANT,0,0,(char*)&nonnegative_limit},
+    {NULL,T_INTEGER,CFG_Y_DPI,0,0,(char*)&positive_limit},
+    {NULL,T_CODE,CFG_BIT_IMAGE_MODE,0,1,NULL},
+    {NULL,T_CODE,CFG_SEND_BIT_IMAGE,0,1,NULL},
+    {NULL,T_CODE,CFG_BIT_ROW_HEADER,0,0,NULL},
+    {NULL,T_CODE,CFG_AFTER_BIT_IMAGE,0,0,NULL},
+    {NULL,T_CODE,CFG_LINE_FEED,0,0,NULL},
+    {NULL,T_CODE,CFG_FORM_FEED,0,0,NULL},
+    {NULL,T_CODE,CFG_NORMAL_MODE,0,1,NULL},
+    {NULL,T_CODE,CFG_SKIP_SPACES,0,1,NULL},
+    {NULL,T_UPPERPOS,CFG_UPPER_POS,0,1,NULL},
+    {NULL,T_SELECT,CFG_ENCODE,0,0,(char*)dviprt_encodename},
+    {NULL,-1},
+  };
+  static dviprt_cfg_item_t encode_info = {
+    "encode",T_STRINGS,CFG_ENCODE_INFO,0,0,NULL
+    };
+  int prtcode_output_bytes[CFG_PRTCODE_TYPE_COUNT];
+  
+  info.line_no = -1;
+  info.fname = fname;
+  if (fname) {
+    info.file = fopen(fname,"r");
+    if (info.file == NULL) {
+      dviprt_printcfgerror(&info,"Cannot open.\n",-1);
+      return CFG_ERROR_FILE_OPEN;
+    }
+  }
+  else {
+    ifp = stdin;
+  }
+  ifp = info.file;
+  
+  info.codebuf = pcodebuf;
+  info.readbuf = pworkbuf;
+  info.codebuf_size = codebuf_s;
+  info.readbuf_size = workbuf_s;
+  /* allocate buffer */
+  if (dviprt_setcfgbuffer_(&info,TEMP_READBUF_SIZE,TEMP_CODEBUF_SIZE) < 0) {
+    fclose(info.file);
+    return CFG_ERROR_MEMORY;
+  }
+  
+  /* initialize */
+  dviprt_initcfg_(pcfg,&info);
+  for (pitem = dviprt_items;pitem->type>=0;pitem++) {
+    if (pitem->name == NULL) {
+      switch (pitem->type) {
+      case T_INTEGER:
+      case T_SELECT:
+      case T_UPPERPOS:
+        pitem->name = dviprt_integername[pitem->no];
+        break;
+      case T_STRINGS:
+        pitem->name = dviprt_stringsname[pitem->no];
+        break;
+      case T_CODE:
+        pitem->name = dviprt_prtcodename[pitem->no];
+        break;
+      }
+    }
+    pitem->spec_f = 0;
+  }
+  encode_info.spec_f = 0;
+  { int i;
+    for (i=0;i<CFG_PRTCODE_TYPE_COUNT;i++)
+      prtcode_output_bytes[i] = 0;
+  }
+  
+  pcfg->version = 1;
+  for ( ; ; ) {
+    uchar *pbuf = info.readbuf;
+    uchar *pchar;
+    
+    if (fgets(info.readbuf,info.readbuf_size,ifp) == NULL) break;
+    info.line_no++;
+    {
+      int len = strlen(pbuf);
+      if ((pbuf[0] < 'a' || pbuf[0] > 'z') && pbuf[0] != '_') {
+        while (pbuf[len-1] != '\n') {
+          if (fgets(info.readbuf,info.readbuf_size,ifp) == NULL)
+            goto end_scan;
+          len = strlen(pbuf);
+        }
+        continue;
+      }
+      if ( len > 0 && pbuf[len-1] == '\n')
+        pbuf[len-1] = 0;
+    }
+    while (*pbuf && *pbuf != ':') pbuf++;
+    if (*pbuf != ':') {
+      dviprt_printcfgerror(&info,"Character ':' is expected.\n",-1);
+      code = CFG_ERROR_SYNTAX;
+      goto end_process;
+    }
+    pchar = pbuf-1;
+    while (pchar >= info.readbuf && isspace(*pchar)) pchar--;
+    *++pchar = 0;
+    pbuf++;
+    for (pitem = dviprt_items;pitem->name;pitem++) {
+      if (strcmp(pitem->name,info.readbuf) == 0) break;
+    }
+    if (pitem->name == NULL) {
+      dviprt_printcfgerror(&info,"Unknown item `",-1);
+      dviprt_printmessage(info.readbuf,-1);
+      dviprt_printmessage("'.\n",-1);
+      code = CFG_ERROR_RANGE;
+      goto end_process;
+    }
+  parse_more:
+    while (*pbuf && isspace(*pbuf)) pbuf++;
+    if (pitem->spec_f) {
+      dviprt_printcfgerror(&info,NULL,0);
+      sprintf(dviprt_message_buffer,
+	      "Item `%s' is specified twice.\n",pitem->name);
+      dviprt_printmessage(dviprt_message_buffer,-1);
+      code = CFG_ERROR_SYNTAX;
+      goto end_process;
+    }
+    switch (pitem->type) {
+    case T_INTEGER:
+      if ((code = dviprt_set_integer(pitem,pbuf,pcfg,&info)) < 0)
+        goto end_process;
+      if (pitem->no == CFG_PINS) {
+        if (pcfg->integer[CFG_PINS] % 8) {
+          dviprt_printcfgerror(&info,"Value must be a multiple of 8.\n",-1);
+          code = CFG_ERROR_RANGE;
+          goto end_process;
+        }
+        pcfg->integer[CFG_PINS] /= 8;
+      }
+      break;
+    case T_STRINGS:
+      if (info.temp_codebuf_f)
+        info.pcodebuf = info.codebuf;
+      if ((code = dviprt_set_strings(pitem,pbuf,pcfg,&info)) < 0)
+    	goto end_process;
+      if (info.temp_codebuf_f) {
+        pcfg->strings[pitem->no] =
+          (uchar*)malloc(strlen(pcfg->strings[pitem->no])+1);
+        if (pcfg->strings[pitem->no] == NULL) {
+          goto no_more_memory;
+        }
+        strcpy(pcfg->strings[pitem->no],info.codebuf);
+      }
+      break;
+    case T_CODE:
+      if (info.temp_codebuf_f)
+        info.pcodebuf = info.codebuf;
+      if ((code = dviprt_set_code(pitem,pbuf,pcfg,&info)) < 0)
+        goto end_process;
+      prtcode_output_bytes[pitem->no] = code;
+      if (info.temp_codebuf_f) {
+        pcfg->prtcode[pitem->no] =
+          (uchar*)malloc(pcfg->prtcode_size[pitem->no]+1);
+        if (pcfg->prtcode[pitem->no] == NULL) {
+        no_more_memory:
+          dviprt_printcfgerror(&info,"Memory exhausted.\n",-1);
+          code = CFG_ERROR_MEMORY;
+          goto end_process;
+        }
+        memcpy(pcfg->prtcode[pitem->no],info.codebuf,
+	       pcfg->prtcode_size[pitem->no]+1);
+      }
+      break;
+    case T_SELECT:
+      if ((code = dviprt_set_select(pitem,&pbuf,pcfg,&info)) < 0)
+        goto end_process;
+      if (pitem->no == CFG_ENCODE) {
+        pitem = &encode_info;
+        goto parse_more;
+      }
+      break;
+    case T_UPPERPOS:
+      { uchar *ptmp;
+        uchar upos=0;
+        uchar opt = 0;
+        if (*pbuf == 0) {
+          dviprt_printcfgerror(&info,"No value.\n",-1);
+          code = CFG_ERROR_SYNTAX;
+          goto end_process;
+        }
+        while (*pbuf) {
+          ptmp = pbuf;
+          while (*ptmp && !isspace(*ptmp)) ptmp++;
+          if (strlcmp("HIGH_BIT",pbuf,ptmp-pbuf) == 0)
+            upos = CFG_TOP_IS_HIGH;
+          else if (strlcmp("LOW_BIT",pbuf,ptmp-pbuf) == 0)
+            upos = CFG_TOP_IS_LOW;
+          else if (strlcmp("LEFT_IS_HIGH",pbuf,ptmp-pbuf) == 0)
+            upos = CFG_LEFT_IS_HIGH;
+          else if (strlcmp("LEFT_IS_LOW",pbuf,ptmp-pbuf) == 0)
+            upos = CFG_LEFT_IS_LOW;
+          else if (strlcmp("NON_MOVING",pbuf,ptmp-pbuf) == 0)
+            opt = CFG_NON_MOVING;
+          else if (strlcmp("HEX_MODE",pbuf,ptmp-pbuf) == 0)
+            enc = CFG_ENCODE_HEX;
+          else {
+            dviprt_printtokenerror(&info,pbuf,(int)(ptmp-pbuf),ERROR_UNKNOWN_VALUE);
+            code = CFG_ERROR_RANGE;
+            goto end_process;
+          }
+          pbuf = ptmp;
+          while (*pbuf && isspace(*pbuf)) pbuf++;
+        }
+        pcfg->integer[CFG_UPPER_POS] = upos | opt;
+      }
+      break;
+    }
+    pitem->spec_f = 1;
+  }
+ end_scan:
+  
+  info.line_no = -1;
+  code = 0;
+  for (pitem = dviprt_items;pitem->name;pitem++) {
+    if (!pitem->spec_f && pitem->req_f) {
+      sprintf(dviprt_message_buffer,"%s not found.\n",pitem->name);
+      dviprt_printcfgerror(&info,dviprt_message_buffer,-1);
+      code++;
+    }
+  }
+  if (code) { code = CFG_ERROR_RANGE; goto end_process; }
+  
+  if (pcfg->prtcode[CFG_LINE_FEED] == NULL) {
+    if (info.temp_codebuf_f) {
+      pcfg->prtcode[CFG_LINE_FEED] = info.pcodebuf;
+      info.pcodebuf += 4;
+    }
+    else pcfg->prtcode[CFG_LINE_FEED] = (byte*)malloc(4);
+    memcpy(pcfg->prtcode[CFG_LINE_FEED],"\002\x0d\x0a\000",4);
+    pcfg->prtcode_size[CFG_LINE_FEED] = 3;
+  }
+  if (pcfg->prtcode[CFG_FORM_FEED] == NULL) {
+    if (info.temp_codebuf_f) {
+      pcfg->prtcode[CFG_FORM_FEED] = info.pcodebuf;
+      info.pcodebuf += 4;
+    }
+    else pcfg->prtcode[CFG_FORM_FEED] = (byte*)malloc(4);
+    memcpy(pcfg->prtcode[CFG_FORM_FEED],"\002\x0d\x0c\000",4);
+    pcfg->prtcode_size[CFG_FORM_FEED] = 3;
+  }
+  if (pcfg->integer[CFG_DPI] < 0 && pcfg->integer[CFG_Y_DPI] < 0) {
+    pcfg->integer[CFG_DPI] = 180;
+  }
+  else if (pcfg->integer[CFG_DPI] < 0 || pcfg->integer[CFG_Y_DPI] < 0) {
+    if (pcfg->integer[CFG_DPI] < 0)
+      pcfg->integer[CFG_DPI] = pcfg->integer[CFG_Y_DPI];
+    pcfg->integer[CFG_Y_DPI] = -1;
+  }
+  else if (pcfg->integer[CFG_DPI] == pcfg->integer[CFG_Y_DPI]) {
+    pcfg->integer[CFG_Y_DPI] = -1;
+  }
+  else if (pcfg->integer[CFG_Y_DPI] >= 0) { /* has y_dpi. */
+    set_version(pcfg,2);
+  }
+  if (pcfg->integer[CFG_ENCODE] < 0) {
+    pcfg->integer[CFG_ENCODE] = enc;
+  }
+  if (pcfg->integer[CFG_MAXIMAL_UNIT] < 0) {
+    pcfg->integer[CFG_MAXIMAL_UNIT] = 0x7fff;
+  }
+  if (pcfg->integer[CFG_MINIMAL_UNIT] < 0) {
+    uint v;
+    v = (MAX(prtcode_output_bytes[CFG_SEND_BIT_IMAGE],0) +
+         MAX(prtcode_output_bytes[CFG_AFTER_BIT_IMAGE],0) +
+         MAX(prtcode_output_bytes[CFG_SKIP_SPACES],0))
+      / (pcfg->integer[CFG_PINS]*8) +
+	MAX(prtcode_output_bytes[CFG_BIT_ROW_HEADER],0);
+    if (v == 0) v = 1;
+    pcfg->integer[CFG_MINIMAL_UNIT] = v;
+  }
+  
+  for (pitem = dviprt_items;pitem->type>=0;pitem++) {
+    if (pitem->spec_f == 0) {
+      sprintf(dviprt_message_buffer,": %s:",pitem->name);
+      switch (pitem->type) {
+      case T_INTEGER:
+        if (pcfg->integer[pitem->no] >= 0) {
+          uint v = pcfg->integer[pitem->no];
+          dviprt_printmessage(fname,-1);
+          dviprt_printmessage(dviprt_message_buffer,-1);
+          sprintf(dviprt_message_buffer," %d\n",v);
+          dviprt_printmessage(dviprt_message_buffer,-1);
+        }
+        break;
+      default: break; /* do nothing */
+      }
+    }
+  }
+  
+ end_process:
+  if (fname) fclose(ifp);
+  dviprt_resetcfgbuffer_(&info);
+  
+  return code;
+}
+
+/*--- internal routines ---*/
+private int 
+dviprt_set_integer(dviprt_cfg_item_t *pitem,uchar *buf,dviprt_cfg_t *pcfg,
+    dviprt_cfg_i *pinfo)
+{
+  uchar *pbuf = buf;
+  long v = 0;
+  long max = -1 ,min = -1;
+  
+  if (pitem->info != NULL) {
+    dviprt_cfg_limit_t *plimit = (dviprt_cfg_limit_t *)pitem->info;
+    min = plimit->min;
+    max = plimit->max;
+  }
+  if (min < 0) min = 0;
+  if (max < 0) max = 0xffff;
+  if (*pbuf == 0) {
+    dviprt_printcfgerror(pinfo,"No value.\n",-1);
+    return CFG_ERROR_SYNTAX;
+  }
+  while (*pbuf) {
+    if (!isdigit(*pbuf)) {
+      if (isspace(*pbuf)) break;
+      else goto invalid_val;
+    }
+    v = v*10 + *pbuf - '0';
+    if (v > max) {
+    out_of_range:
+      dviprt_printtokenerror(pinfo,buf,strlen(buf),ERROR_OUTOFRANGE);
+      dviprt_printcfgerror(pinfo,"",-1);
+      sprintf(dviprt_message_buffer,
+	      "(%u <= value <= %u).\n",(uint)min,(uint)max);
+      dviprt_printmessage(dviprt_message_buffer,-1);
+      return CFG_ERROR_RANGE;
+    }
+    pbuf++;
+  }
+  if (v < min) goto out_of_range;
+  
+  while (*pbuf) {
+    if (!isspace(*pbuf)) {
+    invalid_val:
+      dviprt_printtokenerror(pinfo,buf,strlen(buf),ERROR_INVALID_VALUE);
+      return CFG_ERROR_RANGE;
+    }
+    pbuf++;
+  }
+  pcfg->integer[pitem->no] = v;
+  
+  return 0;
+}
+
+private int 
+dviprt_set_strings(dviprt_cfg_item_t *pitem,uchar *buf,dviprt_cfg_t *pcfg,
+    dviprt_cfg_i *pinfo)
+{
+  uchar *pend;
+  long len;
+  pend = buf+strlen(buf)-1;
+  while (pend >= buf && isspace(*pend)) pend--;
+  pend++;
+  len = pend - buf;
+  if (len > 0x7fffL) {
+    dviprt_printcfgerror(pinfo,"Too long strings.\n",-1);
+    return CFG_ERROR_RANGE;
+  }
+  
+  pcfg->strings[pitem->no] = pinfo->pcodebuf;
+  strncpy(pinfo->pcodebuf,buf,(int)len);
+  pinfo->pcodebuf[len] = 0;
+  pinfo->pcodebuf += len;
+  pinfo->pcodebuf++;
+  return 0;
+}
+
+private int
+dviprt_set_select(dviprt_cfg_item_t *pitem,uchar **buf,dviprt_cfg_t *pcfg,
+    dviprt_cfg_i *pinfo)
+{
+  int i;
+  uchar *ptmp = *buf;
+  uchar *pstart = *buf;
+  uchar **opt;
+  if (*pstart == 0) {
+    dviprt_printcfgerror(pinfo,"No value.\n",-1);
+    return CFG_ERROR_SYNTAX;
+  }
+  while (*ptmp && !isspace(*ptmp)) ptmp++;
+  
+  for (i=0,opt=(uchar**)pitem->info;*opt;i++,opt++) {
+    if (strlcmp(*opt,pstart,ptmp-pstart) == 0) {
+      pcfg->integer[pitem->no] = i;
+      *buf = ptmp;
+      return 0;
+    }
+  }
+  dviprt_printtokenerror(pinfo,pstart,(int)(ptmp-pstart),ERROR_UNKNOWN_VALUE);
+  return CFG_ERROR_RANGE;
+}
+
+#define CFG_TOKEN_ERROR     -1
+#define CFG_TOKEN_LIMIT_BIT 0x100
+#define CFG_TOKEN_FMT       0x200
+
+private int 
+dviprt_get_codetype_token(dviprt_cfg_i *pinfo,uchar *pstart,uchar *pend,uchar *stopescseqchars,
+    uchar *limitchars)
+{
+  while (pstart < pend && isspace(*pstart)) pstart++;
+  if (pstart >= pend) {
+    pinfo->token = pinfo->endtoken = pstart;
+    return CFG_TOKEN_LIMIT_BIT;
+  }
+  else if (strchr(limitchars,*pstart)) {
+    pinfo->token = pstart;
+    pinfo->endtoken = pstart+1;
+    return CFG_TOKEN_LIMIT_BIT | *pstart;
+  }
+  else if (*pstart == '\\') {
+    int c;
+    long v;
+    uchar *pexpr,*pnext;
+    
+    pexpr = pinfo->token = pstart++;
+    while (pstart < pend && !isspace(*pstart) &&
+           *pstart != '\\' && !strchr(stopescseqchars,*pstart)) {
+      pstart++;
+    }
+    pinfo->endtoken = pstart;
+    if (pinfo->token + 1 == pinfo->endtoken) { /* '\\' only */
+      return '\\';
+    }
+    pexpr++;
+    if (pinfo->endtoken - pexpr == 1) {
+      if (isdigit(*pexpr)) goto parse_decimal_numb;
+      switch (*pexpr) {
+      case 't': c = '\t'; break; /* tab */
+      case 'v': c = '\v'; break; /* tab */
+      case 'n': c = '\n'; break; /* line feed */
+      case 'f': c = '\f'; break; /* form feed */
+      case 'r': c = '\r'; break; /* carrige return */
+      case 'e': c = 0x1b; break; /* escape code */
+      case 's': c = 0x20; break; /* space */
+      default:
+        dviprt_printtokenerror(pinfo,pinfo->token,2,ERROR_UNKNOWN_ESCSEQ);
+        return CFG_TOKEN_ERROR;
+      }
+      return c;
+    }
+    else if (strlcmp("SP",pexpr,pinfo->endtoken - pexpr) == 0)
+      return 0x20;
+    else if (strlcmp("ESC",pexpr,pinfo->endtoken - pexpr) == 0)
+      return 0x1b;
+    switch (*pexpr) {
+    case 'x':
+    case 'X':
+      v = dviprt_hex2long(pexpr+1,pinfo->endtoken,&pnext);
+    check_numb_range:
+      if (pstart != pnext) {
+        dviprt_printtokenerror(pinfo,pinfo->token,
+			       (int)(pinfo->endtoken - pinfo->token), ERROR_INVALID_VALUE);
+        return CFG_TOKEN_ERROR;
+      }
+      if (v >= 256) {
+        dviprt_printtokenerror(pinfo,pinfo->token,
+			       (int)(pinfo->endtoken - pinfo->token), ERROR_OUTOFRANGE);
+        return CFG_TOKEN_ERROR;
+      }
+      pinfo->endtoken = pnext;
+      return v;
+    case '0':
+      v = dviprt_oct2long(pexpr,pinfo->endtoken,&pnext);
+      goto check_numb_range;
+    case '1': case '2': case '3': case '4':
+    case '5': case '6': case '7': case '8': case '9':
+    parse_decimal_numb:
+      v = dviprt_dec2long(pexpr,pinfo->endtoken,&pnext);
+      goto check_numb_range;
+    default:
+      return CFG_TOKEN_FMT;
+    }
+  }
+  else {
+    pinfo->token = pstart;
+    pinfo->endtoken = pstart+1;
+    return *pstart;
+  }
+}
+
+private long 
+dviprt_dec2long(uchar *start,uchar *end,uchar **next)
+{
+  long v = 0;
+  while (start < end) {
+    int c = *start;
+    if (isdigit(c)) v = v*10 + c - '0';
+    else break;
+    start++;
+  }
+  *next = start;
+  return v;
+}
+
+private long 
+dviprt_oct2long(uchar *start,uchar *end,uchar **next)
+{
+  long v = 0;
+  while (start < end) {
+    int c = *start;
+    if (c >= '0' && c <= '7') v = v*8 + c - '0';
+    else break;
+    start++;
+  }
+  *next = start;
+  return v;
+}
+
+private long 
+dviprt_hex2long(uchar *start,uchar *end,uchar **next)
+{
+  long v = 0;
+  while (start < end) {
+    int c = *start;
+    if (isdigit(c)) v = v*16 + c - '0';
+    else if (c >= 'A' && c <= 'F') v = v*16 + c - 'A' + 10;
+    else if (c >= 'a' && c <= 'f') v = v*16 + c - 'a' + 10;
+    else break;
+    start++;
+  }
+  *next = start;
+  return v;
+}
+
+private int 
+dviprt_set_rpexpr(dviprt_cfg_item_t *pitem,uchar *pbuf,int len,dviprt_cfg_t *pcfg,
+    dviprt_cfg_i *pinfo,int sp)
+{
+  uchar *pend = pbuf + len;
+  uchar *plastop = NULL;
+  int code;
+  
+  /* get left expr */
+  while (pbuf < pend) {
+    int par_count = 0;
+    uchar *pcur = pbuf;
+    while (pcur < pend) {
+      if (*pcur == '(') par_count++;
+      else if (*pcur == ')') par_count--;
+      else if (!isdigit(*pcur) && !isalpha(*pcur) && par_count == 0) {
+        /* operator */
+        plastop = pcur;
+      }
+      pcur++;
+    }
+    if (par_count != 0) {
+      dviprt_printtokenerror(pinfo,pbuf,(int)(pend-pbuf),ERROR_INCOMPLETE);
+      return CFG_ERROR_SYNTAX;
+    }
+    if (plastop == NULL) {
+      if (*pbuf != '(') break;
+      pbuf++;
+      pend--;
+    }
+    else break;
+  }
+  
+  if (plastop == NULL) { /* no operator */
+    ulong v;
+    uchar *pdummy;
+    if (*pbuf == '0') {
+      uchar a,b,c;
+      v = dviprt_oct2long(pbuf,pend,&pdummy);
+    check_intval:
+      if (pdummy != pend) goto unknown_value;
+      if (v > 0xffff) {
+	dviprt_printtokenerror(pinfo,pbuf,(int)(pend-pbuf),ERROR_OUTOFRANGE);
+	return CFG_ERROR_RANGE;
+      }
+      a = v & 0x7f;
+      b = (v>>7) & 0x7f;
+      c = (v>>14) & 0x03;
+      if (c) {
+        *pinfo->pcodebuf++ = c;
+        *pinfo->pcodebuf++ = 14;
+        *pinfo->pcodebuf++ = CFG_OP_SHL;
+      }
+      if (b) {
+        *pinfo->pcodebuf++ = b;
+        *pinfo->pcodebuf++ = 7;
+        *pinfo->pcodebuf++ = CFG_OP_SHL;
+        if (c) *pinfo->pcodebuf++ = CFG_OP_OR;
+      }
+      if (a) {
+        *pinfo->pcodebuf++ = a;
+        if (b || c) *pinfo->pcodebuf++ = CFG_OP_OR;
+      }
+      code = 0;
+    }
+    else if (isdigit(*pbuf)) {
+      v = dviprt_dec2long(pbuf,pend,&pdummy);
+      goto check_intval;
+    }
+    else if (pend - pbuf > 1 && (*pbuf == 'x' || *pbuf == 'X')) {
+      v = dviprt_hex2long(pbuf+1,pend,&pdummy);
+      goto check_intval;
+    }
+    else if (pend - pbuf > 1) {
+    unknown_value:
+      dviprt_printtokenerror(pinfo,pbuf,(int)(pend-pbuf),ERROR_UNKNOWN_VALUE);
+      return CFG_ERROR_RANGE;
+    }
+    else {
+      switch (*pbuf) {
+      case 'd': v = CFG_VAL_DEFAULT;
+        if (pitem->no != CFG_SEND_BIT_IMAGE &&
+            pitem->no != CFG_BIT_ROW_HEADER &&
+            pitem->no != CFG_AFTER_BIT_IMAGE &&
+            pitem->no != CFG_SKIP_SPACES)
+          goto unavailable_value;
+        break;
+      case 'c': v = CFG_VAL_CONSTANT; break;
+      case 'w': v = CFG_VAL_WIDTH; break;
+      case 'h': v = CFG_VAL_HEIGHT; break;
+      case 'r': v = CFG_VAL_X_DPI; break;
+      case 'R': v = CFG_VAL_Y_DPI; break;
+      case 'p': v = CFG_VAL_PAGE; break;
+      case 'x': v = CFG_VAL_X_POS; break;
+      case 'y': v = CFG_VAL_Y_POS; break;
+      case 'v': v = CFG_VAL_PINS_BYTE; break;
+      case 's':
+        v = CFG_VAL_DATASIZE;
+        if (pitem->no != CFG_SEND_BIT_IMAGE &&
+            pitem->no != CFG_BIT_ROW_HEADER &&
+            pitem->no != CFG_AFTER_BIT_IMAGE) {
+        unavailable_value:
+          dviprt_printcfgerror(pinfo,"",-1);
+          sprintf(dviprt_message_buffer,"Variable `%c' in ",(int)*pbuf);
+          dviprt_printmessage(dviprt_message_buffer,-1);
+          dviprt_printmessage(pbuf,(int)(pend-pbuf));
+          sprintf(dviprt_message_buffer," cannot be used in %s.\n",pitem->name);
+          dviprt_printmessage(dviprt_message_buffer,-1);
+          return CFG_ERROR_RANGE;
+        }
+        break;
+      default:
+        goto unknown_value;
+      }
+      *pinfo->pcodebuf++ = v;
+      code = 0;
+    }
+  }
+  else { /* has operator */
+    uchar op;
+    
+    code = dviprt_set_rpexpr(pitem,pbuf,(int)(plastop-pbuf),pcfg,pinfo,sp+1);
+    if (code < 0) return code;
+    code = dviprt_set_rpexpr(pitem,plastop+1,(int)(pend-plastop-1),pcfg,pinfo,sp+2);
+    if (code < 0) return code;
+    
+    switch (*plastop) {
+    case '+': op = CFG_OP_ADD; break;
+    case '-': op = CFG_OP_SUB; break;
+    case '*': op = CFG_OP_MUL; break;
+    case '/': op = CFG_OP_DIV; break;
+    case '%': op = CFG_OP_MOD; break;
+    case '<': op = CFG_OP_SHL; break;
+    case '>': op = CFG_OP_SHR; break;
+    case '&': op = CFG_OP_AND; break;
+    case '|': op = CFG_OP_OR ; break;
+    case '^': op = CFG_OP_XOR; break;
+    default:
+      dviprt_printcfgerror(pinfo,NULL,0);
+      sprintf(dviprt_message_buffer,"Unknown operator %c in ",(int)*pbuf);
+      dviprt_printmessage(dviprt_message_buffer,-1);
+      dviprt_printmessage(pbuf,(int)(pend-pbuf));
+      dviprt_printmessage(".\n",-1);
+      return CFG_ERROR_SYNTAX;
+    }
+    *pinfo->pcodebuf++ = op;
+  }
+  
+  return code;
+}
+
+private int 
+dviprt_set_code(dviprt_cfg_item_t *pitem,uchar *buf,dviprt_cfg_t *pcfg,
+    dviprt_cfg_i *pinfo)
+{
+  long prev_line;
+  int prev_type = 1;
+  uchar *pcount;
+  uchar *pcode_begin;
+  uchar *rbuf;
+  int obytes = 0;
+  
+  prev_line = ftell(pinfo->file);
+  pcode_begin = pinfo->pcodebuf;
+  rbuf = pinfo->readbuf;
+  
+  for ( ; ; ) {
+    while (*buf) {
+      int c;
+      c = dviprt_get_codetype_token(pinfo,buf,buf+strlen(buf),",","");
+      if (c == CFG_TOKEN_LIMIT_BIT) break; /* no elements remain */
+      else if (c == CFG_TOKEN_ERROR) return CFG_ERROR_SYNTAX;
+      if ( c < 256) {        /* character code (raw data) */
+        if (prev_type) {
+        new_unit:
+          pcount = pinfo->pcodebuf++;
+          (*pcount) = 0;
+          prev_type = 0;
+        }
+        if (*pcount == 127) goto new_unit;
+        (*pcount)++;
+        *pinfo->pcodebuf++ = c;
+        buf = pinfo->endtoken;
+        obytes++;
+      }
+      else if (c == CFG_TOKEN_FMT) { /* format */
+        uchar *pexpr = pinfo->token;
+        int div=0,iso=0,mul=0,tl=0;
+        int cols=0;
+	int fmt;
+        uchar *plength;
+        uchar *pstart;
+        
+        buf = pinfo->token+1;
+        
+        /* formats */
+        switch (*buf) {
+        case 'b': fmt = CFG_FMT_BIN_LTOH; break;
+        case 'B': fmt = CFG_FMT_BIN_HTOL; break;
+        case 'H': fmt = CFG_FMT_HEX_UPPER; break;
+        case 'h': fmt = CFG_FMT_HEX_LOWER; break;
+        case 'd': fmt = CFG_FMT_DECIMAL; break;
+        case 'o': fmt = CFG_FMT_OCTAL; break;
+        case 's':
+          buf++;
+          if (*buf != 't') goto unknown_format;
+          fmt = CFG_FMT_STRINGS;
+          break;
+        default:
+        unknown_format:
+          dviprt_printtokenerror(pinfo,pexpr,(int)(pinfo->endtoken-pexpr),
+				 ERROR_UNKNOWN_FORMAT);
+          return CFG_ERROR_SYNTAX;
+        }
+        buf++;
+	
+        /* columns */
+        if (fmt == CFG_FMT_STRINGS) ;
+        else {
+          if (buf >= pinfo->endtoken) {
+            dviprt_printtokenerror(pinfo,pexpr,(int)(pinfo->token-pexpr),ERROR_INCOMPLETE);
+            return CFG_ERROR_SYNTAX;
+          }
+          
+          if (!(*buf >= '1' && *buf <= '7') && *buf != '?') {
+          invalid_cols:
+            dviprt_printtokenerror(pinfo,pexpr,(int)(pinfo->endtoken-pexpr),
+				   ERROR_UNKNOWN_FORMAT);
+            return CFG_ERROR_SYNTAX;
+          }
+          cols = (*buf == '?') ? 0 : *buf - '0';
+          if (cols == 0 &&
+              (fmt == CFG_FMT_BIN_LTOH || fmt == CFG_FMT_BIN_HTOL))
+            goto invalid_cols;
+	  
+          buf++;
+          obytes += (cols == 0) ? 5 : cols;
+        }
+        
+        /* additional format */
+        while (buf < pinfo->endtoken) {
+          switch (*buf) {
+          case 'D': div++; break;
+          case 'I': iso++; break;
+          case 'M': mul++; break;
+          case 'T': tl++; break;
+          default:
+            dviprt_printtokenerror(pinfo,pexpr,(int)(buf-pexpr),ERROR_UNKNOWN_FORMAT);
+            return CFG_ERROR_SYNTAX;
+          }
+          if (div > 3 || iso > 1 || mul > 1 || tl > 1) {
+            dviprt_printtokenerror(pinfo,pexpr,(int)(buf-pexpr),ERROR_UNKNOWN_FORMAT);
+            return CFG_ERROR_SYNTAX;
+          }
+          buf++;
+        }
+        *pinfo->pcodebuf++ =
+          CFG_FMT_BIT | fmt | (iso ? CFG_FMT_ISO_BIT : 0) | cols;
+        plength = pinfo->pcodebuf;
+        pinfo->pcodebuf++;
+        pstart = pinfo->pcodebuf;
+        
+        if (*buf == ',' && *(buf+1) != '\"') {
+	  int code;
+          buf++;
+          pinfo->token = buf;
+          while (*pinfo->token && *pinfo->token != ',' &&
+                 *pinfo->token != '\\' && !isspace(*pinfo->token))
+            pinfo->token++;
+	  if (pinfo->token == buf) {
+            dviprt_printcfgerror(pinfo,"No expression is specified in ",-1);
+            dviprt_printmessage(pexpr,(int)(buf-pexpr));
+            dviprt_printmessage(".\n",-1);
+            return CFG_ERROR_SYNTAX;
+          }
+          if ((code = dviprt_set_rpexpr(pitem,buf,(int)(pinfo->token-buf),pcfg,pinfo,0)) < 0)
+  	    return code;
+          buf = pinfo->token;
+        }
+        else {
+          *pinfo->pcodebuf++ = CFG_VAL_DEFAULT;
+        }
+        if (mul) {
+          *pinfo->pcodebuf++ = CFG_VAL_CONSTANT;
+          *pinfo->pcodebuf++ = CFG_OP_MUL;
+        }
+        if (tl) {
+          *pinfo->pcodebuf++ = CFG_VAL_PINS_BYTE;
+          *pinfo->pcodebuf++ = CFG_OP_MUL;
+        }
+        if (div) {
+          *pinfo->pcodebuf++ = div;
+          *pinfo->pcodebuf++ = CFG_OP_SHR;
+        }
+	{
+	  int length = pinfo->pcodebuf-pstart;
+	  if (length > 255) {
+	    dviprt_printtokenerror(pinfo,pexpr,(int)(buf-pexpr),ERROR_COMPLICATED_EXPR);
+	    return CFG_ERROR_RANGE;
+	  }
+	  *plength++ = length & 0xff;
+	}
+        if (fmt == CFG_FMT_STRINGS) {
+          uchar *pslen = pinfo->pcodebuf++;
+          int len;
+          if (strlen(buf) < 2 || *buf != ',' || *(buf+1) != '\"') {
+	    dviprt_printcfgerror(pinfo,"No strings specified in ",-1);
+	    dviprt_printmessage(pexpr,(int)(buf-pexpr));
+	    dviprt_printmessage(".\n",-1);
+            return CFG_ERROR_SYNTAX;
+          }
+          buf += 2;
+          for (len=0; ;len++) {
+            c = dviprt_get_codetype_token(pinfo,buf,buf+strlen(buf),"\"","\"");
+            if (c == CFG_TOKEN_ERROR) return CFG_ERROR_SYNTAX;
+            else if (c == CFG_TOKEN_FMT) {
+              dviprt_printcfgerror(pinfo,"The format ",-1);
+              dviprt_printmessage(pinfo->token,
+				  (int)(pinfo->endtoken-pinfo->token));
+              dviprt_printmessage(" cannot to be specified here.\n",-1);
+              return CFG_ERROR_SYNTAX;
+            }
+            else if (c & CFG_TOKEN_LIMIT_BIT) {
+              if ((c & 0xff) != '\"') {
+                dviprt_printcfgerror(pinfo,
+				     "Strings must be enclosed with "
+				     "double quotations (\").\n",-1);
+                return CFG_ERROR_SYNTAX;
+              }
+              buf = pinfo->endtoken;
+              break;
+            }
+            *pinfo->pcodebuf++ = c;
+            buf = pinfo->endtoken;
+          }
+          if (len > 255) {
+            dviprt_printcfgerror(pinfo,"Too long strings.\n",-1);
+            return CFG_ERROR_RANGE;
+          }
+	  *pslen = len;
+	}
+        prev_type = 1;
+      }
+      else {
+	dviprt_printcfgerror(pinfo,"Parse error. Unexpected token ",-1);
+	dviprt_printmessage(pinfo->token,(int)(pinfo->endtoken-pinfo->token));
+	dviprt_printmessage(".\n",-1);
+	return CFG_ERROR_SYNTAX;
+      }
+    }
+  next_line:
+    if (fgets(rbuf,pinfo->readbuf_size,pinfo->file) == NULL) break;
+    if (!isspace(rbuf[0]) && rbuf[0] != ';') {
+      fseek(pinfo->file,prev_line,0);
+      break;
+    }
+    prev_line = ftell(pinfo->file);
+    pinfo->line_no++;
+    buf = rbuf;
+    while (*buf && isspace(*buf)) buf++;
+    if (*buf == ';')
+      goto next_line; /* comment */
+    {
+      int len = strlen(rbuf);
+      if (len > 0 && rbuf[len-1] == '\n')
+        rbuf[len-1] = 0;
+    }
+  }
+  pcfg->prtcode[pitem->no] = pcode_begin;
+  pcfg->prtcode_size[pitem->no] = (pinfo->pcodebuf - pcode_begin) & 0xffff;
+  *pinfo->pcodebuf++ = 0;
+  return obytes;
+}
+
+private char *
+dviprt_src_errorno2message(int type)
+{
+  switch (type) {
+  case ERROR_OUTOFRANGE:
+    return "Out of range.\n";
+  case ERROR_UNKNOWN_VALUE:
+    return "Unknown value.\n";
+  case ERROR_UNKNOWN_ESCSEQ:
+    return "Unknown escape sequence.\n";
+  case ERROR_COMPLICATED_EXPR:
+    return "Too complicated expression.\n";
+  case ERROR_INCOMPLETE:
+    return "Incomplete specification.\n";
+  case ERROR_UNKNOWN_FORMAT:
+    return "Unknown format.\n";
+  case ERROR_INVALID_VALUE:
+    return "Invalid value.\n";
+  default:
+    return NULL;
+  }
+}
+
+private int 
+dviprt_printtokenerror(dviprt_cfg_i *pinfo,char *token,int len,int type)
+{
+  char *msg;
+  
+  dviprt_printcfgerror(pinfo,token,len);
+  dviprt_printmessage("\n",-1);
+  
+  if ((msg = dviprt_src_errorno2message(type)) != NULL)
+    dviprt_printcfgerror(pinfo,msg,-1);
+  return 0;
+}
+
+#undef strlcmp
+#undef set_version
+/***** End of rsrc.c *****/
+
+
+/***** From util.c *****/
+/* $Id$ */
+
+
+char *dviprt_integername[] = { CFG_INTEGER_NAME, NULL };
+char *dviprt_stringsname[] = { CFG_STRINGS_NAME, NULL };
+char *dviprt_prtcodename[] = { CFG_PRTCODE_NAME, NULL };
+char *dviprt_encodename[] = { CFG_ENCODE_NAME, NULL };
+
+#if 0
+private FILE *dviprt_messagestream = stderr;
+#else  /* patch for glibc 2.1.x by Shin Fukui <shita@april.co.jp> */
+private FILE *dviprt_messagestream;
+#endif
+
+/*--- library functions ---*/
+int
+dviprt_setmessagestream(FILE *fp)
+{
+  dviprt_messagestream = fp;
+  return 0;
+}
+
+/*--- internal routines ---*/
+liblocal int 
+dviprt_initcfg_(dviprt_cfg_t *pcfg,dviprt_cfg_i *pinfo)
+{
+  int i;
+  
+  for (i=0;i<CFG_INTEGER_TYPE_COUNT;i++)
+    pcfg->integer[i] = -1;
+  for (i=0;i<CFG_STRINGS_TYPE_COUNT;i++)
+    pcfg->strings[i] = NULL;
+  for (i=0;i<CFG_PRTCODE_TYPE_COUNT;i++) {
+    pcfg->prtcode[i] = NULL;
+    pcfg->prtcode_size[i] = 0;
+  }
+  pinfo->pcodebuf = pinfo->codebuf;
+  pinfo->line_no = 0;
+  return 0;
+}
+
+liblocal int 
+dviprt_setcfgbuffer_(dviprt_cfg_i *pinfo,int rsize,int csize)
+{
+  pinfo->temp_readbuf_f = pinfo->temp_codebuf_f = 0;
+  
+  if (pinfo->readbuf == NULL) {
+    pinfo->readbuf_size = rsize;
+    if (rsize>0) {
+      pinfo->temp_readbuf_f = 1;
+      pinfo->readbuf = (uchar *)malloc(rsize);
+      if (pinfo->readbuf == NULL) {
+      no_mem:
+        dviprt_printmessage(pinfo->fname,-1);
+        dviprt_printmessage("Memory exhausted.\n",-1);
+        return CFG_ERROR_MEMORY;
+      }
+    }
+  }
+  if (pinfo->codebuf == NULL) {
+    pinfo->codebuf_size = csize;
+    if (csize>0) {
+      pinfo->temp_codebuf_f = 1;
+      pinfo->codebuf = (uchar *)malloc(csize);
+      if (pinfo->codebuf == NULL) goto no_mem;
+    }
+  }
+  return 0;
+}
+
+liblocal int 
+dviprt_resetcfgbuffer_(dviprt_cfg_i *pinfo)
+{
+  if (pinfo->temp_readbuf_f) free(pinfo->readbuf);
+  if (pinfo->temp_codebuf_f) free(pinfo->codebuf);
+  pinfo->temp_codebuf_f = pinfo->temp_readbuf_f = 0;
+  return 0;
+}
+
+char dviprt_message_buffer[128];
+
+liblocal int
+dviprt_printmessage(char *str,int len)
+{
+  if (dviprt_messagestream && str) {
+    if (len >= 0) fwrite(str,len,1,dviprt_messagestream);
+    else fputs(str,dviprt_messagestream);
+    fflush(dviprt_messagestream);
+  }
+  return 0;
+}
+
+private int
+dviprt_printcfgerrorheader(dviprt_cfg_i *pinfo)
+{
+  if (pinfo) {
+    char *fn = pinfo->fname;
+    if (fn == NULL) fn = "-";
+    dviprt_printmessage(fn,-1);
+    dviprt_printmessage(": ",-1);
+    if (pinfo->line_no>0) {
+      sprintf(dviprt_message_buffer,"%d: ",pinfo->line_no);
+      dviprt_printmessage(dviprt_message_buffer,-1);
+    }
+  }
+  return 0;
+}
+
+liblocal int
+dviprt_printerror(char *msg,int len)
+{
+  dviprt_printmessage("*ERROR* ",-1);
+  dviprt_printmessage(msg,len);
+  return 0;
+}
+
+liblocal int 
+dviprt_printcfgerror(dviprt_cfg_i *pinfo,char *msg,int len)
+{
+  dviprt_printcfgerrorheader(pinfo);
+  dviprt_printerror(msg,len);
+  return 0;
+}
+
+liblocal int
+dviprt_printwarning(char *msg,int len)
+{
+  dviprt_printmessage("*WARNING* ",-1);
+  dviprt_printmessage(msg,len);
+  return 0;
+}
+
+liblocal int 
+dviprt_printcfgwarning(dviprt_cfg_i *pinfo,char *msg,int len)
+{
+  dviprt_printcfgerrorheader(pinfo);
+  dviprt_printwarning(msg,len);
+  return 0;
+}
+/***** End of util.c *****/
+
+
+/***** From print.c *****/
+/* $Id$ */
+
+
+/*--- forward declarations ---*/
+private int dviprt_getmaximalwidth(dviprt_print *);
+private int dviprt_flush_buffer(dviprt_print *,uchar far *);
+private int dviprt_output_transpose(dviprt_print *,uchar far *,uint);
+private int dviprt_output_nontranspose(dviprt_print *,uchar far *,uint);
+private int dviprt_output_nontranspose_reverse(dviprt_print *,uchar far *,uint);
+private int dviprt_reverse_bits(uchar far *,uint);
+private int dviprt_transpose8x8(uchar far *,uint, uchar far *,uint);
+private int dviprt_output_expr(dviprt_print *,int,uint,uint);
+private int dviprt_default_outputproc(uchar far *,long ,void *);
+private long dviprt_getbuffersize(dviprt_print *);
+     
+/*--- library functions ---*/
+long
+dviprt_initlibrary(dviprt_print *pprint,dviprt_cfg_t *pprt,uint width,uint height)
+{
+  dviprt_encoder *pencode;
+  uint pins = pprt->integer[CFG_PINS]*8;
+  
+  pprint->printer = pprt;
+  height += (pins-1);
+  height /= pins;
+  height *= pins;
+  pprint->bitmap_width = width; /* width by bytes */
+  pprint->bitmap_height = height;
+  pprint->buffer_width = MIN(width,pprt->integer[CFG_MAXIMAL_UNIT]);
+  pprint->page_count = 0;
+  pprint->output_bytes = 0;
+  pprint->tempbuffer_f = 0;
+  pencode = dviprt_getencoder_((int)pprt->integer[CFG_ENCODE]);
+  if (pencode == NULL) return CFG_ERROR_NOT_SUPPORTED;
+  pprint->encode_getbuffersize_proc = pencode->getworksize;
+  pprint->encode_encode_proc = pencode->encode;
+  
+  pprint->output_bytes = 0;
+  pprint->pstream = NULL;
+  pprint->output_proc = NULL;
+  
+  if (pprt->integer[CFG_UPPER_POS] & CFG_NON_TRANSPOSE_BIT) {
+    pprint->output_maximal_unit =
+      (pprt->integer[CFG_UPPER_POS] & CFG_REVERSE_BIT) ?
+	dviprt_output_nontranspose_reverse : dviprt_output_nontranspose;
+  }
+  else
+    pprint->output_maximal_unit = dviprt_output_transpose;
+  return dviprt_getbuffersize(pprint);
+}
+
+int
+  dviprt_setstream
+#ifdef __PROTOTYPES__
+  (dviprt_print *pprint,int (*func)(uchar far *,long ,void*),void *pstream)
+#else
+(pprint,func,pstream)
+dviprt_print *pprint;
+int (*func)();
+void *pstream;
+#endif
+{
+  if (pprint->page_count) {
+    int code = dviprt_output_expr(pprint,CFG_FORM_FEED,0,0);
+    if (code < 0) return code;
+    pprint->page_count = 0;
+  }
+  pprint->output_bytes = 0;
+  pprint->pstream = pstream;
+  pprint->output_proc = (func == NULL) ? dviprt_default_outputproc : func;
+  return 0;
+}
+
+int
+dviprt_setbuffer(dviprt_print *pprint,uchar far *buf)
+{
+  if (pprint->tempbuffer_f) {
+    BufferFree(pprint->encode_buffer);
+  }
+  pprint->tempbuffer_f = 0;
+  if (buf == NULL) {
+    long s = dviprt_getbuffersize(pprint);
+    if (s) {
+      buf = (uchar far *)BufferAlloc(s);
+      if (buf == NULL) return CFG_ERROR_MEMORY;
+      pprint->tempbuffer_f = 1;
+    }
+  }
+  pprint->encode_buffer = buf;
+  pprint->source_buffer =
+    buf + pprint->encode_getbuffersize_proc(pprint,dviprt_getmaximalwidth(pprint));
+  return 0;
+}
+
+int
+dviprt_beginpage(dviprt_print *pprint)
+{
+  int code;
+  pprint->device_x = pprint->device_y = 0;
+  pprint->bitmap_x = pprint->bitmap_y = 0;
+  if (pprint->page_count == 0) { /* bit_image_mode */
+    code = dviprt_output_expr(pprint,CFG_BIT_IMAGE_MODE,0,0);
+  }
+  else { /* form_feed */
+    code = dviprt_output_expr(pprint,CFG_FORM_FEED,0,0);
+  }
+  pprint->page_count++;
+  if (code < 0) return code;
+  return 0;
+}
+
+int
+dviprt_outputscanlines(dviprt_print *pprint,uchar far *fb)
+{
+  dviprt_cfg_t *pprt;
+  int code;
+  uint bw;
+  
+  pprt = pprint->printer;
+  bw = pprint->bitmap_width;
+  
+  if (pprt->prtcode_size[CFG_SKIP_SPACES] <= 0) {
+    pprint->bitmap_x = bw;
+    pprint->last_x = 0;
+  }
+  else {
+    uint uw,rw;
+    uint mu;
+    uint bx,lx;
+    uint pins = dviprt_getscanlines(pprint);
+    mu = pprt->integer[CFG_MINIMAL_UNIT];
+    bx = lx = 0;
+    
+    for (rw= bw; rw > 0 ;rw -= uw) {
+      uint x,y;
+      uchar far *in;
+      
+      uw = MIN(mu,rw);
+      in = fb + bx;
+      for (x = uw; x>0 ; x--) {
+        uchar far *test;
+        test = in;
+        for (y = pins ; y > 0 ;y--) {
+          if (*test) goto next_unit;
+          test += bw;
+        }
+        in++;
+      }
+      
+      if (bx > lx) {
+        pprint->bitmap_x = bx;
+        pprint->last_x = lx;
+        code = dviprt_flush_buffer(pprint,fb); /* output buffered unit */
+        if (code < 0) return code;
+        lx = pprint->last_x + uw;
+      }
+      else lx += uw;
+      
+    next_unit:
+      bx += uw;
+    }
+    pprint->bitmap_x = bx;
+    pprint->last_x = lx;
+  }
+  code = (pprint->last_x < pprint->bitmap_x) ? dviprt_flush_buffer(pprint,fb) : 0;
+  pprint->bitmap_y++;
+  return code;
+}
+
+int
+dviprt_endbitmap(dviprt_print *pprint)
+{
+  if (pprint->page_count) {
+    int code = dviprt_output_expr(pprint,CFG_NORMAL_MODE,0,0);
+    if (code < 0) return code;
+  }
+  return 0;
+}
+
+int
+dviprt_unsetbuffer(dviprt_print *pprint)
+{
+  if (pprint->tempbuffer_f) {
+    BufferFree(pprint->encode_buffer);
+    pprint->tempbuffer_f = 0;
+  }
+  return 0;
+}
+
+int
+dviprt_output(dviprt_print *pprint,uchar far *buf,long s)
+{
+  int c = pprint->output_proc(buf,s,pprint->pstream);
+  pprint->output_bytes += s;
+  return c;
+}
+
+/*--- internal routines ---*/
+private int
+dviprt_getmaximalwidth(dviprt_print *pprint)
+{
+  return MIN(pprint->printer->integer[CFG_MAXIMAL_UNIT],pprint->bitmap_width);
+}
+
+private long
+dviprt_getbuffersize(dviprt_print *pprint)
+{
+  long w = dviprt_getmaximalwidth(pprint);
+  long e = pprint->encode_getbuffersize_proc(pprint,w);
+  switch (pprint->printer->integer[CFG_UPPER_POS]
+	  & (CFG_NON_TRANSPOSE_BIT | CFG_REVERSE_BIT)) {
+  case CFG_LEFT_IS_HIGH:
+    return e;
+  default:
+    return w * dviprt_getscanlines(pprint) + e;
+  }
+}
+
+private int
+dviprt_flush_buffer(dviprt_print *pprint,uchar far *fb)
+{
+  dviprt_cfg_t *pprt;
+  int code;
+  
+  pprt = pprint->printer;
+  while (pprint->device_y < pprint->bitmap_y) { /* skip vertical spaces */
+    pprint->device_y++;
+    code = dviprt_output_expr(pprint,CFG_LINE_FEED,0,0);
+    pprint->device_x = 0;
+  }
+  while (pprint->last_x < pprint->bitmap_x) {
+    int w;
+    while (pprint->device_x < pprint->last_x) { /* skip horizontal spaces */
+      w = MIN(pprt->integer[CFG_MAXIMAL_UNIT],
+	      pprint->last_x - pprint->device_x);
+      code = dviprt_output_expr(pprint,CFG_SKIP_SPACES,w,0);
+      pprint->device_x += w;
+    }
+    w = MIN(pprt->integer[CFG_MAXIMAL_UNIT],pprint->bitmap_x-pprint->last_x);
+    code = pprint->output_maximal_unit(pprint,fb+pprint->last_x,w);
+    if (code < 0) return code;
+    pprint->last_x += w;
+    if (!(pprt->integer[CFG_UPPER_POS] & CFG_NON_MOVING))
+      pprint->device_x += w;
+  }
+  return 0;
+}
+
+private int
+dviprt_output_nontranspose(dviprt_print *pprint,uchar far *fb,uint width)
+{
+  int code;
+  uint dsize;
+  uint y;
+  uint pins;
+  
+  pins = dviprt_getscanlines(pprint);
+  
+  dsize = 0;
+  pprint->psource = fb;
+  for (y = pins ; y>0 ; y--) {
+    int dsize_line;
+    dsize_line = pprint->encode_encode_proc(pprint,(long)width,0);
+    if (dsize_line < 0) return dsize_line;
+    dsize += dsize_line;
+    pprint->psource += pprint->bitmap_width;
+  }
+  
+  code = dviprt_output_expr(pprint,CFG_SEND_BIT_IMAGE,width,dsize);
+  if (code < 0) return code;
+  
+  pprint->psource = fb;
+  for (y = pins ; y>0 ; y--) {
+    int dsize_line;
+    dsize_line = pprint->encode_encode_proc(pprint,(long)width,1);
+    code = dviprt_output_expr(pprint,CFG_BIT_ROW_HEADER,width,dsize_line);
+    if (code < 0) return code;
+    code = dviprt_output(pprint,pprint->poutput,dsize_line);
+    if (code < 0) return code;
+    pprint->psource += pprint->bitmap_width;
+  }
+  
+  code = dviprt_output_expr(pprint,CFG_AFTER_BIT_IMAGE,width,dsize);
+  if (code < 0) return code;
+  
+  return 0;
+}
+
+
+private int
+dviprt_output_nontranspose_reverse(dviprt_print *pprint,uchar far *fb,uint width)
+{
+  uchar far *psrc;
+  uchar far *pbuf;
+  int code;
+  uint src_size;
+  uint dsize;
+  uint y;
+  uint pins;
+  
+  pins = dviprt_getscanlines(pprint);
+  src_size = width * pins;
+  
+  psrc = pprint->source_buffer;
+  for (y = pins ; y > 0; y--) {
+    uint i;
+    pbuf = fb;
+    for (i=width;i>0;i--) *psrc++ = *pbuf++;
+    fb += pprint->bitmap_width;
+  }
+  
+  /* here, reverse bits */
+  psrc = pprint->source_buffer;
+  dviprt_reverse_bits(psrc,src_size);
+  
+  
+  dsize = 0;
+  pprint->psource = pprint->source_buffer;
+  for (y = pins ; y>0 ; y--) {
+    int dsize_line;
+    dsize_line = pprint->encode_encode_proc(pprint,(long)width,0);
+    if (dsize_line < 0) return dsize_line;
+    dsize += dsize_line;
+    pprint->psource += width;
+  }
+  
+  code = dviprt_output_expr(pprint,CFG_SEND_BIT_IMAGE,width,dsize);
+  if (code < 0) return code;
+  
+  pprint->psource = pprint->source_buffer;
+  for (y = pins ; y>0 ; y--) {
+    int dsize_line;
+    dsize_line = pprint->encode_encode_proc(pprint,(long)width,1);
+    code = dviprt_output_expr(pprint,CFG_BIT_ROW_HEADER,width,dsize_line);
+    if (code < 0) return code;
+    code = dviprt_output(pprint,pprint->poutput,dsize_line);
+    if (code < 0) return code;
+    pprint->psource += width;
+  }
+  
+  code = dviprt_output_expr(pprint,CFG_AFTER_BIT_IMAGE,width,dsize);
+  if (code < 0) return code;
+  
+  return 0;
+}
+
+private int
+dviprt_output_transpose(dviprt_print *pprint,uchar far *fb,uint width)
+{
+  uchar far *psrc;
+  uchar far *pbuf;
+  int code;
+  uint src_size;
+  uint dsize;
+  uint pins,pins8;
+  int y;
+  
+  pins8 = pprint->printer->integer[CFG_PINS];
+  pins = pins8 * 8;
+  src_size = width * pins;
+  psrc = pprint->source_buffer;
+  {
+    uchar far *pdst;
+    uint sskip;
+    sskip = pprint->bitmap_width * 8;
+    for (y = pins8-1; y >= 0 ; y--) {
+      uint i;
+      pbuf = fb;
+      pdst = psrc;
+      for (i=width;i>0;i--) {
+        dviprt_transpose8x8(pbuf,pprint->bitmap_width,pdst,pins8);
+        pbuf ++;
+        pdst += pins;
+      }
+      fb += sskip;
+      psrc++;
+    }
+  }
+  
+  psrc = pprint->source_buffer;
+  
+  /* here, reverse bits */
+  if (pprint->printer->integer[CFG_UPPER_POS] & CFG_REVERSE_BIT)
+    dviprt_reverse_bits(psrc,src_size);
+  
+  dsize = 0;
+  pprint->psource = pprint->source_buffer;
+  for (y = pins ; y>0 ; y--) {
+    int dsize_line;
+    dsize_line = pprint->encode_encode_proc(pprint,(long)width,0);
+    if (dsize_line < 0) return dsize_line;
+    dsize += dsize_line;
+    pprint->psource += width;
+  }
+  
+  code = dviprt_output_expr(pprint,CFG_SEND_BIT_IMAGE,width,dsize);
+  if (code < 0) return code;
+  
+  pprint->psource = pprint->source_buffer;
+  for (y = pins ; y>0 ; y--) {
+    uint dsize_line;
+    dsize_line = pprint->encode_encode_proc(pprint,(long)width,1);
+    code = dviprt_output(pprint,pprint->poutput,dsize_line);
+    if (code < 0) return code;
+    pprint->psource += width;
+  }
+  
+  code = dviprt_output_expr(pprint,CFG_AFTER_BIT_IMAGE,width,dsize);
+  if (code < 0) return code;
+  
+  return 0;
+}
+
+private int
+dviprt_transpose8x8(uchar far *inp,uint line_size,uchar far *outp,uint dist)
+{
+  register uint ae, bf, cg, dh;
+  {
+    uchar far *ptr4 = inp + (line_size << 2);
+    ae = ((uint)*inp << 8) + *ptr4;
+    inp += line_size, ptr4 += line_size;
+    bf = ((uint)*inp << 8) + *ptr4;
+    inp += line_size, ptr4 += line_size;
+    cg = ((uint)*inp << 8) + *ptr4;
+    inp += line_size, ptr4 += line_size;
+    dh = ((uint)*inp << 8) + *ptr4;
+  }
+  /* Check for all 8 bytes being the same. */
+  /* This is especially worth doing for the case where all are zero. */
+  if ( ae == bf && ae == cg && ae == dh && (ae >> 8) == (ae & 0xff) ) {
+    if ( ae == 0 ) goto store;
+    *outp = -((ae >> 7) & 1);
+    outp += dist;
+    *outp = -((ae >> 6) & 1);
+    outp += dist;
+    *outp = -((ae >> 5) & 1);
+    outp += dist;
+    *outp = -((ae >> 4) & 1);
+    outp += dist;
+    *outp = -((ae >> 3) & 1);
+    outp += dist;
+    *outp = -((ae >> 2) & 1);
+    outp += dist;
+    *outp = -((ae >> 1) & 1);
+    outp += dist;
+    *outp = -(ae & 1);
+  }
+  else {
+    register uint temp;
+    
+    /* Transpose a block of bits between registers. */
+#define transpose(r,s,mask,shift)\
+    r ^= (temp = ((s >> shift) ^ r) & mask);\
+      s ^= temp << shift
+	
+	/* Transpose blocks of 4 x 4 */
+#define transpose4(r) transpose(r,r,0x00f0,4)
+	transpose4(ae);
+    transpose4(bf);
+    transpose4(cg);
+    transpose4(dh);
+    
+    /* Transpose blocks of 2 x 2 */
+    transpose(ae, cg, 0x3333, 2);
+    transpose(bf, dh, 0x3333, 2);
+    
+    /* Transpose blocks of 1 x 1 */
+    transpose(ae, bf, 0x5555, 1);
+    transpose(cg, dh, 0x5555, 1);
+    
+  store:	*outp = ae >> 8;
+    outp += dist;
+    *outp = bf >> 8;
+    outp += dist;
+    *outp = cg >> 8;
+    outp += dist;
+    *outp = dh >> 8;
+    outp += dist;
+    *outp = (uchar)ae;
+    outp += dist;
+    *outp = (uchar)bf;
+    outp += dist;
+    *outp = (uchar)cg;
+    outp += dist;
+    *outp = (uchar)dh;
+  }
+  return 0;
+}
+
+private int
+dviprt_reverse_bits(uchar far *buf,uint s)
+{
+  static uchar rev[256] = {
+    0x00, 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0, 
+    0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0, 
+    0x08, 0x88, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8, 
+    0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8, 
+    0x04, 0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4, 
+    0x14, 0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4, 
+    0x0c, 0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c, 0xec, 
+    0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc, 
+    0x02, 0x82, 0x42, 0xc2, 0x22, 0xa2, 0x62, 0xe2, 
+    0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2, 
+    0x0a, 0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a, 0xea, 
+    0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa, 
+    0x06, 0x86, 0x46, 0xc6, 0x26, 0xa6, 0x66, 0xe6, 
+    0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6, 
+    0x0e, 0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee, 
+    0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe, 
+    0x01, 0x81, 0x41, 0xc1, 0x21, 0xa1, 0x61, 0xe1, 
+    0x11, 0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1, 
+    0x09, 0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9, 
+    0x19, 0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9, 
+    0x05, 0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5, 
+    0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5, 
+    0x0d, 0x8d, 0x4d, 0xcd, 0x2d, 0xad, 0x6d, 0xed, 
+    0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd, 
+    0x03, 0x83, 0x43, 0xc3, 0x23, 0xa3, 0x63, 0xe3, 
+    0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3, 
+    0x0b, 0x8b, 0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb, 
+    0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb, 
+    0x07, 0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67, 0xe7, 
+    0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7, 
+    0x0f, 0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef, 
+    0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff, 
+  };
+  while (s-- > 0) {
+    *buf = rev[*buf];
+    buf++;
+  }
+  return 0;
+}
+
+
+private int
+dviprt_output_expr(dviprt_print *pprint,int numb,uint width,uint dsize)
+{
+  uchar *pcode;
+  dviprt_cfg_t *pprt;
+  uint v;
+  uint len;
+  
+  pprt = pprint->printer;
+  if (pprt->prtcode[numb] == NULL) return 0;
+  pcode = pprt->prtcode[numb];
+  len = pprt->prtcode_size[numb];
+  
+  while (*pcode && len>0) {
+    if (*pcode & CFG_FMT_BIT) {
+      uint stack[CFG_STACK_DEPTH];
+      int stack_p = -1;
+      uchar fmt = *pcode++;
+      uint l = *pcode++;
+      len -=2;
+      while (l>0) {
+        if ((*pcode & CFG_EXPR_TYPE_BIT) == CFG_OP) {
+          uint v2 = stack[stack_p--];
+          v = stack[stack_p--];
+          switch (*pcode) {
+          case CFG_OP_ADD: v += v2; break;
+          case CFG_OP_SUB: v -= v2; break;
+          case CFG_OP_MUL: v *= v2; break;
+          case CFG_OP_DIV:
+            if (v2 == 0) { /* divided by zero. */
+            div_by_zero:
+              return CFG_ERROR_DIV0;
+            }
+            v /= v2;
+            break;
+          case CFG_OP_MOD:
+            if (v2 == 0) goto div_by_zero;
+            v %= v2;
+            break;
+          case CFG_OP_SHL: v <<= v2; break;
+          case CFG_OP_SHR: v >>= v2; break;
+          case CFG_OP_AND: v &= v2; break;
+          case CFG_OP_OR : v |= v2; break;
+          case CFG_OP_XOR: v ^= v2; break;
+          default:
+            ;
+          }
+          stack[++stack_p] = v;
+        }
+        else if ((*pcode & CFG_EXPR_TYPE_BIT) == CFG_VAL) {
+          {
+            switch (*pcode) {
+            case CFG_VAL_DEFAULT: v = width*8; break;
+            case CFG_VAL_CONSTANT: v = pprt->integer[CFG_CONSTANT]; break;
+            case CFG_VAL_WIDTH: v = pprint->bitmap_width*8; break;
+            case CFG_VAL_HEIGHT: v = pprint->bitmap_height; break;
+            case CFG_VAL_PAGE:
+            case CFG_VAL_PAGECOUNT: v = pprint->page_count; break;
+            case CFG_VAL_DATASIZE: v = dsize; break;
+            case CFG_VAL_X_DPI: v = (int)pprt->integer[CFG_DPI]; break;
+            case CFG_VAL_Y_DPI:
+              v = pprt->integer[CFG_Y_DPI] > 0 ?
+		pprt->integer[CFG_Y_DPI] : pprt->integer[CFG_DPI];
+              break;
+            case CFG_VAL_PINS_BYTE: v = pprt->integer[CFG_PINS]; break;
+            case CFG_VAL_X_POS: v = pprint->device_x*8; break;
+            case CFG_VAL_Y_POS:
+              v = pprint->device_y * dviprt_getscanlines(pprint);
+              break;
+            }
+          }
+          stack[++stack_p] = v;
+        }
+        else {
+          stack[++stack_p] = *pcode;
+        }
+        l--; pcode++; len--;
+      }
+      v = stack[stack_p];
+      if ((fmt & CFG_FMT_FORMAT_BIT) == CFG_FMT_STRINGS) {
+        uint l = *pcode++;
+        len--;
+        while (v-- > 0)
+          dviprt_output(pprint,(uchar far *)pcode,l);
+        pcode += l;
+        len -= l;
+      }
+      else if ((fmt & CFG_FMT_FORMAT_BIT) == CFG_FMT_ASSIGNMENT) {
+        pprint->uservar[fmt&0x0f] = v;
+      }
+      else { uchar valbuf[10];
+	     int cols = fmt & CFG_FMT_COLUMN_BIT;
+	     int i;
+	     
+	     switch (fmt & CFG_FMT_FORMAT_BIT) {
+	     case CFG_FMT_BIN_LTOH:
+	       for (i=0;i<cols;i++) {
+		 valbuf[i] = v&0xff;
+		 v >>= 8;
+	       }
+	       break;
+	     case CFG_FMT_BIN_HTOL:
+	       for (i=cols-1;i>=0;i--) {
+		 valbuf[i] = v&0xff;
+		 v >>= 8;
+	       }
+	       break;
+	     default:
+	       { char *f;
+		 char fmtbuf[10];
+		 switch(fmt & CFG_FMT_FORMAT_BIT) {
+		 case CFG_FMT_HEX_UPPER: f = "X"; break;
+		 case CFG_FMT_HEX_LOWER: f = "x"; break;
+		 case CFG_FMT_DECIMAL: f = "u"; break;
+		 case CFG_FMT_OCTAL: f = "o"; break;
+		 }
+		 if (cols == 0)
+		   strcpy(fmtbuf,"%");
+		 else
+		   sprintf(fmtbuf,"%%0%d",cols);
+		 strcat(fmtbuf,f);
+		 sprintf(valbuf,fmtbuf,stack[stack_p]);
+		 cols = strlen(valbuf);
+		 if (fmt & CFG_FMT_ISO_BIT)
+		   valbuf[cols-1] |= 0x10;
+	       }
+	       break;
+	     }
+	     dviprt_output(pprint,(uchar far *)valbuf, cols);
+	   }
+    }
+    else {
+      uint l = *pcode++;
+      len--;
+      dviprt_output(pprint,(uchar far *)pcode,l);
+      pcode += l;
+      len -= l;
+    }
+  }
+  return 0;
+}
+
+private int
+dviprt_default_outputproc(uchar far *buf,long s,void *fp)
+{
+#ifdef __MSDOS_REAL__
+  while (s-- > 0) {
+    if (fputc(*buf++,fp) == EOF)
+      return CFG_ERROR_OUTPUT;
+  }
+  return 0;
+#else
+  return fwrite(buf,s,1,fp) == 1 ? 0 : CFG_ERROR_OUTPUT;
+#endif
+}
+/***** End of print.c *****/
+
+
+/***** From encode.c *****/
+/* $Id$ */
+
+
+#define DVIPRT_SUPPORT_FAX 1
+#define DVIPRT_SUPPORT_PCL 1
+
+/*--- forward declarations ---*/
+private long dviprt_null_getworksize(dviprt_print *,long );
+private long dviprt_null_encode(dviprt_print *,long ,int );
+private long dviprt_hex_getworksize(dviprt_print *,long );
+private long dviprt_hex_encode(dviprt_print *,long ,int );
+#if DVIPRT_SUPPORT_FAX
+private long dviprt_fax_getworksize(dviprt_print *,long );
+private long dviprt_fax_encode(dviprt_print *,long ,int );
+#endif
+#if DVIPRT_SUPPORT_PCL
+private long dviprt_pcl1_getworksize(dviprt_print *,long );
+private long dviprt_pcl1_encode(dviprt_print *,long ,int );
+private long dviprt_pcl2_getworksize(dviprt_print *,long );
+private long dviprt_pcl2_encode(dviprt_print *,long ,int );
+#endif
+     
+private dviprt_encoder dviprt_encoder_list[] = {
+  { CFG_ENCODE_NULL, dviprt_null_getworksize,dviprt_null_encode},
+  { CFG_ENCODE_HEX, dviprt_hex_getworksize,dviprt_hex_encode},
+#if DVIPRT_SUPPORT_FAX
+  { CFG_ENCODE_FAX, dviprt_fax_getworksize,dviprt_fax_encode},
+#endif
+#if DVIPRT_SUPPORT_PCL
+  { CFG_ENCODE_PCL1, dviprt_pcl1_getworksize,dviprt_pcl1_encode},
+  { CFG_ENCODE_PCL2, dviprt_pcl2_getworksize,dviprt_pcl2_encode},
+#endif
+  { -1 },
+};
+
+/*--- internal routines ---*/
+/* The users MUST NOT USE these functions */
+liblocal dviprt_encoder *
+dviprt_getencoder_(int no)
+{
+  int i;
+  for (i=0;dviprt_encoder_list[i].no >= 0;i++)
+    if (no == dviprt_encoder_list[i].no)
+      return dviprt_encoder_list+i;
+  return NULL;
+}
+
+private long 
+dviprt_null_getworksize(dviprt_print *pprint,long s)
+{
+  return 0;
+}
+private long 
+dviprt_null_encode(dviprt_print *pprint,long s,int f)
+{
+  pprint->poutput = pprint->psource;
+  return s;
+}
+
+private long 
+dviprt_hex_getworksize(dviprt_print *pprint,long s)
+{
+  return s*2;
+}
+private long 
+dviprt_hex_encode(dviprt_print *pprint,long s,int f)
+{
+  if (f) {
+    uchar far *w;
+    uchar far *buf;
+    static uchar hex[] = "0123456789ABCDEF";
+    int i=s;
+    w = pprint->poutput = pprint->encode_buffer;
+    buf = pprint->psource;
+    while (i-->0) {
+      *w++ = hex[(*buf>>4)&0x0f];
+      *w++ = hex[*buf&0x0f];
+      buf++;
+    }
+  }
+  return s*2;
+}
+
+#if DVIPRT_SUPPORT_PCL
+private long
+dviprt_pcl1_getworksize(dviprt_print *pprint,long s)
+{
+  return s*2;
+}
+private long 
+dviprt_pcl1_encode(dviprt_print *pprint,long s,int f)
+{
+  uchar far *src;
+  uchar far *end;
+  uchar far *out;
+  long total = 0;
+  
+  src = pprint->psource;
+  end = src + s;
+  out = pprint->poutput = pprint->encode_buffer;
+  
+  while ( src < end  ) {
+    uchar test = *src++;
+    uchar far *run = src;
+    while ( src < end && *src == test ) src++;
+    if (f) {
+      while ( src - run > 255 ) {
+        *out++ = 255;
+        *out++ = test;
+        total += 2;
+        run += 256;
+      }
+      *out++ = src - run;
+      *out++ = test;
+      total += 2;
+    }
+    else {
+      total += (((src-run)/255 + ((src-run)%255) ? 1 : 0)) * 2;
+    }
+  }
+  return total;
+}
+
+private long 
+dviprt_pcl2_getworksize(dviprt_print *pprint,long s)
+{
+  return s + s/127 + 1;
+}
+private long 
+dviprt_pcl2_encode(dviprt_print *pprint,long s,int f)
+{
+  uchar far *exam;
+  uchar far *cptr;
+  uchar far *end;
+  uchar far *src;
+  long total = 0;
+  
+  src = pprint->psource;
+  exam = src;
+  cptr = pprint->poutput = pprint->encode_buffer;
+  end = exam + s;
+  
+  for ( ; ; ) {
+    uchar test = *exam++;
+    int len;
+    while ((test != *exam) && (exam < end))
+      test = *exam++;
+    if (exam < end) exam--;
+    len = exam - src;
+    if (f) {
+      while (len > 0){
+        int i;
+        int count = len;
+        if (count>127) count=127;
+        *cptr++=count-1;
+        for (i = 0 ; i < count ; i++) *cptr++ = *src++;
+        len -= count;
+        total += (count+1);
+      }
+    }
+    else {
+      total += len + ((len/127)+(len%127 ? 1 : 0));
+    }
+    if (exam >= end) break;
+    exam++;
+    while ((test == *exam) && (exam < end))
+      exam++;
+    len = exam - src;
+    if (f) {
+      while (len > 0) {
+        int count = len;
+        if (count > 127) count = 127;
+        *cptr++ = (257-count);
+        *cptr++ = test;
+        len -= count;
+        total += 2;
+      }
+    }
+    else {
+      total += ((len/127 + (len%127) ? 1 : 0)) * 2;
+    }
+    if (exam >= end) break;
+    src = exam;
+  }
+  return total;
+}
+#endif /* DVIPRT_SUPPORT_PCL */
+
+#if DVIPRT_SUPPORT_FAX
+private long 
+dviprt_fax_getworksize(dviprt_print *pprint,long s)
+{
+  long size = s * 8 + 7;
+  return MAX(size*2/9+4,size/8) * dviprt_getscanlines(pprint) + 1;
+}
+
+#define MAX_FAX_WIDTH	2623
+typedef struct {
+  int	data;
+  int	length;
+} FaxEncode_t;
+typedef struct {
+  uchar i_bitbuf;
+  uchar far *i_buf;
+  int i_count;
+  
+  uchar o_bitbuf;
+  uchar far *o_buf;
+  int o_count;
+  int o_bufcount;
+} FaxEncodeInfo;
+private int dviprt_fax_set_white(int,FaxEncodeInfo *);
+private int dviprt_fax_set_black(int,FaxEncodeInfo *);
+private int dviprt_fax_set_bitcount(FaxEncode_t *,FaxEncodeInfo *);
+     
+private long 
+dviprt_fax_encode(dviprt_print *pprint,long s,int f)
+{
+  static FaxEncode_t eol_code = {0x800,12};
+  int allruns = 0;
+  int width = s * 8;
+  int top_bit_count = 8;
+  FaxEncodeInfo info;
+  uchar far *src_end;
+  uchar recover;
+  
+  src_end = pprint->psource + s;
+  recover = *src_end;
+  *src_end = 0xaa;
+  
+  /* initializing */
+  info.i_buf = pprint->psource;
+  info.i_bitbuf = *info.i_buf++;
+  info.i_count = 8;
+  info.o_buf = pprint->poutput = pprint->encode_buffer;
+  info.o_bitbuf = 0;
+  info.o_count = 8;
+  info.o_bufcount = 0;
+  
+  dviprt_fax_set_bitcount(&eol_code,&info);
+  
+  for(;;){
+    static uchar ROW[9] =
+      {0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80};
+    static uchar MASK[9] =
+      {0x00, 0x01, 0x03, 0x07, 0x0f, 0x1f, 0x3f, 0x7f, 0xff};
+    int white_run_length;
+    int black_run_length;
+    
+    /* count run-length */
+    /* remaining bits in the current byte are white? */
+    if (!(info.i_bitbuf &= MASK[info.i_count])){
+      do{
+	top_bit_count += 8; /* next byte is also white	*/
+      } while(!(info.i_bitbuf = *info.i_buf++));
+      info.i_count = 8;
+    }
+    /* current byte contains white and black bits 	*/
+    while(!(info.i_bitbuf & ROW[info.i_count]))
+      info.i_count--;		/* skip white bits 	*/
+    white_run_length = top_bit_count - (black_run_length = info.i_count);
+    
+    /* remaining bits in the current byte are black?	*/
+    if (info.i_bitbuf == MASK[info.i_count]){
+      do{
+	black_run_length += 8;
+	/* next byte is also black	*/
+      } while((info.i_bitbuf = *info.i_buf++) == 0xff);
+      info.i_count = 8;
+    }
+    else info.i_count--;	/* skip the top black bit	*/
+    
+    /* current byte contains white and black bits 	*/
+    while(info.i_bitbuf & ROW[info.i_count])
+      info.i_count--;		/* skip black bits	 		*/
+    black_run_length -= (top_bit_count = info.i_count);
+    
+    /* output */
+    if((allruns += white_run_length) < width)
+      dviprt_fax_set_white(white_run_length,&info);
+    else{
+      dviprt_fax_set_white(white_run_length + width - allruns,&info);
+      break;
+    }
+    if((allruns += black_run_length) < width)
+      dviprt_fax_set_black(black_run_length,&info);
+    else{
+      dviprt_fax_set_black(black_run_length + width - allruns,&info);
+      break;
+    }
+  }
+  
+  info.o_bufcount++;
+  if (info.o_count < 8)
+    *info.o_buf++ = info.o_bitbuf;
+  else
+    *info.o_buf++ = 0;
+  *src_end = recover;
+  
+  return info.o_bufcount;
+}
+
+private int 
+dviprt_fax_set_bitcount(FaxEncode_t *pt,FaxEncodeInfo *info)
+{
+  int	data, length;
+  
+  data = pt->data;
+  length = pt->length;
+  while( (length -= info->o_count) >= 0 ){
+    *info->o_buf++ = ((data << (8 - info->o_count))|info->o_bitbuf);
+    info->o_bitbuf = 0;
+    info->o_bufcount++;
+    data >>= info->o_count;
+    info->o_count = 8;
+  }
+  info->o_bitbuf |= (data << (8 - info->o_count));
+  info->o_count = -length;
+  return 0;
+}
+
+private int 
+dviprt_fax_set_white(int count,FaxEncodeInfo *info)
+{
+  static FaxEncode_t white_count_list[]={
+    { 0x00AC,      8,	}, /*    0 */
+    { 0x0038,      6,	}, /*    1 */
+    { 0x000E,      4,	}, /*    2 */
+    { 0x0001,      4,	}, /*    3 */
+    { 0x000D,      4,	}, /*    4 */
+    { 0x0003,      4,	}, /*    5 */
+    { 0x0007,      4,	}, /*    6 */
+    { 0x000F,      4,	}, /*    7 */
+    { 0x0019,      5,	}, /*    8 */
+    { 0x0005,      5,	}, /*    9 */
+    { 0x001C,      5,	}, /*   10 */
+    { 0x0002,      5,	}, /*   11 */
+    { 0x0004,      6,	}, /*   12 */
+    { 0x0030,      6,	}, /*   13 */
+    { 0x000B,      6,	}, /*   14 */
+    { 0x002B,      6,	}, /*   15 */
+    { 0x0015,      6,	}, /*   16 */
+    { 0x0035,      6,	}, /*   17 */
+    { 0x0072,      7,	}, /*   18 */
+    { 0x0018,      7,	}, /*   19 */
+    { 0x0008,      7,	}, /*   20 */
+    { 0x0074,      7,	}, /*   21 */
+    { 0x0060,      7,	}, /*   22 */
+    { 0x0010,      7,	}, /*   23 */
+    { 0x000A,      7,	}, /*   24 */
+    { 0x006A,      7,	}, /*   25 */
+    { 0x0064,      7,	}, /*   26 */
+    { 0x0012,      7,	}, /*   27 */
+    { 0x000C,      7,	}, /*   28 */
+    { 0x0040,      8,	}, /*   29 */
+    { 0x00C0,      8,	}, /*   30 */
+    { 0x0058,      8,	}, /*   31 */
+    { 0x00D8,      8,	}, /*   32 */
+    { 0x0048,      8,	}, /*   33 */
+    { 0x00C8,      8,	}, /*   34 */
+    { 0x0028,      8,	}, /*   35 */
+    { 0x00A8,      8,	}, /*   36 */
+    { 0x0068,      8,	}, /*   37 */
+    { 0x00E8,      8,	}, /*   38 */
+    { 0x0014,      8,	}, /*   39 */
+    { 0x0094,      8,	}, /*   40 */
+    { 0x0054,      8,	}, /*   41 */
+    { 0x00D4,      8,	}, /*   42 */
+    { 0x0034,      8,	}, /*   43 */
+    { 0x00B4,      8,	}, /*   44 */
+    { 0x0020,      8,	}, /*   45 */
+    { 0x00A0,      8,	}, /*   46 */
+    { 0x0050,      8,	}, /*   47 */
+    { 0x00D0,      8,	}, /*   48 */
+    { 0x004A,      8,	}, /*   49 */
+    { 0x00CA,      8,	}, /*   50 */
+    { 0x002A,      8,	}, /*   51 */
+    { 0x00AA,      8,	}, /*   52 */
+    { 0x0024,      8,	}, /*   53 */
+    { 0x00A4,      8,	}, /*   54 */
+    { 0x001A,      8,	}, /*   55 */
+    { 0x009A,      8,	}, /*   56 */
+    { 0x005A,      8,	}, /*   57 */
+    { 0x00DA,      8,	}, /*   58 */
+    { 0x0052,      8,	}, /*   59 */
+    { 0x00D2,      8,	}, /*   60 */
+    { 0x004C,      8,	}, /*   61 */
+    { 0x00CC,      8,	}, /*   62 */
+    { 0x002C,      8,	}, /*   63 */
+    
+    { 0x001B,      5,	}, /*   64 */
+    { 0x0009,      5,	}, /*  128 */
+    { 0x003A,      6,	}, /*  192 */
+    { 0x0076,      7,	}, /*  256 */
+    { 0x006C,      8,	}, /*  320 */
+    { 0x00EC,      8,	}, /*  384 */
+    { 0x0026,      8,	}, /*  448 */
+    { 0x00A6,      8,	}, /*  512 */
+    { 0x0016,      8,	}, /*  576 */
+    { 0x00E6,      8,	}, /*  640 */
+    { 0x0066,      9,	}, /*  704 */
+    { 0x0166,      9,	}, /*  768 */
+    { 0x0096,      9,	}, /*  832 */
+    { 0x0196,      9,	}, /*  896 */
+    { 0x0056,      9,	}, /*  960 */
+    { 0x0156,      9,	}, /* 1024 */
+    { 0x00D6,      9,	}, /* 1088 */
+    { 0x01D6,      9,	}, /* 1152 */
+    { 0x0036,      9,	}, /* 1216 */
+    { 0x0136,      9,	}, /* 1280 */
+    { 0x00B6,      9,	}, /* 1344 */
+    { 0x01B6,      9,	}, /* 1408 */
+    { 0x0032,      9,	}, /* 1472 */
+    { 0x0132,      9,	}, /* 1536 */
+    { 0x00B2,      9,	}, /* 1600 */
+    { 0x0006,      6,	}, /* 1664 */
+    { 0x01B2,      9,	}, /* 1728 */
+    
+    { 0x0080,     11,	}, /* 1792 */
+    { 0x0180,     11,	}, /* 1856 */
+    { 0x0580,     11,	}, /* 1920 */
+    { 0x0480,     12,	}, /* 1984 */
+    { 0x0C80,     12,	}, /* 2048 */
+    { 0x0280,     12,	}, /* 2112 */
+    { 0x0A80,     12,	}, /* 2176 */
+    { 0x0680,     12,	}, /* 2240 */
+    { 0x0E80,     12,	}, /* 2304 */
+    { 0x0380,     12,	}, /* 2368 */
+    { 0x0B80,     12,	}, /* 2432 */
+    { 0x0780,     12,	}, /* 2496 */
+    { 0x0F80,     12,	}, /* 2560 */
+  };
+  while (count >= 64){
+    if(count <= MAX_FAX_WIDTH){
+      dviprt_fax_set_bitcount((white_count_list + 63) + (count/64),info);
+      break;
+    }
+    dviprt_fax_set_white(MAX_FAX_WIDTH,info);
+    dviprt_fax_set_black(0,info);
+    count -= MAX_FAX_WIDTH;
+  }
+  dviprt_fax_set_bitcount(white_count_list + (count & 63) ,info);
+  return 0;
+}
+
+private int 
+dviprt_fax_set_black(int count,FaxEncodeInfo *info)
+{
+  static FaxEncode_t black_count_list[]={
+    { 0x03B0,     10,	}, /*    0 */
+    { 0x0002,      3,	}, /*    1 */
+    { 0x0003,      2,	}, /*    2 */
+    { 0x0001,      2,	}, /*    3 */
+    { 0x0006,      3,	}, /*    4 */
+    { 0x000C,      4,	}, /*    5 */
+    { 0x0004,      4,	}, /*    6 */
+    { 0x0018,      5,	}, /*    7 */
+    { 0x0028,      6,	}, /*    8 */
+    { 0x0008,      6,	}, /*    9 */
+    { 0x0010,      7,	}, /*   10 */
+    { 0x0050,      7,	}, /*   11 */
+    { 0x0070,      7,	}, /*   12 */
+    { 0x0020,      8,	}, /*   13 */
+    { 0x00E0,      8,	}, /*   14 */
+    { 0x0030,      9,	}, /*   15 */
+    { 0x03A0,     10,	}, /*   16 */
+    { 0x0060,     10,	}, /*   17 */
+    { 0x0040,     10,	}, /*   18 */
+    { 0x0730,     11,	}, /*   19 */
+    { 0x00B0,     11,	}, /*   20 */
+    { 0x01B0,     11,	}, /*   21 */
+    { 0x0760,     11,	}, /*   22 */
+    { 0x00A0,     11,	}, /*   23 */
+    { 0x0740,     11,	}, /*   24 */
+    { 0x00C0,     11,	}, /*   25 */
+    { 0x0530,     12,	}, /*   26 */
+    { 0x0D30,     12,	}, /*   27 */
+    { 0x0330,     12,	}, /*   28 */
+    { 0x0B30,     12,	}, /*   29 */
+    { 0x0160,     12,	}, /*   30 */
+    { 0x0960,     12,	}, /*   31 */
+    { 0x0560,     12,	}, /*   32 */
+    { 0x0D60,     12,	}, /*   33 */
+    { 0x04B0,     12,	}, /*   34 */
+    { 0x0CB0,     12,	}, /*   35 */
+    { 0x02B0,     12,	}, /*   36 */
+    { 0x0AB0,     12,	}, /*   37 */
+    { 0x06B0,     12,	}, /*   38 */
+    { 0x0EB0,     12,	}, /*   39 */
+    { 0x0360,     12,	}, /*   40 */
+    { 0x0B60,     12,	}, /*   41 */
+    { 0x05B0,     12,	}, /*   42 */
+    { 0x0DB0,     12,	}, /*   43 */
+    { 0x02A0,     12,	}, /*   44 */
+    { 0x0AA0,     12,	}, /*   45 */
+    { 0x06A0,     12,	}, /*   46 */
+    { 0x0EA0,     12,	}, /*   47 */
+    { 0x0260,     12,	}, /*   48 */
+    { 0x0A60,     12,	}, /*   49 */
+    { 0x04A0,     12,	}, /*   50 */
+    { 0x0CA0,     12,	}, /*   51 */
+    { 0x0240,     12,	}, /*   52 */
+    { 0x0EC0,     12,	}, /*   53 */
+    { 0x01C0,     12,	}, /*   54 */
+    { 0x0E40,     12,	}, /*   55 */
+    { 0x0140,     12,	}, /*   56 */
+    { 0x01A0,     12,	}, /*   57 */
+    { 0x09A0,     12,	}, /*   58 */
+    { 0x0D40,     12,	}, /*   59 */
+    { 0x0340,     12,	}, /*   60 */
+    { 0x05A0,     12,	}, /*   61 */
+    { 0x0660,     12,	}, /*   62 */
+    { 0x0E60,     12,	}, /*   63 */
+    
+    { 0x03C0,     10,	}, /*   64 */
+    { 0x0130,     12,	}, /*  128 */
+    { 0x0930,     12,	}, /*  192 */
+    { 0x0DA0,     12,	}, /*  256 */
+    { 0x0CC0,     12,	}, /*  320 */
+    { 0x02C0,     12,	}, /*  384 */
+    { 0x0AC0,     12,	}, /*  448 */
+    { 0x06C0,     13,	}, /*  512 */
+    { 0x16C0,     13,	}, /*  576 */
+    { 0x0A40,     13,	}, /*  640 */
+    { 0x1A40,     13,	}, /*  704 */
+    { 0x0640,     13,	}, /*  768 */
+    { 0x1640,     13,	}, /*  832 */
+    { 0x09C0,     13,	}, /*  896 */
+    { 0x19C0,     13,	}, /*  960 */
+    { 0x05C0,     13,	}, /* 1024 */
+    { 0x15C0,     13,	}, /* 1088 */
+    { 0x0DC0,     13,	}, /* 1152 */
+    { 0x1DC0,     13,	}, /* 1216 */
+    { 0x0940,     13,	}, /* 1280 */
+    { 0x1940,     13,	}, /* 1344 */
+    { 0x0540,     13,	}, /* 1408 */
+    { 0x1540,     13,	}, /* 1472 */
+    { 0x0B40,     13,	}, /* 1536 */
+    { 0x1B40,     13,	}, /* 1600 */
+    { 0x04C0,     13,	}, /* 1664 */
+    { 0x14C0,     13, }, /* 1728 */
+    
+    { 0x0080,     11,	}, /* 1792 */
+    { 0x0180,     11,	}, /* 1856 */
+    { 0x0580,     11,	}, /* 1920 */
+    { 0x0480,     12,	}, /* 1984 */
+    { 0x0C80,     12,	}, /* 2048 */
+    { 0x0280,     12,	}, /* 2112 */
+    { 0x0A80,     12,	}, /* 2176 */
+    { 0x0680,     12,	}, /* 2240 */
+    { 0x0E80,     12,	}, /* 2304 */
+    { 0x0380,     12,	}, /* 2368 */
+    { 0x0B80,     12,	}, /* 2432 */
+    { 0x0780,     12,	}, /* 2496 */
+    { 0x0F80,     12,	}, /* 2560 */
+  };
+  
+  while (count >= 64){
+    if(count <= MAX_FAX_WIDTH){
+      dviprt_fax_set_bitcount((black_count_list + 63) + (count/64),info);
+      break;
+    }
+    dviprt_fax_set_black(MAX_FAX_WIDTH,info);
+    dviprt_fax_set_white(0,info);
+    count -= MAX_FAX_WIDTH;
+  }
+  dviprt_fax_set_bitcount(black_count_list + (count & 63),info);
+  return 0;
+}
+#endif /* DVIPRT_SUPPORT_FAX */
+/***** End of encode.c *****/
diff -urN -x .svn espgs-8.15rc2/addons/japanese/dviprlib.h trunk/addons/japanese/dviprlib.h
--- espgs-8.15rc2/addons/japanese/dviprlib.h	1970-01-01 01:00:00.000000000 +0100
+++ trunk/addons/japanese/dviprlib.h	2005-03-14 00:03:52.511756100 +0100
@@ -0,0 +1,361 @@
+/* COPYRIGHT (C) 1990, 1992 Aladdin Enterprises.  All rights reserved.
+   Distributed by Free Software Foundation, Inc.
+   
+   This file is part of Ghostscript.
+   
+   Ghostscript is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility
+   to anyone for the consequences of using it or for whether it serves any
+   particular purpose or works at all, unless he says so in writing.  Refer
+   to the Ghostscript General Public License for full details.
+   
+   Everyone is granted permission to copy, modify and redistribute
+   Ghostscript, but only under the conditions described in the Ghostscript
+   General Public License.  A copy of this license is supposed to have been
+   given to you along with Ghostscript so you can know your rights and
+   responsibilities.  It should be in a file named COPYING.  Among other
+   things, the copyright notice and this notice must be preserved on all
+   copies.  */
+
+/* dviprlib.h */
+
+/* $Id$ */
+
+#ifndef s_cfgbld_h_INCLUDED
+
+
+/* $Id$ */
+
+#ifndef s_cfg_h_INCLUDED
+#define CFG_MAGIC_NUMBER   ":K"
+#define CFG_VERSION       2
+
+#define CFG_NAME          0
+#define CFG_ENCODE_INFO   1
+#define CFG_STRINGS_TYPE_COUNT 2
+
+#define CFG_STRINGS_NAME "name", "encode_info"
+
+#define CFG_PINS           0
+#define CFG_MINIMAL_UNIT   1
+#define CFG_MAXIMAL_UNIT   2
+#define CFG_DPI            3
+#define CFG_UPPER_POS      4
+#define CFG_ENCODE         5
+#define CFG_CONSTANT       6
+#define CFG_Y_DPI          7
+#define CFG_INTEGER_TYPE_COUNT 8
+
+#define CFG_INTEGER_NAME  "pins","minimal_unit","maximal_unit","dpi",\
+"upper_position","encode","constant","y_dpi"
+  
+#define CFG_BIT_IMAGE_MODE  0
+#define CFG_SEND_BIT_IMAGE  1
+#define CFG_BIT_ROW_HEADER  2
+#define CFG_AFTER_BIT_IMAGE 3
+#define CFG_LINE_FEED       4
+#define CFG_FORM_FEED       5
+#define CFG_NORMAL_MODE     6
+#define CFG_SKIP_SPACES     7
+#define CFG_PRTCODE_TYPE_COUNT 8
+  
+#define CFG_PRTCODE_NAME "bit_image_mode", "send_bit_image", "bit_row_header",\
+  "after_bit_image", "line_feed", "form_feed",\
+  "normal_mode", "skip_spaces"
+  
+#define CFG_FMT_BIT         0x80
+#define CFG_FMT_FORMAT_BIT  0x70
+#define CFG_FMT_COLUMN_BIT  0x07
+#define CFG_FMT_ISO_BIT     0x08
+  
+#define CFG_FMT_BIN_LTOH    0x00
+#define CFG_FMT_BIN_HTOL    0x10
+#define CFG_FMT_HEX_UPPER   0x20
+#define CFG_FMT_HEX_LOWER   0x30
+#define CFG_FMT_DECIMAL     0x40
+#define CFG_FMT_OCTAL       0x50
+#define CFG_FMT_ASSIGNMENT  0x60  /* assignment(user variables) */
+#define CFG_FMT_STRINGS     0x70
+  
+#define CFG_EXPR_TYPE_BIT   0xe0
+#define CFG_EXPR_VAL_BIT    0x1f
+#define CFG_VAL           0x80
+#define CFG_VAL_DEFAULT   (0x00 | CFG_VAL)
+#define CFG_VAL_CONSTANT  (0x01 | CFG_VAL)
+#define CFG_VAL_WIDTH     (0x02 | CFG_VAL)
+#define CFG_VAL_HEIGHT    (0x03 | CFG_VAL)
+#define CFG_VAL_PAGE      (0x04 | CFG_VAL)
+#define CFG_VAL_PAGECOUNT (0x05 | CFG_VAL)
+#define CFG_VAL_DATASIZE  (0x06 | CFG_VAL)
+#define CFG_VAL_X_DPI     (0x07 | CFG_VAL)
+#define CFG_VAL_Y_DPI     (0x08 | CFG_VAL)
+#define CFG_VAL_PINS_BYTE (0x09 | CFG_VAL)
+#define CFG_VAL_X_POS     (0x0a | CFG_VAL)
+#define CFG_VAL_Y_POS     (0x0b | CFG_VAL)
+
+/* user variable 'A' -- 'P' (0xa0 -- 0xaf) */
+#define CFG_USERVAL       (0x20 | CFG_VAL)
+#define CFG_USERVAL_COUNT 16
+
+#define CFG_OP  0xc0
+/* logic 2 operand */
+#define CFG_OP_ADD  (0x00 | CFG_OP)
+#define CFG_OP_SUB  (0x01 | CFG_OP)
+#define CFG_OP_MUL  (0x02 | CFG_OP)
+#define CFG_OP_DIV  (0x03 | CFG_OP)
+#define CFG_OP_MOD  (0x04 | CFG_OP)
+
+#define CFG_OP_SHL  (0x05 | CFG_OP)
+#define CFG_OP_SHR  (0x06 | CFG_OP)
+#define CFG_OP_AND  (0x07 | CFG_OP)
+#define CFG_OP_OR   (0x08 | CFG_OP)
+#define CFG_OP_XOR  (0x09 | CFG_OP)
+/* extra operation (user cannot use) */
+#define CFG_OP_POP  (0x2e | CFG_OP)
+#define CFG_OP_NULL (0x2f | CFG_OP)
+
+#define CFG_OP_NAME	"+","-","*","/",\
+"%","<",">","&",\
+  "|","^",\
+  /* 0x0a -- 0x0f */	NULL,NULL,\
+  /* Undefined */	NULL,NULL,NULL,NULL,\
+  \
+  /* 0x10 -- 0x1f*/	NULL,NULL,NULL,NULL,\
+  /* Undefined */	NULL,NULL,NULL,NULL,\
+  NULL,NULL,NULL,NULL,\
+  NULL,NULL,NULL,NULL,\
+  \
+  /* 0x20 -- 0x2d*/	NULL,NULL,NULL,NULL,\
+  /* Undefined */	NULL,NULL,NULL,NULL,\
+  NULL,NULL,NULL,NULL,\
+  NULL,NULL,\
+  \
+  "pop","null"
+  
+#define CFG_TOP_IS_HIGH  0x00
+#define CFG_TOP_IS_LOW   0x80
+#define CFG_LEFT_IS_HIGH 0x40
+#define CFG_LEFT_IS_LOW  0xc0
+#define CFG_NON_MOVING   0x20
+#define CFG_NON_TRANSPOSE_BIT 0x40
+#define CFG_REVERSE_BIT       0x80
+#define CFG_PIN_POSITION_BITS 0xc0
+  
+#define CFG_ENCODE_NAME "NULL","HEX","FAX","PCL1","PCL2"
+#define CFG_ENCODE_NULL  0x00
+#define CFG_ENCODE_HEX   0x01
+#define CFG_ENCODE_FAX   0x02
+#define CFG_ENCODE_PCL1  0x03
+#define CFG_ENCODE_PCL2  0x04
+#define CFG_ENCODE_LIPS3 0x05    /* Not implemented yet. */
+#define CFG_ENCODE_ESCPAGE 0x06  /* Not implemented yet. */
+#define CFG_ENCODE_COUNT 0x05
+  
+#define CFG_STACK_DEPTH  20
+  
+#define CFG_ERROR_OTHER        -1
+  
+#define CFG_ERROR_SYNTAX       -2
+#define CFG_ERROR_RANGE        -3
+#define CFG_ERROR_TYPE         -4
+  
+#define CFG_ERROR_FILE_OPEN    -5
+#define CFG_ERROR_OUTPUT       -6
+#define CFG_ERROR_MEMORY       -7
+#define CFG_ERROR_DIV0         -8
+#define CFG_ERROR_NOT_SUPPORTED -9
+  
+#if defined(MSDOS) || defined(_MSDOS)
+#  ifndef __MSDOS__
+#    define __MSDOS__
+#  endif
+#endif
+#if defined(__MSDOS__) || defined(__STDC__)
+#  ifndef __PROTOTYPES__
+#    define __PROTOTYPES__
+#  endif
+#endif
+#ifdef __NO_PROTOTYPES__
+#  undef __PROTOTYPES__
+#endif
+
+#if defined(__MSDOS__) && !defined(__GNUC__) && !defined(__WATCOMC__)
+# ifndef __MSDOS_REAL__
+#   define __MSDOS_REAL__
+# endif
+#else
+# ifndef far
+#   define far /* */
+# endif
+#endif
+
+typedef struct {
+  unsigned int version;
+  
+  long integer[CFG_INTEGER_TYPE_COUNT];
+  unsigned char *strings[CFG_STRINGS_TYPE_COUNT];
+  unsigned char *prtcode[CFG_PRTCODE_TYPE_COUNT];
+  unsigned int prtcode_size[CFG_PRTCODE_TYPE_COUNT];
+} dviprt_cfg_t;
+
+typedef struct dviprt_print_s dviprt_print;
+struct dviprt_print_s {
+  dviprt_cfg_t *printer;
+  unsigned int bitmap_width;
+  unsigned int bitmap_height;
+  unsigned int buffer_width;
+  
+  unsigned int device_x;
+  unsigned int device_y;
+  unsigned int bitmap_x;
+  unsigned int bitmap_y;
+  unsigned int last_x;
+  
+  int page_count;
+  unsigned char far *source_buffer;
+  unsigned char far *encode_buffer;
+  unsigned char far *psource;
+  unsigned char far *poutput;
+  int tempbuffer_f;
+  
+#ifdef __PROTOTYPES__
+  int (*output_proc)(unsigned char far *,long ,void *);
+  int (*output_maximal_unit)(dviprt_print *,unsigned char far *,unsigned int );
+  long (*encode_getbuffersize_proc)(dviprt_print *,long);
+  long (*encode_encode_proc)(dviprt_print *,long ,int);
+#else
+  int (*output_proc)();
+  int (*output_maximal_unit)();
+  long (*encode_getbuffersize_proc)();
+  long (*encode_encode_proc)();
+#endif
+  void *pstream;
+  
+  unsigned long output_bytes;
+  unsigned int uservar[CFG_USERVAL_COUNT];
+};
+
+#define dviprt_getscanlines(p) ((int)(p)->printer->integer[CFG_PINS]*8)
+#define dviprt_getoutputbytes(p) ((unsigned long)(p)->output_bytes)
+
+#ifdef __PROTOTYPES__
+extern int dviprt_readsrc(char *,dviprt_cfg_t *,
+			  unsigned char *,int ,unsigned char *, int);
+extern int dviprt_readcfg(char *,dviprt_cfg_t *,
+			  unsigned char *,int , unsigned char *,int);
+
+extern int dviprt_beginpage(dviprt_print *);
+extern long dviprt_initlibrary(dviprt_print *,dviprt_cfg_t *,
+			       unsigned int ,unsigned int );
+extern int dviprt_endbitmap(dviprt_print *);
+extern int dviprt_setstream
+  (dviprt_print *p,int(*f)(unsigned char far*,long,void*),void *s);
+extern int dviprt_setbuffer(dviprt_print *,unsigned char far *);
+extern int dviprt_outputscanlines(dviprt_print *, unsigned char far *);
+extern int dviprt_output(dviprt_print *,unsigned char far *,long );
+extern int dviprt_unsetbuffer(dviprt_print *);
+
+extern int dviprt_setmessagestream(FILE *);
+extern int dviprt_writesrc(char *,char *,dviprt_cfg_t *,unsigned char *,int );
+extern int dviprt_writecfg(char *,char *,dviprt_cfg_t *,unsigned char *,int );
+extern int dviprt_writec(char *,char *,dviprt_cfg_t *,unsigned char *,int );
+#else /* !__PROTOTYPES__ */
+extern int dviprt_readsrc();
+extern int dviprt_readcfg();
+extern long dviprt_initlibrary();
+extern int dviprt_setstream();
+extern int dviprt_setbuffer();
+extern int dviprt_beginpage();
+extern int dviprt_outputscanlines();
+extern int dviprt_endbitmap();
+extern int dviprt_output ();
+extern int dviprt_unsetbuffer();
+extern int dviprt_setmessagestream();
+extern int dviprt_writesrc();
+extern int dviprt_writecfg();
+extern int dviprt_writec();
+#endif /* __PROTOTYPES__ */
+
+extern char *dviprt_integername[];
+extern char *dviprt_stringsname[];
+extern char *dviprt_prtcodename[];
+extern char *dviprt_encodename[];
+
+#define s_cfg_h_INCLUDED
+#endif /* s_cfg_h_INCLUDED */
+
+
+#define TEMP_CODEBUF_SIZE 2048
+#define TEMP_READBUF_SIZE 1024
+
+/* MS-DOS (real-mode) */
+#ifdef __MSDOS_REAL__
+# define BufferCpy(a,b,c) _fmemcpy(a,b,c)
+# define BufferCmp(a,b,c) _fmemcmp(a,b,c)
+# define BufferAlloc(a)   _fmalloc(a)
+# define BufferFree(a)    _ffree(a)
+#else
+# define BufferCpy(a,b,c) memcpy(a,b,c)
+# define BufferCmp(a,b,c) memcmp(a,b,c)
+# define BufferAlloc(a)   malloc(a)
+# define BufferFree(a)    free(a)
+#endif
+
+#ifndef MIN
+#define MIN(a,b) ((a)<(b) ? (a) : (b))
+#endif
+#ifndef MAX
+#define MAX(a,b) ((a)>(b) ? (a) : (b))
+#endif
+
+#define CFG_LIBERROR_UNKNOWN_VALUE  -256
+#define CFG_LIBERROR_UNKNOWN_FORMAT -257
+#define CFG_LIBERROR_UNKNOWN_ESCSEQ -258
+#define CFG_LIBERROR_OUTOFRANGE     -259
+#define CFG_LIBERROR_INVALID_VALUE  -260
+#define CFG_LIBERROR_COMPLICATED_EXPR  -261
+#define CFG_LIBERROR_INCOMPLETE      -262
+
+typedef struct {
+  uchar *fname;
+  FILE *file;
+  int line_no;
+  
+  char temp_readbuf_f;
+  char temp_codebuf_f;
+  uchar *readbuf;
+  uchar *codebuf;
+  int readbuf_size;
+  int codebuf_size;
+  
+  uchar *pcodebuf;
+  
+  uchar *token;
+  uchar *endtoken;
+} dviprt_cfg_i;
+
+#ifdef dviprlib_implementation
+typedef struct {
+  int no;
+  long (*getworksize)(dviprt_print *,long);
+  long (*encode)(dviprt_print *,long,int);
+} dviprt_encoder;
+
+#define liblocal private
+
+liblocal dviprt_encoder *dviprt_getencoder_(int);
+liblocal int dviprt_setcfgbuffer_(dviprt_cfg_i *,int ,int);
+liblocal int dviprt_resetcfgbuffer_(dviprt_cfg_i *);
+liblocal int dviprt_initcfg_(dviprt_cfg_t *,dviprt_cfg_i *);
+liblocal int dviprt_printmessage(char *,int);
+liblocal int dviprt_printerror(char *,int);
+liblocal int dviprt_printwarning(char *,int);
+liblocal int dviprt_printcfgerror(dviprt_cfg_i *,char *,int);
+liblocal int dviprt_printcfgwarning(dviprt_cfg_i *,char *,int);
+
+extern int dviprt_print_headercomment_(char *,char *,char *,FILE *);
+extern char dviprt_message_buffer[];
+#endif dviprlib_implementation
+ 
+#define s_cfgbld_h_INCLUDED
+#endif /* s_cfgbld_h_INCLUDED */
diff -urN -x .svn espgs-8.15rc2/addons/japanese/escp_24.src trunk/addons/japanese/escp_24.src
--- espgs-8.15rc2/addons/japanese/escp_24.src	1970-01-01 01:00:00.000000000 +0100
+++ trunk/addons/japanese/escp_24.src	2005-03-14 00:03:52.418759106 +0100
@@ -0,0 +1,12 @@
+name               : ESC/P 24 pin
+pins               : 24
+minimal_unit       : 1
+maximal_unit       : 180
+dpi                : 180
+upper_position     : HIGH_BIT
+bit_image_mode     : \e 3 \x18 \e ?Z'
+send_bit_image     : \e Z \b2,d
+line_feed          : \r \n
+form_feed          : \r \f
+normal_mode        : \r \f \e 2
+skip_spaces        : \e \  \b2,d
diff -urN -x .svn espgs-8.15rc2/addons/japanese/gdevdmpr.c trunk/addons/japanese/gdevdmpr.c
--- espgs-8.15rc2/addons/japanese/gdevdmpr.c	1970-01-01 01:00:00.000000000 +0100
+++ trunk/addons/japanese/gdevdmpr.c	2005-03-14 00:03:52.498756520 +0100
@@ -0,0 +1,881 @@
+/* COPYRIGHT (C) 1990, 1992 Aladdin Enterprises.  All rights reserved.
+   Distributed by Free Software Foundation, Inc.
+   
+   This file is part of Ghostscript.
+   
+   Ghostscript is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility
+   to anyone for the consequences of using it or for whether it serves any
+   particular purpose or works at all, unless he says so in writing.  Refer
+   to the Ghostscript General Public License for full details.
+   
+   Everyone is granted permission to copy, modify and redistribute
+   Ghostscript, but only under the conditions described in the Ghostscript
+   General Public License.  A copy of this license is supposed to have been
+   given to you along with Ghostscript so you can know your rights and
+   responsibilities.  It should be in a file named COPYING.  Among other
+   things, the copyright notice and this notice must be preserved on all
+   copies.  */
+
+/* gdevdmpr.c
+ *
+ * Dot matrix printer driver for Ghostscript
+ *
+ * The first version written by ...                 K.Asayama  Nov 1992
+ * NEC PC-H98 high resolution mode supported by ... OkI        Dec 1992
+ * IBM PC AT/Compatible machines supported by ...   hero.h     Mar 1993
+ * Modified for 386BSD by ...                       FKR        Mar 1993
+ * Modified for Ghostscript version 2.5.2 by ...    K.Asayama  Mar 1993
+ * Modified for Ghostscript version 2.6.1 by ...    K.Asayama  Oct 1993
+ * Modified for Ghostscript version 4.03 by ...     K.Asayama  May 1997
+ */
+
+#include "gdevprn.h"
+#include "gp.h"
+#include "errors.h"
+#include "gsparam.h"
+#include "gsstate.h"
+#include "math_.h"
+#include "malloc_.h"
+
+/* include library header. */
+#include "dviprlib.h"
+
+extern FILE *lib_fopen(const char *);
+
+#define LOCAL_DEBUG 0
+
+#define DEVICE_NAME "dmprt"
+#define DEVICE_VERSION 201  /* 2.01 */
+
+typedef struct gx_device_dmprt_local_s gx_device_dmprt_local;
+struct gx_device_dmprt_local_s {
+  int orig_x_dpi;
+  int orig_y_dpi;
+
+  int x_offset;
+  int y_offset;
+  
+  int spec_width;
+  int spec_height;
+  int max_width;
+  int max_height;
+  int dev_margin[4]; /* left bottom right top */
+  
+  int prtcfg_init_f;
+  int verbose_f;
+  int debug_f;
+  dviprt_cfg_t prtcfg;
+  dviprt_print prtinfo;
+};
+
+/* declaration of the structure to describe `DMPRT' device driver */
+typedef struct gx_device_dmprt_s gx_device_dmprt;
+struct gx_device_dmprt_s {
+  gx_device_common;
+  gx_prn_device_common;
+  
+  gx_device_dmprt_local dmprt;
+};
+
+/* declarations of main functions */
+private dev_proc_get_params(gdev_dmprt_get_params);
+private dev_proc_put_params(gdev_dmprt_put_params);
+private dev_proc_get_initial_matrix(gdev_dmprt_get_initial_matrix);
+private dev_proc_open_device(gdev_dmprt_open);
+private dev_proc_print_page(gdev_dmprt_print_page);
+private dev_proc_close_device(gdev_dmprt_close);
+
+/* declarations of sub functions to get printer properties. */
+private void gdev_dmprt_init_printer_props(gx_device_dmprt *);
+private int gdev_dmprt_get_printer_props(gx_device_dmprt *,char *);
+private int gdev_dmprt_check_code_props(byte * ,int );
+private FILE *gdev_dmprt_dviprt_lib_fopen(const char *,char *);
+
+private int gdev_dmprt_error_no_dviprt_to_gs(int );
+
+/* The device descriptor */
+gx_device_procs prn_dmprt_procs = {
+  gdev_dmprt_open,
+  gdev_dmprt_get_initial_matrix,
+  0, /* sync_output */
+  gdev_prn_output_page,
+  gdev_dmprt_close,
+  gdev_prn_map_rgb_color,
+  gdev_prn_map_color_rgb,
+  0, /* fill_rectangle */
+  0, /* tile_rectangle */
+  0, /* copy_mono */
+  0, /* copy_color */
+  0, /* draw_line */
+  0, /* get_bits */
+  gdev_dmprt_get_params,
+  gdev_dmprt_put_params,
+  gx_default_map_cmyk_color,
+  0,
+};
+
+#define DEFAULT_DPI   180
+#define DEFAULT_WIDTH   8.3
+#define DEFAULT_HEIGHT 11.7
+
+gx_device_dmprt gs_dmprt_device = {
+  prn_device_body(gx_device_dmprt, prn_dmprt_procs, DEVICE_NAME,
+      DEFAULT_WIDTH*10,       /* width 10'th */
+      DEFAULT_HEIGHT*10,      /* height 10'th */
+      DEFAULT_DPI,            /* X resolution */
+      DEFAULT_DPI,            /* Y resolution */
+      0,0,0,0,                /* margins (top,left,bottom,right) */
+      1,1,1,1,2,2,            /* color info. */
+      gdev_dmprt_print_page),
+
+  {
+    DEFAULT_DPI,  DEFAULT_DPI,
+    0, 0, /* offset */
+    DEFAULT_DPI*DEFAULT_WIDTH,  /* specified width */
+    DEFAULT_DPI*DEFAULT_HEIGHT, /* specified height */
+    -1,-1,			/* maximal width,height */
+    { 0,0,0,0 },      /* margins */
+    
+  /* status of the device */
+      0,    /* printer configuration is not initialized */
+      0,    /* verbose mode */
+      0,    /* debug flag */
+  },
+};
+
+#define ppdev ((gx_device_printer *)pdev)
+#define pddev ((gx_device_dmprt *)pdev)
+
+
+typedef struct {
+  char *name;
+  int no;
+} dmprt_encoding;
+private dmprt_encoding gdev_dmprt_encode_list[] = {
+  {"Null",CFG_ENCODE_NULL},
+  {"AsciiHex",CFG_ENCODE_HEX },
+  {"CCITTFax",CFG_ENCODE_FAX },
+  {"PCLMode1Compress",CFG_ENCODE_PCL1 },
+  {"PCLMode2Compress",CFG_ENCODE_PCL2 },
+  {0},
+};
+
+
+/* --- Get properties of printer device. --- */
+private int gdev_dmprt_get_dmprt_params(gx_device *pdev, gs_param_list *plist);
+private int
+gdev_dmprt_get_dviprt_params(gx_device *pdev, gs_param_list *plist);
+
+private int
+gdev_dmprt_get_params(gx_device *pdev, gs_param_list *plist)
+{
+  int code;
+  gs_param_dict dict;
+  const char *param_name;
+  
+  if (!pddev->dmprt.prtcfg_init_f)
+    gdev_dmprt_init_printer_props(pddev);
+
+  dict.size = 30;
+  code = param_begin_write_dict(plist, (param_name = "DmprtParams"),
+				&dict, false);
+  if (code < 0) return code;
+  if (code == 0) {
+    code = gdev_dmprt_get_dmprt_params(pdev, dict.list);
+    param_end_write_dict(plist, param_name, &dict);
+    if (code < 0) return code;
+  }
+  
+  dict.size = 30;
+  code = param_begin_write_dict(plist, (param_name = "DviprtParams"),
+				&dict, false);
+  if (code < 0) return code;
+  if (code == 0) {
+    code = gdev_dmprt_get_dviprt_params(pdev, dict.list);
+    param_end_write_dict(plist, param_name, &dict);
+    if (code < 0) return code;
+  }
+  
+  {
+    int w = pddev->width;
+    int h = pddev->height;
+    pddev->width = pddev->dmprt.spec_width;
+    pddev->height = pddev->dmprt.spec_height;
+    code = gdev_prn_get_params(pdev, plist);
+    pddev->width = w;
+    pddev->height = h;
+  }
+  
+  return code;
+}
+
+/* internal routines for get_params */
+private int
+gdev_dmprt_get_dmprt_params(gx_device *pdev, gs_param_list *plist)
+{
+  int code;
+  long vlong;
+  bool vbool;
+  gs_param_int_array vaint;
+  int int_data[4];
+  
+  vlong = DEVICE_VERSION;
+  code = param_write_long(plist, "Version", &vlong);
+  if (code < 0) return code;
+
+  vbool = pddev->dmprt.debug_f;
+  code = param_write_bool(plist, "Debug", &vbool);
+  if (code < 0) return code;
+  
+  vbool = pddev->dmprt.verbose_f;
+  code = param_write_bool(plist, "Verbose", &vbool);
+  if (code < 0) return code;
+
+  vaint.size = 2;
+  vaint.data = int_data;
+  vaint.persistent = false;
+  int_data[0] = pddev->dmprt.max_width;
+  int_data[1] = pddev->dmprt.max_height;
+  code = param_write_int_array(plist, "MaxSize", &vaint);
+  if (code < 0) return code;
+
+  vaint.size = 2;
+  vaint.data = int_data;
+  vaint.persistent = false;
+  int_data[0] = pddev->dmprt.x_offset;
+  int_data[1] = pddev->dmprt.y_offset;
+  code = param_write_int_array(plist, "Offsets", &vaint);
+  if (code < 0) return code;
+  
+  vaint.size = 4;
+  vaint.data = int_data;
+  vaint.persistent = false;
+  { int i;
+    for (i=0;i<4;i++) int_data[i] = pddev->dmprt.dev_margin[i];
+  }
+  code = param_write_int_array(plist, "Margins", &vaint);
+  if (code < 0) return code;
+
+  return code;
+}
+
+private int
+gdev_dmprt_get_dviprt_params(gx_device *pdev, gs_param_list *plist)
+{
+  dviprt_cfg_t *pprt = &pddev->dmprt.prtcfg;
+  long vlong;
+  bool vbool;
+  gs_param_string vstr;
+  const char *vchar;
+  int code;
+  int i;
+  
+  vlong = pprt->integer[CFG_PINS] * 8;
+  code = param_write_long(plist,"Pins", &vlong);
+  if (code < 0) return code;
+  code = param_write_long(plist, "MinimalUnit",
+			  pprt->integer+CFG_MINIMAL_UNIT);
+  if (code < 0) return code;
+  code = param_write_long(plist,"MaximalUnit",
+			  pprt->integer+CFG_MAXIMAL_UNIT);
+  if (code < 0) return code;
+  code = param_write_int(plist,"HDpi" , &pddev->dmprt.orig_x_dpi);
+  if (code < 0) return code;
+  code = param_write_int(plist,"VDpi", &pddev->dmprt.orig_y_dpi);
+  if (code < 0) return code;
+  code = param_write_long(plist,"Constant", pprt->integer+CFG_CONSTANT);
+  if (code < 0) return code;
+  
+  vbool = pprt->integer[CFG_UPPER_POS] & CFG_NON_TRANSPOSE_BIT ? 0 : 1;
+  code = param_write_bool(plist,"Transpose", &vbool);
+  if (code < 0) return code;
+  vbool = pprt->integer[CFG_UPPER_POS] & CFG_REVERSE_BIT ? 1 : 0;
+  code = param_write_bool(plist,"Reverse", &vbool);
+  if (code < 0) return code;
+  vbool = (pprt->integer[CFG_UPPER_POS] & CFG_NON_MOVING) ? 1 : 0;
+  code = param_write_bool(plist,"NonMoving", &vbool);
+  if (code < 0) return code;
+
+  vchar = pprt->strings[CFG_NAME] ? (const char*)pprt->strings[CFG_NAME] : "";
+  param_string_from_string(vstr, vchar);
+  code = param_write_string(plist, "Name", &vstr);
+  if (code < 0) return code;
+  
+  for (i=0;gdev_dmprt_encode_list[i].name;i++) {
+    if (pprt->integer[CFG_ENCODE] == gdev_dmprt_encode_list[i].no)
+      break;
+  }
+  if (gdev_dmprt_encode_list[i].name == 0) i = 0;
+  param_string_from_string(vstr, gdev_dmprt_encode_list[i].name);
+  code = param_write_string(plist, "Encoding", &vstr);
+  if (code < 0) return code;
+  
+#define param_string_from_prt(ps, pprt, n) \
+  ((ps).data = pprt->prtcode[n] ? pprt->prtcode[n] : (const byte*)"", \
+  (ps).size = pprt->prtcode[n] ? pprt->prtcode_size[n] : 0, \
+  (ps).persistent = true)
+#define param_write_prt(plist, name, pprt, n) \
+  (param_string_from_prt(vstr, pprt, n), \
+  param_write_string(plist, name, &vstr))
+
+  code = param_write_prt(plist, "BitImageMode",
+			 pprt, CFG_BIT_IMAGE_MODE);
+  if (code < 0) return code;
+  code = param_write_prt(plist, "SendBitImage",
+			 pprt, CFG_SEND_BIT_IMAGE);
+  if (code < 0) return code;
+  code = param_write_prt(plist, "BitRowHeader",
+			 pprt, CFG_BIT_ROW_HEADER);
+  if (code < 0) return code;
+  code = param_write_prt(plist, "AfterBitImage",
+			 pprt, CFG_AFTER_BIT_IMAGE);
+  if (code < 0) return code;
+  code = param_write_prt(plist, "LineFeed", pprt, CFG_LINE_FEED);
+  if (code < 0) return code;
+  code = param_write_prt(plist, "FormFeed", pprt, CFG_FORM_FEED);
+  if (code < 0) return code;
+  code = param_write_prt(plist, "NormalMode", pprt, CFG_NORMAL_MODE);
+  if (code < 0) return code;
+  code = param_write_prt(plist, "SkipSpaces", pprt, CFG_SKIP_SPACES);
+  if (code < 0) return code;
+
+  return code;
+}
+/* end of internal routines for get_params */
+
+
+/* --- Put properties of printer device. --- */
+private int gdev_dmprt_put_dmprt_params(gx_device *pdev, gs_param_list *plist);
+private int
+gdev_dmprt_put_dviprt_params(gx_device *pdev, gs_param_list *plist);
+private int gdev_dmprt_put_prt_code_param(gs_param_list *plist,
+					  dviprt_cfg_t *pprt,
+					  const char* name, int idx);
+private int
+gdev_dmprt_put_prt_string_param(gs_param_list *plist,
+				dviprt_cfg_t *pprt, const char* name, int idx);
+
+private int
+gdev_dmprt_put_params(gx_device *pdev, gs_param_list *plist)
+{
+  int code = 0;
+  const char *param_name;
+  gs_param_dict dict;
+  
+  if (!pddev->dmprt.prtcfg_init_f)
+    gdev_dmprt_init_printer_props(pddev);
+
+  /* dmprt parameters */
+  code = param_begin_read_dict(plist, (param_name = "DmprtParams"),
+			       &dict, false);
+  if (code < 0) return code;
+  if (code == 0) {
+    code = gdev_dmprt_put_dmprt_params(pdev, dict.list);
+    param_end_read_dict(plist, param_name, &dict);
+    if (code < 0) return code;
+  }
+  
+  /* dviprt parameters */
+  code = param_begin_read_dict(plist, (param_name = "DviprtParams"),
+				&dict, false);
+  if (code < 0) return code;
+  if (code == 0) {
+    code = gdev_dmprt_put_dviprt_params(pdev, dict.list);
+    param_end_read_dict(plist, param_name, &dict);
+    if (code < 0) return code;
+  }
+  
+  if (pdev->is_open && code) {
+    int ccode = gs_closedevice(pdev);
+    if (ccode < 0) return ccode;
+  }
+  
+  pddev->width = pddev->dmprt.spec_width;
+  pddev->height = pddev->dmprt.spec_height;
+  code = gdev_prn_put_params(pdev, plist);
+  pddev->dmprt.spec_width = pddev->width;
+  pddev->dmprt.spec_height = pddev->height;
+  pddev->width -= (pddev->dmprt.dev_margin[0] + pddev->dmprt.dev_margin[2]);
+  pddev->height -= (pddev->dmprt.dev_margin[1] + pddev->dmprt.dev_margin[3]);
+  if (code < 0) return code;
+  
+  if (pddev->dmprt.max_width>0 && pddev->dmprt.max_width<pddev->width)
+    pddev->width = pddev->dmprt.max_width;
+  if (pddev->dmprt.max_height>0 && pddev->dmprt.max_height<pddev->height)
+    pddev->height = pddev->dmprt.max_height;
+  
+  dviprt_setmessagestream(pddev->dmprt.debug_f ? stderr : NULL);
+  
+  return code;
+}
+
+/* internal routines for put_params */
+
+private int
+gdev_dmprt_put_dmprt_params(gx_device *pdev, gs_param_list *plist)
+{
+  int code;
+  long vlong;
+  bool vbool;
+  gs_param_int_array vaint;
+  
+  /* debug flag */
+  code = param_read_bool(plist, "Debug", &vbool);
+  if (code < 0) return code;
+  if (code == 0) pddev->dmprt.debug_f = vbool;
+  
+  dviprt_setmessagestream(pddev->dmprt.debug_f ? stderr : NULL);
+  
+  code = param_read_bool(plist, "Verbose", &vbool);
+  if (code < 0) return code;
+  pddev->dmprt.verbose_f = vbool;
+
+  /* dummy */
+  code = param_read_long(plist, "Version", &vlong);
+  if (code < 0) return code;
+
+  code = param_read_int_array(plist, "MaxSize", &vaint);
+  if (code < 0) return code;
+  if (code == 0) {
+    if (vaint.size != 2) return e_typecheck;
+    pddev->dmprt.max_width = vaint.data[0];
+    pddev->dmprt.max_height = vaint.data[1];
+  }
+
+  code = param_read_int_array(plist, "Offsets", &vaint);
+  if (code < 0) return code;
+  if (code == 0) {
+    if (vaint.size != 2) return e_typecheck;
+    pddev->dmprt.x_offset = vaint.data[0];
+    pddev->dmprt.y_offset = vaint.data[1];
+  }
+  
+  code = param_read_int_array(plist, "Margins", &vaint);
+  if (code < 0) return code;
+  if (code == 0) {
+    int i;
+    if (vaint.size != 4) return e_typecheck;
+    for (i=0;i<4;i++) pddev->dmprt.dev_margin[i] = vaint.data[i];
+  }
+  
+  return code;
+}
+
+private int
+gdev_dmprt_put_dviprt_params(gx_device *pdev, gs_param_list *plist)
+{
+  int code;
+  dviprt_cfg_t *pprt = &pddev->dmprt.prtcfg;
+  gs_param_string vstr;
+  long vlong;
+  bool vbool;
+  
+  /* load .cfg/.src file */
+  code = param_read_string(plist, "FileName", &vstr);
+  if (code < 0) return code;
+  if (code == 0) {
+    char *filename = gs_malloc(vstr.size + 1, 1,
+			       "gdev_dmprt_put_props(filename)");
+    int ccode;
+    if (filename == 0) return e_VMerror;
+    strncpy(filename, (const char*)vstr.data, vstr.size);
+    filename[vstr.size] = '\0';
+    ccode = gdev_dmprt_get_printer_props(pddev,filename);
+    gs_free(filename, vstr.size+1, 1, "gdev_dmprt_put_props(filename)");
+    if (ccode < 0) return ccode;
+  }
+
+  code = param_read_long(plist, "Pins", &vlong);
+  if (code < 0) return code;
+  if (code == 0) pprt->integer[CFG_PINS] = vlong / 8;
+
+  code = param_read_long(plist, "MinimalUnit", &vlong);
+  if (code < 0) return code;
+  if (code == 0) pprt->integer[CFG_MINIMAL_UNIT] = vlong;
+
+  code = param_read_long(plist, "MaximalUnit", &vlong);
+  if (code < 0) return code;
+  if (code == 0) pprt->integer[CFG_MAXIMAL_UNIT] = vlong;
+
+  code = param_read_long(plist, "HDpi", &vlong);
+  if (code < 0) return code;
+  if (code == 0) pddev->dmprt.orig_x_dpi = vlong;
+
+  code = param_read_long(plist, "VDpi", &vlong);
+  if (code < 0) return code;
+  if (code == 0) pddev->dmprt.orig_y_dpi = vlong;
+
+  code = param_read_long(plist, "Constant", &vlong);
+  if (code < 0) return code;
+  if (code == 0) pprt->integer[CFG_CONSTANT] = vlong;
+  
+  {
+    long tr = pprt->integer[CFG_UPPER_POS] & CFG_NON_TRANSPOSE_BIT;
+    long rv = pprt->integer[CFG_UPPER_POS] & CFG_REVERSE_BIT;
+    long nm = pprt->integer[CFG_UPPER_POS] & CFG_NON_MOVING;
+    param_read_bool(plist,"Transpose", &vbool);
+    if (code < 0) return code;
+    if (code == 0) tr = vbool ? 0 : CFG_NON_TRANSPOSE_BIT;
+    param_read_bool(plist,"Reverse", &vbool);
+    if (code < 0) return code;
+    if (code == 0) rv = vbool ? CFG_REVERSE_BIT : 0;
+    param_read_bool(plist,"NonMoving", &vbool);
+    if (code < 0) return code;
+    if (code == 0) nm = vbool ? CFG_NON_MOVING : 0;
+    pprt->integer[CFG_UPPER_POS] = tr | rv | nm;
+  }
+
+  code = gdev_dmprt_put_prt_code_param(plist, pprt, "BitImageMode",
+				       CFG_BIT_IMAGE_MODE);
+  if (code < 0) return code;
+  code = gdev_dmprt_put_prt_code_param(plist, pprt, "SendBitImage",
+				       CFG_SEND_BIT_IMAGE);
+  if (code < 0) return code;
+  code = gdev_dmprt_put_prt_code_param(plist, pprt, "BitRowHeader",
+				       CFG_BIT_ROW_HEADER);
+  if (code < 0) return code;
+  code = gdev_dmprt_put_prt_code_param(plist, pprt, "AfterBitImage",
+				       CFG_AFTER_BIT_IMAGE);
+  if (code < 0) return code;
+  code = gdev_dmprt_put_prt_code_param(plist, pprt, "LineFeed",
+				       CFG_LINE_FEED);
+  if (code < 0) return code;
+  code = gdev_dmprt_put_prt_code_param(plist, pprt, "FormFeed",
+				       CFG_FORM_FEED);
+  if (code < 0) return code;
+  code = gdev_dmprt_put_prt_code_param(plist, pprt, "NormalMode",
+				       CFG_NORMAL_MODE);
+  if (code < 0) return code;
+  code = gdev_dmprt_put_prt_code_param(plist, pprt, "SkipSpaces",
+				       CFG_SKIP_SPACES);
+  if (code < 0) return code;
+
+  code = gdev_dmprt_put_prt_string_param(plist, pprt, "Name",
+					 CFG_NAME);
+  if (code < 0) return code;
+
+  code = param_read_string(plist, "Encoding", &vstr);
+  if (code < 0) return code;
+  if (code == 0) {
+    int i;
+    for (i=0; gdev_dmprt_encode_list[i].name ; i++) {
+      if (strlen(gdev_dmprt_encode_list[i].name) == vstr.size) {
+	if (strncmp(gdev_dmprt_encode_list[i].name,
+		    vstr.data, vstr.size) == 0) {
+	  pprt->integer[CFG_ENCODE] = gdev_dmprt_encode_list[i].no;
+	  break;
+	}
+      }
+    }
+    if (gdev_dmprt_encode_list[i].name == 0)
+      return e_rangecheck;
+  }
+  
+  return code;
+}
+
+private int
+gdev_dmprt_put_prt_code_param(gs_param_list *plist,
+			      dviprt_cfg_t *pprt, const char* name, int idx)
+{
+  gs_param_string vstr;
+  
+  int code = param_read_string(plist, name, &vstr);
+  if (code == 0) {
+    int ccode = gdev_dmprt_check_code_props(vstr.data, vstr.size);
+    byte *pbyte;
+    if (ccode < 0) return e_rangecheck;
+    pbyte = (byte *)malloc(vstr.size+1);
+    if (pbyte == 0) return e_VMerror;
+    memcpy(pbyte, vstr.data, vstr.size);
+    pbyte[vstr.size] = 0;
+    pprt->prtcode[idx] = pbyte;
+    pprt->prtcode_size[idx] = vstr.size;
+    if (code == 0) code = 1;
+  }
+  return code;
+}
+
+private int
+gdev_dmprt_put_prt_string_param(gs_param_list *plist,
+				dviprt_cfg_t *pprt, const char* name, int idx)
+{
+  gs_param_string vstr;
+  
+  int code = param_read_string(plist, name, &vstr);
+  if (code == 0) {
+    byte *pbyte;
+    pbyte = (byte *)malloc(vstr.size+1);
+    if (pbyte == 0) return e_VMerror;
+    memcpy(pbyte, vstr.data, vstr.size);
+    pbyte[vstr.size] = 0;
+    pprt->strings[idx] = pbyte;
+    if (code == 0) code = 1;
+  }
+  return code;
+}
+/* end of internal routines for put_params */
+
+
+/* --- Get initial matrix. --- */
+private void
+gdev_dmprt_get_initial_matrix(gx_device *pdev, gs_matrix *pmat)
+{
+  gx_default_get_initial_matrix(pdev,pmat);
+  pmat->tx += (pddev->dmprt.x_offset - pddev->dmprt.dev_margin[0]);
+  pmat->ty += (pddev->dmprt.y_offset + pddev->dmprt.dev_margin[3]);
+}
+
+/* --- Open printer device. --- */
+private int
+gdev_dmprt_open(gx_device *pdev)
+{
+  int code;
+  dviprt_cfg_t *pcfg;
+  dviprt_print *pprint;
+
+  pprint = &pddev->dmprt.prtinfo;
+  pcfg = &pddev->dmprt.prtcfg;
+  
+  if ((code = gdev_prn_open(pdev)) < 0)
+    return code;
+  pcfg->integer[CFG_DPI] = (int)ppdev->x_pixels_per_inch;
+  pcfg->integer[CFG_Y_DPI] = (int)ppdev->y_pixels_per_inch;
+  code = dviprt_initlibrary(pprint,pcfg,gdev_prn_raster(pdev),pdev->height);
+  if (code < 0) return gdev_dmprt_error_no_dviprt_to_gs(code);
+  code = dviprt_setbuffer(pprint,NULL);
+  if (code < 0) return gdev_dmprt_error_no_dviprt_to_gs(code);
+  
+  return 0;
+}
+
+/* --- Close printer device. --- */
+private int
+gdev_dmprt_close(gx_device *pdev)
+{
+  int code;
+  dviprt_print *pprint;
+  
+  pprint = &pddev->dmprt.prtinfo;
+
+  if (!strchr(pddev->fname,'%')) {
+    code = dviprt_endbitmap(pprint);
+    if (code < 0) return gdev_dmprt_error_no_dviprt_to_gs(code);
+  }
+  if (pddev->dmprt.verbose_f && pddev->PageCount>0) {
+    eprintf2("%s: Total %lu bytes output.\n",
+      pddev->dname,dviprt_getoutputbytes(pprint));
+  }
+  code = dviprt_unsetbuffer(pprint);
+  if (code < 0) return gdev_dmprt_error_no_dviprt_to_gs(code);
+  return gdev_prn_close(pdev);
+}
+
+/* Output the PAGE. */
+private int
+gdev_dmprt_print_page(gx_device_printer *pdev, FILE *prn_stream)
+{
+  int code = 0;
+  dviprt_print *pprint = &pddev->dmprt.prtinfo;
+  int line_size = gdev_prn_raster((gx_device *)pdev);
+  int pins = dviprt_getscanlines(pprint);
+  int i_buf_size = pins * line_size;
+  int lnum = 0;
+  ulong prev_bytes;
+  byte *in;
+  
+  /* get work buffer */
+  in = (byte *)gs_malloc(1, i_buf_size ,"gdev_dmprt_print_page(in)");
+  if ( in == 0 )
+    return e_VMerror;
+  
+  /* Initialize this printer driver */
+  if (pdev->file_is_new) {
+    code = dviprt_setstream(pprint,NULL,prn_stream);
+    if (code < 0) return gdev_dmprt_error_no_dviprt_to_gs(code);
+  }
+  if (pddev->dmprt.verbose_f) {
+    if (pddev->PageCount == 1)
+      eprintf2("%s: %s\n", pddev->dname,  pddev->dmprt.prtcfg.strings[CFG_NAME]);
+    eprintf2("%s: [%ld]",pddev->dname, pddev->PageCount);
+  }
+  prev_bytes = dviprt_getoutputbytes(pprint);
+  code = dviprt_beginpage(pprint);
+  if (code < 0) return gdev_dmprt_error_no_dviprt_to_gs(code);
+  
+  /* Transfer pixels to printer */
+  while ( lnum < pdev->height ) {   
+    int num_lines;
+    
+    num_lines = pdev->height-lnum;
+    if (num_lines > pins)
+      num_lines = pins;
+    
+    code = gdev_prn_copy_scan_lines(pdev,lnum,in,line_size*num_lines);
+    if (code < 0) goto error_ex;
+    
+    lnum += num_lines;
+    if (num_lines < pins) {
+      memset(in+line_size*num_lines,0,line_size*(pins-num_lines));
+    }
+    
+    code = dviprt_outputscanlines(pprint,in);
+    if (code < 0) {
+      code = gdev_dmprt_error_no_dviprt_to_gs(code);
+      goto error_ex;
+    }
+  }
+  
+  /* Eject the page and set printer normal mode. */
+  if (strchr(pdev->fname,'%')) {
+    code = dviprt_endbitmap(pprint);
+    if (code < 0) return gdev_dmprt_error_no_dviprt_to_gs(code);
+  }
+  fflush(pddev->file);
+  if (pddev->dmprt.verbose_f) {
+    eprintf1(" %lu bytes\n",dviprt_getoutputbytes(pprint)-prev_bytes);
+  }
+error_ex:
+  gs_free((char *)in, 1, i_buf_size,"gdev_dmprt_print_page(in)");
+  
+  return code;
+}
+
+
+/************************** Internal Routines **************************/
+
+/************************ Get printer properties. ***********************/
+private int
+gdev_dmprt_check_code_props(byte *str,int len)
+{
+  byte *end = str+len;
+  while (str < end) {
+    byte fmt = *str++;
+    if (fmt & CFG_FMT_BIT) {
+      int s = *str++;
+      str += s;
+      if (str > end) return e_rangecheck;
+      if ((fmt & CFG_FMT_FORMAT_BIT) == CFG_FMT_STRINGS) {
+        s = *str++;
+        str += s;
+        if (str > end) return e_rangecheck;
+      }
+    }
+    else {
+      str += fmt;
+      if (str > end) return e_rangecheck;
+    }
+  }
+  return str == end ? 0 : e_rangecheck;
+}
+
+private void
+gdev_dmprt_init_printer_props(gx_device_dmprt *pdev)
+{
+  dviprt_cfg_t *pprt;
+  int i;
+
+  pprt = &pdev->dmprt.prtcfg;
+  
+  for (i=0;i<CFG_INTEGER_TYPE_COUNT;i++)
+    pprt->integer[i] = 0;
+  for (i=0;i<CFG_STRINGS_TYPE_COUNT;i++)
+    pprt->strings[i] = 0;
+  for (i=0;i<CFG_PRTCODE_TYPE_COUNT;i++) {
+    pprt->prtcode[i] = 0;
+    pprt->prtcode_size[i] = 0;
+  }
+  pdev->dmprt.prtcfg_init_f = 1;
+}
+
+private int
+gdev_dmprt_get_printer_props(gx_device_dmprt *pdev,char *fnamebase)
+{
+  int code;
+  FILE *fp;
+  dviprt_cfg_t cfg;
+  char *fname;
+
+  fname = gs_malloc(256,1,"dviprt_lib_fname");
+  if (fname == NULL) return e_VMerror;
+  
+  fp = gdev_dmprt_dviprt_lib_fopen(fnamebase,fname);
+  if (fp == NULL) {
+    return e_undefinedfilename;
+  }
+  if (fseek(fp,18,0) < 0)
+    return e_ioerror;
+  code = fgetc(fp);
+  fclose(fp);
+  
+  if (code == EOF)
+    code = e_ioerror;
+  else if (code == 0xff) {
+    code = dviprt_readcfg(fname,&cfg,NULL,0,NULL,0);
+  }
+  else {
+    code = dviprt_readsrc(fname,&cfg,NULL,0,NULL,0);
+  }
+  
+  if (code < 0) {
+    code = gdev_dmprt_error_no_dviprt_to_gs(code);
+  }
+  else { /* success */
+    memcpy(&pdev->dmprt.prtcfg,&cfg,sizeof(dviprt_cfg_t));
+    pddev->dmprt.orig_x_dpi = cfg.integer[CFG_DPI];
+    pddev->dmprt.orig_y_dpi =
+      cfg.integer[CFG_Y_DPI] > 0 ? cfg.integer[CFG_Y_DPI] : pddev->dmprt.orig_x_dpi;
+  }
+  
+  gs_free(fname,256,1,"dviprt_lib_fname");
+  
+  return code;
+}
+
+private const char * gp_file_name_concat_string(const char *, unsigned);
+private FILE *
+gdev_dmprt_dviprt_lib_fopen(const char *fnamebase,char *fname)
+{
+  FILE *fp;
+  char *env;
+
+  strcpy(fname,fnamebase);
+  fp = lib_fopen(fname);
+  if (fp == NULL) {
+    env = getenv("TEXCFG");
+    if (env) {
+      strcpy(fname,env);
+      strcat(fname, gp_file_name_concat_string(env,strlen(env)));
+      strcat(fname,fnamebase);
+      fp = fopen(fname,gp_fmode_rb);
+    }
+  }
+  return fp;
+}
+
+/* Misc. */
+private int
+gdev_dmprt_error_no_dviprt_to_gs(int code)
+{
+  switch (code) {
+  case CFG_ERROR_MEMORY:
+    return e_VMerror;
+  case CFG_ERROR_FILE_OPEN:
+  case CFG_ERROR_OUTPUT:
+    return e_ioerror;
+  default:
+    return -1;
+  }
+}
+
+/* Answer the string to be used for combining a directory/device prefix */
+/* with a base file name. The prefix directory/device is examined to    */
+/* determine if a separator is needed and may return an empty string    */
+private const char *
+gp_file_name_concat_string(const char *prefix, unsigned plen)
+{
+    if (plen > 0 && prefix[plen - 1] == '/')
+        return "";
+    return "/";
+}
diff -urN -x .svn espgs-8.15rc2/addons/japanese/gdevespg.c trunk/addons/japanese/gdevespg.c
--- espgs-8.15rc2/addons/japanese/gdevespg.c	1970-01-01 01:00:00.000000000 +0100
+++ trunk/addons/japanese/gdevespg.c	2005-03-14 00:03:52.416759171 +0100
@@ -0,0 +1,301 @@
+/* Copyright (C) 1999 Norihito Ohmori.
+
+   Ghostscript driver for EPSON ESC/Page printer.
+
+   This software is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility
+   to anyone for the consequences of using it or for whether it serves any
+   particular purpose or works at all, unless he says so in writing.  Refer
+   to the GNU General Public License for full details.
+
+   Everyone is granted permission to copy, modify and redistribute
+   this software, but only under the conditions described in the GNU
+   General Public License.  A copy of this license is supposed to have been
+   given to you along with this software so you can know your rights and
+   responsibilities.  It should be in a file named COPYING.  Among other
+   things, the copyright notice and this notice must be preserved on all
+   copies.
+ */
+
+/*$Id$ */
+/* EPSON ESC/Page driver for Ghostscript */
+
+/*
+   Main part of this driver is taked from Hiroshi Narimatsu's
+   Ghostscript driver, epag-3.08.
+   <ftp://ftp.humblesoft.com/pub/epag-3.08.tar.gz>
+ */
+
+#include "gdevlprn.h"
+#include "gdevlips.h"
+
+#define DPI 300
+
+/* The device descriptors */
+private dev_proc_open_device(escpage_open);
+private dev_proc_open_device(lp2000_open);
+private dev_proc_close_device(escpage_close);
+private dev_proc_print_page_copies(escpage_print_page_copies);
+private dev_proc_print_page_copies(lp2000_print_page_copies);
+private dev_proc_image_out(escpage_image_out);
+
+private void escpage_printer_initialize(gx_device_printer * pdev, FILE * fp, int);
+private void escpage_paper_set(gx_device_printer * pdev, FILE * fp);
+
+private gx_device_procs lp2000_prn_procs =
+lprn_procs(lp2000_open, gdev_prn_output_page, gdev_prn_close);
+
+private gx_device_procs escpage_prn_procs =
+lprn_procs(escpage_open, gdev_prn_output_page, escpage_close);
+
+gx_device_lprn far_data gs_lp2000_device =
+lprn_device(gx_device_lprn, lp2000_prn_procs, "lp2000",
+	    DPI, DPI, 0.0, 0.0, 0.0, 0.0, 1,
+	    lp2000_print_page_copies, escpage_image_out);
+
+gx_device_lprn far_data gs_escpage_device =
+lprn_duplex_device(gx_device_lprn, escpage_prn_procs, "escpage",
+		   DPI, DPI, 0.0, 0.0, 0.0, 0.0, 1,
+		   escpage_print_page_copies, escpage_image_out);
+
+#define ppdev ((gx_device_printer *)pdev)
+
+static char *epson_remote_start = "\033\001@EJL \r\n";
+
+/* Open the printer. */
+private int
+escpage_open(gx_device * pdev)
+{
+    int xdpi = pdev->x_pixels_per_inch;
+    int ydpi = pdev->y_pixels_per_inch;
+
+    /* Resolution Check */
+    if (xdpi != ydpi)
+	return_error(gs_error_rangecheck);
+    if (xdpi < 60 || xdpi > 600)
+	return_error(gs_error_rangecheck);
+
+    return gdev_prn_open(pdev);
+}
+
+private int
+lp2000_open(gx_device * pdev)
+{
+    int xdpi = pdev->x_pixels_per_inch;
+    int ydpi = pdev->y_pixels_per_inch;
+
+    /* Resolution Check */
+    if (xdpi != ydpi)
+	return_error(gs_error_rangecheck);
+    if (xdpi < 60 || xdpi > 300)
+	return_error(gs_error_rangecheck);
+
+    return gdev_prn_open(pdev);
+}
+
+private int
+escpage_close(gx_device * pdev)
+{
+    gdev_prn_open_printer(pdev, 1);
+    if (ppdev->Duplex && (pdev->PageCount & 1)) {
+	fprintf(ppdev->file, "%c0dpsE", GS);
+    }
+    fputs(epson_remote_start, ppdev->file);
+    fputs(epson_remote_start, ppdev->file);
+    return gdev_prn_close(pdev);
+}
+
+private int
+escpage_print_page_copies(gx_device_printer * pdev, FILE * fp, int num_coipes)
+{
+    gx_device_lprn *const lprn = (gx_device_lprn *) pdev;
+
+    if (pdev->PageCount == 0) {
+	double xDpi = pdev->x_pixels_per_inch;
+
+	/* Goto REMOTE MODE */
+	fputs(epson_remote_start, fp);
+	fprintf(fp, "@EJL SELECT LANGUAGE=ESC/PAGE\r\n");
+
+	/* RIT (Resolution Improvement Technology) Setting */
+	if (lprn->RITOff)
+	    fprintf(fp, "@EJL SET RI=OFF\r\n");
+	else
+	    fprintf(fp, "@EJL SET RI=ON\r\n");
+
+	/* Resolution Setting */
+	fprintf(fp, "@EJL SET RS=%s\r\n", xDpi > 300 ? "FN" : "QK");
+	fprintf(fp, "@EJL ENTER LANGUAGE=ESC/PAGE\r\n");
+    }
+    return lp2000_print_page_copies(pdev, fp, num_coipes);
+}
+
+private int
+lp2000_print_page_copies(gx_device_printer * pdev, FILE * fp, int num_coipes)
+{
+    gx_device_lprn *const lprn = (gx_device_lprn *) pdev;
+    int code = 0;
+    int bpl = gdev_mem_bytes_per_scan_line(pdev);
+    int maxY = lprn->BlockLine / lprn->nBh * lprn->nBh;
+
+    /* printer initialize */
+    if (pdev->PageCount == 0)
+	escpage_printer_initialize(pdev, fp, num_coipes);
+
+    if (!(lprn->CompBuf = gs_malloc(bpl * 3 / 2 + 1, maxY, "lp2000_print_page_copies(CompBuf)")))
+	return_error(gs_error_VMerror);
+
+    if (lprn->NegativePrint) {
+	fprintf(fp, "%c1dmG", GS);
+	fprintf(fp, "%c0;0;%d;%d;0rG", GS, pdev->width, pdev->height);
+	fprintf(fp, "%c2owE", GS);
+    }
+    code = lprn_print_image(pdev, fp);
+    if (code < 0)
+	return code;
+
+    gs_free(lprn->CompBuf, bpl * 3 / 2 + 1, maxY, "lp2000_print_page_copies(CompBuf)");
+
+    if (pdev->Duplex)
+	fprintf(fp, "%c0dpsE", GS);
+    else
+	fprintf(fp, "\014");	/* eject page */
+    return code;
+}
+
+/* Output data */
+private void
+escpage_image_out(gx_device_printer * pdev, FILE * fp, int x, int y, int width, int height)
+{
+    gx_device_lprn *const lprn = (gx_device_lprn *) pdev;
+    int Len;
+
+    fprintf(fp, "%c%dY%c%dX", GS, y, GS, x);
+
+    Len = lips_mode3format_encode(lprn->TmpBuf, lprn->CompBuf, width / 8 * height);
+
+    fprintf(fp, "%c%d;%d;%d;0bi{I", GS, Len,
+	    width, height);
+    fwrite(lprn->CompBuf, 1, Len, fp);
+
+    if (lprn->ShowBubble) {
+	fprintf(fp, "%c0dmG", GS);
+	fprintf(fp, "%c%d;%d;%d;%d;0rG", GS,
+		x, y, x + width, y + height);
+    }
+}
+
+/* output printer initialize code */
+
+/* ------ Internal routines ------ */
+
+static char can_inits[] =
+{
+    ESC, 'S', ESC, ESC, 'S', 034,
+    ESC, 'z', 0, 0,		/* Go to ESC/Page  */
+    GS, 'r', 'h', 'E',		/* hard reset         */
+    GS, '1', 'm', 'm', 'E',	/* Page Memory Mode (for LP-3000/7000/7000G) */
+    GS, '3', 'b', 'c', 'I',	/* Style of Compression  */
+    GS, '0', ';', '0', 'i', 'u', 'E', /* Paper Feed Unit (Auto) */
+};
+
+private void
+escpage_printer_initialize(gx_device_printer * pdev, FILE * fp, int copies)
+{
+    gx_device_lprn *const lprn = (gx_device_lprn *) pdev;
+    double xDpi, yDpi;
+
+    xDpi = pdev->x_pixels_per_inch;
+    yDpi = pdev->y_pixels_per_inch;
+
+    /* Initialize */
+    fwrite(can_inits, sizeof(can_inits), 1, fp);
+    /* Duplex Setting */
+    if (pdev->Duplex_set > 0) {
+	if (pdev->Duplex) {
+	    fprintf(fp, "%c1sdE", GS);
+	    if (lprn->Tumble == 0)
+		fprintf(fp, "%c0bdE", GS);
+	    else
+		fprintf(fp, "%c1bdE", GS);
+	} else
+	    fprintf(fp, "%c0sdE", GS);
+    }
+    /* Set the Size Unit  */
+    fprintf(fp, "%c0;%4.2fmuE", GS, 72.0 / xDpi);
+    /* Set the Resolution */
+    fprintf(fp, "%c0;%d;%ddrE", GS, (int)(xDpi + 0.5), (int)(yDpi + 0.5));
+    /* Set the Paper Size */
+    escpage_paper_set(pdev, fp);
+    /* Set the desired number of Copies */
+    fprintf(fp, "%c%dcoO", GS, copies < 256 ? copies : 255);
+    /* Set the Position to (0, 0) */
+    fprintf(fp, "%c0;0loE", GS);
+}
+
+typedef struct {
+    int width;			/* paper width (unit: point) */
+    int height;			/* paper height (unit: point) */
+    int escpage;		/* number of papersize in ESC/PAGE */
+} EpagPaperTable;
+
+static EpagPaperTable epagPaperTable[] =
+{
+    {842, 1190, 13},		/* A3 */
+    {595, 842, 14},		/* A4 */
+    {597, 842, 14},		/* A4 (8.3x11.7 inch) */
+    {421, 595, 15},		/* A5 */
+    {297, 421, 16},		/* A6 */
+    {729, 1032, 24},		/* B4 JIS */
+    {516, 729, 25},		/* B5 JIS */
+    {612, 792, 30},		/* Letter */
+    {396, 612, 31},		/* Half Letter */
+    {612, 1008, 32},		/* Legal */
+    {522, 756, 33},		/* Executive */
+    {612, 936, 34},		/* Government Legal */
+    {576, 756, 35},		/* Government Letter */
+    {792, 1224, 36},		/* Ledger */
+    {593, 935, 37},		/* F4 */
+    {284, 419, 38},		/* PostCard */
+    {933, 1369, 72},		/* A3 NOBI */
+    {279, 540, 80},		/* Monarch */
+    {297, 684, 81},		/* Commercial 10 */
+    {312, 624, 90},		/* DL */
+    {459, 649, 91},		/* C5 */
+    {0, 0, -1},			/* Undefined */
+};
+
+private void
+escpage_paper_set(gx_device_printer * pdev, FILE * fp)
+{
+    int width, height, w, h, wp, hp, bLandscape;
+    EpagPaperTable *pt;
+
+    width = pdev->MediaSize[0];
+    height = pdev->MediaSize[1];
+
+    if (width < height) {
+	bLandscape = 0;
+	w = width;
+	h = height;
+	wp = width / 72.0 * pdev->x_pixels_per_inch;
+	hp = height / 72.0 * pdev->y_pixels_per_inch;
+    } else {
+	bLandscape = 1;
+	w = height;
+	h = width;
+	wp = height / 72.0 * pdev->y_pixels_per_inch;
+	hp = width / 72.0 * pdev->x_pixels_per_inch;
+    }
+
+    for (pt = epagPaperTable; pt->escpage > 0; pt++)
+	if (pt->width == w && pt->height == h)
+	    break;
+
+    fprintf(fp, "%c%d", GS, pt->escpage);
+    if (pt->escpage < 0)
+	fprintf(fp, ";%d;%d", wp, hp);
+    fprintf(fp, "psE");
+
+    fprintf(fp, "%c%dpoE", GS, bLandscape);
+}
diff -urN -x .svn espgs-8.15rc2/addons/japanese/gdevnpdl.c trunk/addons/japanese/gdevnpdl.c
--- espgs-8.15rc2/addons/japanese/gdevnpdl.c	1970-01-01 01:00:00.000000000 +0100
+++ trunk/addons/japanese/gdevnpdl.c	2005-03-14 00:03:52.415759203 +0100
@@ -0,0 +1,715 @@
+/* Copyright (C) 1989, 1992, 1993 Aladdin Enterprises.  All rights reserved.
+
+   This file is part of Ghostscript.
+
+   Ghostscript is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility
+   to anyone for the consequences of using it or for whether it serves any
+   particular purpose or works at all, unless he says so in writing.  Refer
+   to the Ghostscript General Public License for full details.
+
+   Everyone is granted permission to copy, modify and redistribute
+   Ghostscript, but only under the conditions described in the Ghostscript
+   General Public License.  A copy of this license is supposed to have been
+   given to you along with Ghostscript so you can know your rights and
+   responsibilities.  It should be in a file named COPYING.  Among other
+   things, the copyright notice and this notice must be preserved on all
+   copies.  */
+
+/* gdevnpdl.c */
+/*
+ * NEC NPDL/NPDL(level 2) language printer driver for Ghostscript.
+ *   Version 1.5
+ *
+ * This driver was designed to work with any NEC NPDL/NPDL(level 2)
+ * language printers such as NEC MultiWriter series.
+ *
+ * Any test reports, comments, suggestions, and bug reports are welcome.
+ * 
+ *  -- Osamu Watanabe <owatanab@ceres.dti.ne.jp>
+ *
+ * $Id$
+ *
+ */
+
+/*
+   Modified by Norihito Ohmori, May 15 1999
+   1. Landscape Support
+   2. PostCard Size Support
+   3. Output Speed UP
+   4. Copy Mode Support (-dNumCopies Option)
+   5. Default Resolution Chage from 400 dpi to 240 dpi
+   6. NegativePrint Support
+ */
+
+/*
+   Modified by Norihito Ohmori, Jul 18 1999
+   1. Envelope 4 and BPostCard Size Support
+   2. Tumble (When Duplex) Support
+   3. Margin size change.
+ */
+
+#include "gdevlprn.h"
+
+/*
+ * Valid values for IMAGE resolutions, that is, X_DPI and Y_DPI, are
+ * 160, 200, 240, and 400 (Mr. Keita Kawabe reported that the 600dpi
+ * printer, MultiWriter 2000X, accepts 600).
+ * These two values must be the same.
+ *
+ * The resolution specified below is the default value.
+ * You can also specify the resolution at runtime with -r option.
+ */
+#define X_DPI 240
+#define Y_DPI 240
+
+/*
+ * Left, bottom, right, and top margins.
+ *
+ * The values defined below are more accurate for my printer,
+ * and it is recommended that you adjust these values suitable to yours.
+ * The commented values are from the PC-PR1000E/4 User's Manual.
+ */
+/* margins of A3 paper */
+#define L_MARGIN_A3 0.20
+#define B_MARGIN_A3 0.24
+#define R_MARGIN_A3 0.20
+#define T_MARGIN_A3 0.20
+/* margins of A4 paper */
+#define L_MARGIN_A4 0.31
+#define B_MARGIN_A4 0.20
+#define R_MARGIN_A4 0.16
+#define T_MARGIN_A4 0.20
+/* margins of A5 paper */
+#define L_MARGIN_A5 0.31
+#define B_MARGIN_A5 0.16
+#define R_MARGIN_A5 0.16
+#define T_MARGIN_A5 0.20
+/* margins of B4 paper */
+#define L_MARGIN_B4 0.31
+#define B_MARGIN_B4 0.24
+#define R_MARGIN_B4 0.31
+#define T_MARGIN_B4 0.20
+/* margins of B5 paper */
+#define L_MARGIN_B5 0.31
+#define B_MARGIN_B5 0.24
+#define R_MARGIN_B5 0.16
+#define T_MARGIN_B5 0.20
+/* margins of letter size paper */
+#define L_MARGIN_LETTER 0.31
+#define B_MARGIN_LETTER 0.24
+#define R_MARGIN_LETTER 0.20
+#define T_MARGIN_LETTER 0.20
+/* margins of postcard size paper */
+#define L_MARGIN_POSTCARD 0.31
+#define B_MARGIN_POSTCARD 0.12
+#define R_MARGIN_POSTCARD 0.24
+#define T_MARGIN_POSTCARD 0.20
+/* margins of env4 size paper */
+#define L_MARGIN_ENV4 0.20
+#define B_MARGIN_ENV4 0.20
+#define R_MARGIN_ENV4 0.20
+#define T_MARGIN_ENV4 0.20
+
+/* The device descriptors */
+private dev_proc_open_device(npdl_open);
+private dev_proc_open_device(npdl_close);
+private dev_proc_print_page_copies(npdl_print_page_copies);
+private dev_proc_put_params(npdl_put_params);
+private dev_proc_image_out(npdl_image_out);
+
+private gx_device_procs npdl_prn_procs =
+prn_params_procs(npdl_open, gdev_prn_output_page, npdl_close,
+		 lprn_get_params, npdl_put_params);
+
+gx_device_lprn far_data gs_npdl_device =
+lprn_duplex_device(gx_device_lprn, npdl_prn_procs, "npdl",
+	    X_DPI, Y_DPI,	/* default resolution */
+	    0.0, 0.0, 0.0, 0.0,	/* margins */
+	    1, npdl_print_page_copies, npdl_image_out);
+
+
+
+/* ------ internal routines ------ */
+
+/* paper size code */
+/* modified from gdevpcl.h and gdevmjc.c */
+#define PAPER_SIZE_LETTER 2
+#define PAPER_SIZE_A5 25
+#define PAPER_SIZE_A4 26
+#define PAPER_SIZE_A3 27
+#define PAPER_SIZE_B4 30
+#define PAPER_SIZE_B5 31
+#define PAPER_SIZE_POSTCARD 32
+#define PAPER_SIZE_BPOSTCARD 33
+#define PAPER_SIZE_ENV4 34
+
+/* terminating code */
+private char
+terminating[2][64][13] = {{
+/* white */
+"00110101",     "000111",       "0111",         "1000",         /*  0 -  3 */
+"1011",         "1100",         "1110",         "1111",         /*  4 -  7 */
+"10011",        "10100",        "00111",        "01000",        /*  8 - 11 */
+"001000",       "000011",       "110100",       "110101",       /* 12 - 15 */
+"101010",       "101011",       "0100111",      "0001100",      /* 16 - 19 */
+"0001000",      "0010111",      "0000011",      "0000100",      /* 20 - 23 */
+"0101000",      "0101011",      "0010011",      "0100100",      /* 24 - 27 */
+"0011000",      "00000010",     "00000011",     "00011010",     /* 28 - 31 */
+"00011011",     "00010010",     "00010011",     "00010100",     /* 32 - 35 */
+"00010101",     "00010110",     "00010111",     "00101000",     /* 36 - 39 */
+"00101001",     "00101010",     "00101011",     "00101100",     /* 40 - 43 */
+"00101101",     "00000100",     "00000101",     "00001010",     /* 44 - 47 */
+"00001011",     "01010010",     "01010011",     "01010100",     /* 48 - 51 */
+"01010101",     "00100100",     "00100101",     "01011000",     /* 52 - 55 */
+"01011001",     "01011010",     "01011011",     "01001010",     /* 56 - 59 */
+"01001011",     "00110010",     "00110011",     "00110100"      /* 60 - 63 */
+},{
+/* black */
+"0000110111",   "010",          "11",           "10",           /*  0 -  3 */
+"011",          "0011",         "0010",         "00011",        /*  4 -  7 */
+"000101",       "000100",       "0000100",      "0000101",      /*  8 - 11 */
+"0000111",      "00000100",     "00000111",     "000011000",    /* 12 - 15 */
+"0000010111",   "0000011000",   "0000001000",   "00001100111",  /* 16 - 19 */
+"00001101000",  "00001101100",  "00000110111",  "00000101000",  /* 20 - 23 */
+"00000010111",  "00000011000",  "000011001010", "000011001011", /* 24 - 27 */
+"000011001100", "000011001101", "000001101000", "000001101001", /* 28 - 31 */
+"000001101010", "000001101011", "000011010010", "000011010011", /* 32 - 35 */
+"000011010100", "000011010101", "000011010110", "000011010111", /* 36 - 39 */
+"000001101100", "000001101101", "000011011010", "000011011011", /* 40 - 43 */
+"000001010100", "000001010101", "000001010110", "000001010111", /* 44 - 47 */
+"000001100100", "000001100101", "000001010010", "000001010011", /* 48 - 51 */
+"000000100100", "000000110111", "000000111000", "000000100111", /* 52 - 55 */
+"000000101000", "000001011000", "000001011001", "000000101011", /* 56 - 59 */
+"000000101100", "000001011010", "000001100110", "000001100111"  /* 60 - 63 */
+}};
+
+/* make-up code */
+private char
+makeup[2][40][14] = {{
+/* white */
+"11011",        "10010",        "010111",       "0110111",      /*   64- 256 */
+"00110110",     "00110111",     "01100100",     "01100101",     /*  320- 512 */
+"01101000",     "01100111",     "011001100",    "011001101",    /*  576- 768 */
+"011010010",    "011010011",    "011010100",    "011010101",    /*  832-1024 */
+"011010110",    "011010111",    "011011000",    "011011001",    /* 1088-1280 */
+"011011010",    "011011011",    "010011000",    "010011001",    /* 1344-1536 */
+"010011010",    "011000",       "010011011",    "00000001000",  /* 1600-1792 */
+"00000001100",  "00000001101",  "000000010010", "000000010011", /* 1856-2048 */
+"000000010100", "000000010101", "000000010110", "000000010111", /* 2112-2304 */
+"000000011100", "000000011101", "000000011110", "000000011111"  /* 2368-2560 */
+},{
+/* black */
+"0000001111",   "000011001000", "000011001001", "000001011011", /*   64- 256 */
+"000000110011", "000000110100", "000000110101", "0000001101100",/*  320- 512 */
+"0000001101101","0000001001010","0000001001011","0000001001100",/*  576- 768 */
+"0000001001101","0000001110010","0000001110011","0000001110100",/*  832-1024 */
+"0000001110101","0000001110110","0000001110111","0000001010010",/* 1088-1280 */
+"0000001010011","0000001010100","0000001010101","0000001011010",/* 1344-1536 */
+"0000001011011","0000001100100","0000001100101","00000001000",  /* 1600-1792 */
+"00000001100",  "00000001101",  "000000010010", "000000010011", /* 1856-2048 */
+"000000010100", "000000010101", "000000010110", "000000010111", /* 2112-2304 */
+"000000011100", "000000011101", "000000011110", "000000011111"  /* 2368-2560 */
+}};
+
+/* EOL (end of line) code */
+private char
+     eol[] = "000000000001";
+
+/* FILL bit */
+private char
+     fill[] = "0";
+
+#define MAX_RUNLENGTH 2623	/* Max value of makeup(2560) + terminating(63) */
+#define EOL_SIZE 12		/* Size of EOL (end of line) code */
+
+private byte
+        mask[] =
+{0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01};
+
+/* Write MH code to buffer */
+private int
+mh_write_to_buffer(byte * out, int chunk_size, int num_bits, char *code)
+{
+    int code_length, i, p, q;
+
+    for (code_length = 0; code[code_length] != '\0'; code_length++);
+    if (((num_bits + code_length) / 8) >= chunk_size)
+	return 0;
+
+    p = num_bits / 8;
+    q = num_bits % 8;
+    for (i = 0; i < code_length; i++) {
+	/*
+	 * MH compressed data are stored from 2^0 to 2^7,
+	 * whereas uncompressed data are stored from 2^7 to 2^0.
+	 */
+	if (code[i] == '0')
+	    out[p] &= ~(mask[7 - q]);
+	else
+	    out[p] |= mask[7 - q];
+
+	if (q < 7)
+	    q++;
+	else {
+	    p++;
+	    q = 0;
+	}
+    }
+
+    return code_length;
+}
+
+/* Set run-length code */
+private int
+mh_set_runlength(byte * out, int chunk_size, int num_bits, int phase, int count)
+{
+    int n, code_length;
+
+    code_length = 0;
+
+    /* Set makeup code */
+    if (count / 64 > 0) {
+	if ((n = mh_write_to_buffer(out, chunk_size, num_bits,
+				    makeup[phase][(count / 64) - 1])) == 0)
+	    return 0;
+	code_length += n;
+    }
+    /* Set terminating code */
+    if ((n = mh_write_to_buffer(out, chunk_size, num_bits + code_length,
+				terminating[phase][count % 64])) == 0)
+	return 0;
+    code_length += n;
+
+    return code_length;
+}
+
+/* Set EOL (end of line) code */
+private int
+mh_set_eol(byte * out, int chunk_size, int num_bits)
+{
+    return mh_write_to_buffer(out, chunk_size, num_bits, eol);
+}
+
+/* Set RTC (return to control) code and FILL bits */
+private int
+mh_set_rtc(byte * out, int chunk_size, int num_bits)
+{
+    int i, n, code_length, num_fills;
+
+    code_length = 0;
+
+    /* Set FILL bits */
+    num_fills = (EOL_SIZE * 6 + (num_bits % 8)) % 8;
+    if (num_fills != 0) {
+	for (i = 0; i < 8 - num_fills; i++) {
+	    if ((n = mh_write_to_buffer(out, chunk_size, num_bits + code_length,
+					fill)) == 0)
+		return 0;
+	    code_length += n;
+	}
+    }
+    /* Set RTC (that is, six EOL) code */
+    for (i = 0; i < 6; i++) {
+	if ((n = mh_write_to_buffer(out, chunk_size, num_bits + code_length,
+				    eol)) == 0)
+	    return 0;
+	code_length += n;
+    }
+
+    return code_length;
+}
+
+/* Data compression by MH coding */
+private int
+mh_compression(byte * in, byte * out, int line_size, int column_size)
+{
+    int i, p, q, r, n;
+    int num_bits, phase, count;
+    int chunk_size = line_size * column_size;
+    byte src;
+
+    num_bits = 0;
+    for (i = 0; i < column_size; i++) {
+	r = i * line_size;
+
+	/* Synchronization of 1-dot line */
+	if ((n = mh_set_eol(out, chunk_size, num_bits)) == 0)
+	    return 0;
+	num_bits += n;
+
+	/* Data compression of 1-dot line */
+	phase = count = 0;
+	for (p = 0; p < line_size; p++) {
+	    if (phase == 0)
+		src = ~(in[r + p]);
+	    else
+		src = in[r + p];
+	    for (q = 0; q < 8; q++) {
+
+		/*
+		 * If the dot has reversed, write the
+		 * run-length of the continuous dots.
+		 */
+		if (!(src & mask[q])) {
+		    if ((n = mh_set_runlength(out, chunk_size, num_bits,
+					      phase, count)) == 0)
+			return 0;
+		    num_bits += n;
+		    phase = (phase == 0) ? 1 : 0;
+		    count = 1;
+		    src = ~src;
+		}
+		/*
+		 * If the dot is not reversed, check the
+		 * length of this continuous dots,
+		 */
+		else {
+		    if (count < MAX_RUNLENGTH)
+			count++;
+		    /*
+		     * and if the length >= MAX_RUNLENGTH,
+		     * stop and restart counting.
+		     */
+		    else {
+			if ((n = mh_set_runlength(out, chunk_size, num_bits,
+						phase, MAX_RUNLENGTH)) == 0)
+			    return 0;
+			num_bits += n;
+			phase = (phase == 0) ? 1 : 0;
+			if ((n = mh_set_runlength(out, chunk_size, num_bits,
+						  phase, 0)) == 0)
+			    return 0;
+			num_bits += n;
+			phase = (phase == 0) ? 1 : 0;
+			count = 1;
+		    }
+		}
+	    }
+	}
+
+	/* Write the last run-length of 1-dot line */
+	if ((n = mh_set_runlength(out, chunk_size, num_bits, phase,
+				  count)) == 0)
+	    return 0;
+	num_bits += n;
+    }
+
+    /* RTC (return to control) */
+    if ((n = mh_set_rtc(out, chunk_size, num_bits)) == 0)
+	return 0;
+    num_bits += n;
+
+    return (num_bits / 8);
+}
+
+/* Get the paper size code based on the width and the height. 
+   modified from gdevpcl.c and gdevmjc.c */
+private int
+npdl_get_paper_size(gx_device * dev)
+{
+    float media_height = (dev->MediaSize[0] > dev->MediaSize[1]) ? dev->MediaSize[0] : dev->MediaSize[1];
+
+    return (media_height > 1032 ? PAPER_SIZE_A3 :
+	    media_height > 842 ? PAPER_SIZE_B4 :
+	    media_height > 792 ? PAPER_SIZE_A4 :
+	    media_height > 756 ? PAPER_SIZE_LETTER :
+	    media_height > 729 ? PAPER_SIZE_ENV4 :
+	    media_height > 595 ? PAPER_SIZE_BPOSTCARD :
+	    media_height > 568 ? PAPER_SIZE_B5 :
+	    media_height > 419 ? PAPER_SIZE_A5 :
+	    PAPER_SIZE_POSTCARD);
+}
+
+private int
+npdl_set_page_layout(gx_device * dev)
+{
+    int code;
+    float margins[4];
+
+    /* Change the margins according to the paper size. */
+    switch (npdl_get_paper_size(dev)) {
+	case PAPER_SIZE_A3:
+	    if (dev->MediaSize[0] > dev->MediaSize[1]) {	/* Landscape */
+		margins[0] = L_MARGIN_A3;
+		margins[1] = B_MARGIN_A3;
+		margins[2] = R_MARGIN_A3;
+		margins[3] = T_MARGIN_A3;
+	    } else {		/* Portrait */
+		margins[1] = L_MARGIN_A3;
+		margins[2] = B_MARGIN_A3;
+		margins[3] = R_MARGIN_A3;
+		margins[0] = T_MARGIN_A3;
+	    }
+	    break;
+	case PAPER_SIZE_A5:
+	    if (dev->MediaSize[0] > dev->MediaSize[1]) {	/* Landscape */
+		margins[0] = L_MARGIN_A5;
+		margins[1] = B_MARGIN_A5;
+		margins[2] = R_MARGIN_A5;
+		margins[3] = T_MARGIN_A5;
+	    } else {		/* Portrait */
+		margins[1] = L_MARGIN_A5;
+		margins[2] = B_MARGIN_A5;
+		margins[3] = R_MARGIN_A5;
+		margins[0] = T_MARGIN_A5;
+	    }
+	    break;
+	case PAPER_SIZE_B5:
+	    if (dev->MediaSize[0] > dev->MediaSize[1]) {	/* Landscape */
+		margins[1] = L_MARGIN_B5;
+		margins[2] = B_MARGIN_B5;
+		margins[3] = R_MARGIN_B5;
+		margins[0] = T_MARGIN_B5;
+	    } else {		/* Portrait */
+		margins[0] = L_MARGIN_B5;
+		margins[1] = B_MARGIN_B5;
+		margins[2] = R_MARGIN_B5;
+		margins[3] = T_MARGIN_B5;
+	    }
+	    break;
+	case PAPER_SIZE_LETTER:
+	    if (dev->MediaSize[0] > dev->MediaSize[1]) {	/* Landscape */
+		margins[1] = L_MARGIN_LETTER;
+		margins[2] = B_MARGIN_LETTER;
+		margins[3] = R_MARGIN_LETTER;
+		margins[0] = T_MARGIN_LETTER;
+	    } else {		/* Portrait */
+		margins[0] = L_MARGIN_LETTER;
+		margins[1] = B_MARGIN_LETTER;
+		margins[2] = R_MARGIN_LETTER;
+		margins[3] = T_MARGIN_LETTER;
+	    }
+	    break;
+	case PAPER_SIZE_POSTCARD:
+	    if (dev->MediaSize[0] > dev->MediaSize[1]) {	/* Landscape */
+		margins[1] = L_MARGIN_POSTCARD;
+		margins[2] = B_MARGIN_POSTCARD;
+		margins[3] = R_MARGIN_POSTCARD;
+		margins[0] = T_MARGIN_POSTCARD;
+	    } else {		/* Portrait */
+		margins[0] = L_MARGIN_POSTCARD;
+		margins[1] = B_MARGIN_POSTCARD;
+		margins[2] = R_MARGIN_POSTCARD;
+		margins[3] = T_MARGIN_POSTCARD;
+	    }
+	    break;
+	case PAPER_SIZE_ENV4:
+	case PAPER_SIZE_BPOSTCARD:
+		margins[1] = L_MARGIN_ENV4;
+		margins[2] = B_MARGIN_ENV4;
+		margins[3] = R_MARGIN_ENV4;
+		margins[0] = T_MARGIN_ENV4;
+	    break;
+	default:		/* A4 */
+	    if (dev->MediaSize[0] > dev->MediaSize[1]) {	/* Landscape */
+		margins[1] = L_MARGIN_A4;
+		margins[2] = B_MARGIN_A4;
+		margins[3] = R_MARGIN_A4;
+		margins[0] = T_MARGIN_A4;
+	    } else {		/* Portrait */
+		margins[0] = L_MARGIN_A4;
+		margins[1] = B_MARGIN_A4;
+		margins[2] = R_MARGIN_A4;
+		margins[3] = T_MARGIN_A4;
+	    }
+	    break;
+    }
+    gx_device_set_margins(dev, margins, true);
+    if (dev->is_open) {
+	gdev_prn_close(dev);
+	code = gdev_prn_open(dev);
+	if (code < 0)
+	    return code;
+    }
+    return 0;
+}
+
+/* Open the printer, and set the margins. */
+private int
+npdl_open(gx_device * dev)
+{
+    int xdpi = dev->x_pixels_per_inch;
+    int ydpi = dev->y_pixels_per_inch;
+
+    /* Print Resolution Check */
+    if (xdpi != ydpi)
+	return_error(gs_error_rangecheck);
+    else if (xdpi != 160 && xdpi != 200 && xdpi != 240 &&
+	     xdpi != 400 && xdpi != 600)
+	return_error(gs_error_rangecheck);
+
+    npdl_set_page_layout(dev);
+
+    return gdev_prn_open(dev);
+}
+
+private int
+npdl_close(gx_device *pdev)
+{
+    gx_device_printer *const ppdev = (gx_device_printer *) pdev;
+    gdev_prn_open_printer(pdev, 1);
+    fputs("\033c1", ppdev->file);
+
+    return gdev_prn_close(pdev);
+}
+
+
+private int
+npdl_put_params(gx_device * pdev, gs_param_list * plist)
+{
+    gx_device_lprn *const lprn = (gx_device_lprn *) pdev;
+    int code;
+
+    code = lprn_put_params(pdev, plist);
+    if (code < 0)
+	return code;
+    if (pdev->is_open && !lprn->initialized) {
+	npdl_set_page_layout(pdev);
+    }
+    return 0;
+}
+
+/* Send the page to the printer.  For speed, compress each scan line,
+   since computer-to-printer communication time is often a bottleneck. */
+private int
+npdl_print_page_copies(gx_device_printer * pdev, FILE * prn_stream, int num_copies)
+{
+    gx_device_lprn *const lprn = (gx_device_lprn *) pdev;
+    int line_size = gdev_prn_raster(pdev);
+    int x_dpi = (int)(pdev->x_pixels_per_inch);
+    char paper_command[5];
+    int code;
+    int maxY = lprn->BlockLine / lprn->nBh * lprn->nBh;
+
+    if (!(lprn->CompBuf = gs_malloc(line_size * maxY, sizeof(byte), "npdl_print_page_copies(CompBuf)")))
+	return_error(gs_error_VMerror);
+
+
+	/* Initialize printer */
+    if (pdev->PageCount == 0) {
+      
+      /* Initialize printer */
+      fputs("\033c1", prn_stream);               /* Software Reset */
+      fputs("\034d240.", prn_stream);            /* Page Printer Mode */
+
+
+	/* Check paper size */
+	switch (npdl_get_paper_size((gx_device *) pdev)) {
+	    case PAPER_SIZE_POSTCARD:
+		sprintf(paper_command, "PC");
+		break;
+	    case PAPER_SIZE_A5:
+		sprintf(paper_command, "A5");
+		break;
+	    case PAPER_SIZE_A4:
+		sprintf(paper_command, "A4");
+		break;
+	    case PAPER_SIZE_A3:
+		sprintf(paper_command, "A3");
+		break;
+	    case PAPER_SIZE_B5:
+		sprintf(paper_command, "B5");
+		break;
+	    case PAPER_SIZE_B4:
+		sprintf(paper_command, "B4");
+		break;
+	    case PAPER_SIZE_LETTER:
+		sprintf(paper_command, "LT");
+		break;
+	    case PAPER_SIZE_ENV4:
+		sprintf(paper_command, "ENV4");
+		break;
+	    case PAPER_SIZE_BPOSTCARD:
+		sprintf(paper_command, "UPPC");
+		break;
+	}
+
+	if (lprn->ManualFeed) {
+	fprintf(prn_stream, "\034f%cM0.",
+		(pdev->MediaSize[0] > pdev->MediaSize[1]) ? 'L' : 'P');
+	/* Page Orientation  P: Portrait, L: Landscape */
+	} else {
+	fprintf(prn_stream, "\034f%c%s.",
+		(pdev->MediaSize[0] > pdev->MediaSize[1]) ? 'L' : 'P',
+	/* Page Orientation  P: Portrait, L: Landscape */
+		paper_command);	/* Paper Size */
+	}
+
+	fprintf(prn_stream, "\034<1/%d,i.", x_dpi);	/* Image Resolution */
+
+	/* Duplex Setting */
+	if (pdev->Duplex_set > 0) {
+	    if (pdev->Duplex) {
+		if (lprn->Tumble == 0)
+		  fprintf(prn_stream, "\034'B,,1,0.");
+		else
+		  fprintf(prn_stream, "\034'B,,2,0.");
+	    } else
+	      fprintf(prn_stream, "\034'S,,,0.");
+	}
+    }
+
+    if (num_copies > 99)
+       num_copies = 99;
+    fprintf(prn_stream, "\034x%d.", num_copies);
+
+    lprn->initialized = false;
+
+    if (lprn->NegativePrint) {
+	fprintf(prn_stream, "\034e0,0.");	/* move to (0, 0) */
+	fprintf(prn_stream, "\034Y");	/* goto figure mode */
+	fprintf(prn_stream, "SU1,%d,0;", (int)pdev->x_pixels_per_inch);
+	/* Setting Printer Unit */
+	fprintf(prn_stream, "SG0,0;");	/* select black color */
+	fprintf(prn_stream, "NP;");	/* begin path */
+	fprintf(prn_stream, "PA%d,0,%d,%d,0,%d;",
+		pdev->width, pdev->width, pdev->height, pdev->height);
+	/* draw rectangle */
+	fprintf(prn_stream, "CP");	/* close path */
+	fprintf(prn_stream, "EP;");	/* end path */
+	fprintf(prn_stream, "FL0;");	/* fill path */
+	fprintf(prn_stream, "\034Z");	/* end of figure mode */
+	fprintf(prn_stream, "\034\"R.");	/* `R'eplace Mode */
+    }
+    code = lprn_print_image(pdev, prn_stream);
+    if (code < 0)
+	return code;
+
+
+    /* Form Feed */
+    fputs("\014", prn_stream);
+
+    gs_free(lprn->CompBuf, line_size * maxY, sizeof(byte), "npdl_print_page_copies(CompBuf)");
+    return 0;
+}
+
+/* Output data */
+private void
+npdl_image_out(gx_device_printer * pdev, FILE * prn_stream, int x, int y, int width, int height)
+{
+    gx_device_lprn *const lprn = (gx_device_lprn *) pdev;
+    int num_bytes;
+    int x_dpi = (int)(pdev->x_pixels_per_inch);
+
+    fprintf(prn_stream, "\034e%d,%d.", x, y);
+    /* Data compression */
+    num_bytes = mh_compression(lprn->TmpBuf, lprn->CompBuf, width / 8, height);
+
+    /*
+     * If the compression ratio >= 100%, send uncompressed data
+     */
+    if (num_bytes == 0) {
+	fprintf(prn_stream, "\034i%d,%d,0,1/1,1/1,%d,%d.", width,
+		height, width * height / 8, x_dpi);
+	fwrite(lprn->TmpBuf, 1, width * height / 8, prn_stream);
+    }
+    /*
+     * If the compression ratio < 100%, send compressed data
+     */
+    else {
+	fprintf(prn_stream, "\034i%d,%d,1,1/1,1/1,%d,%d.", width,
+		height, num_bytes, x_dpi);
+	fwrite(lprn->CompBuf, 1, num_bytes, prn_stream);
+    }
+}
diff -urN -x .svn espgs-8.15rc2/addons/japanese/gdevrpdl.c trunk/addons/japanese/gdevrpdl.c
--- espgs-8.15rc2/addons/japanese/gdevrpdl.c	1970-01-01 01:00:00.000000000 +0100
+++ trunk/addons/japanese/gdevrpdl.c	2005-03-14 00:03:52.496756585 +0100
@@ -0,0 +1,296 @@
+/* Copyright (C) 1999, 2000 Norihito Ohmori.
+
+   Ghostscript driver for Ricoh RPDL printer.
+
+   This software is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility
+   to anyone for the consequences of using it or for whether it serves any
+   particular purpose or works at all, unless he says so in writing.  Refer
+   to the GNU General Public License for full details.
+
+   Everyone is granted permission to copy, modify and redistribute
+   this software, but only under the conditions described in the GNU
+   General Public License.  A copy of this license is supposed to have been
+   given to you along with this software so you can know your rights and
+   responsibilities.  It should be in a file named COPYING.  Among other
+   things, the copyright notice and this notice must be preserved on all
+   copies.
+ */
+
+/*$Id$ */
+/* Ricoh RPDL driver for Ghostscript */
+
+#include "gdevlprn.h"
+#include "gdevlips.h"
+
+#define DPI 240
+
+/* The device descriptors */
+private dev_proc_open_device(rpdl_open);
+private dev_proc_close_device(rpdl_close);
+private dev_proc_print_page_copies(rpdl_print_page_copies);
+private dev_proc_image_out(rpdl_image_out);
+private void rpdl_printer_initialize(gx_device_printer * pdev, FILE * prn_stream, int num_copies);
+private void rpdl_paper_set(gx_device_printer * pdev, FILE * prn_stream);
+
+private gx_device_procs rpdl_prn_procs =
+lprn_procs(rpdl_open, gdev_prn_output_page, rpdl_close);
+
+gx_device_lprn far_data gs_rpdl_device =
+lprn_device(gx_device_lprn, rpdl_prn_procs, "rpdl",
+	    DPI, DPI, 0.0, 0.0, 0.0, 0.0, 1,
+	    rpdl_print_page_copies, rpdl_image_out);
+
+#define ppdev ((gx_device_printer *)pdev)
+
+/* Open the printer. */
+private int
+rpdl_open(gx_device * pdev)
+{
+    int xdpi = pdev->x_pixels_per_inch;
+    int ydpi = pdev->y_pixels_per_inch;
+
+    /* Resolution Check */
+    if (xdpi != ydpi)
+	return_error(gs_error_rangecheck);
+    if (xdpi != 240 && xdpi != 400 && xdpi != 600)
+	return_error(gs_error_rangecheck);
+
+    return gdev_prn_open(pdev);
+}
+
+private int
+rpdl_close(gx_device * pdev)
+{
+    gdev_prn_open_printer(pdev, 1);
+    if (ppdev->Duplex && (pdev->PageCount & 1)) {
+	fprintf(ppdev->file, "\014"); /* Form Feed */
+    }
+    return gdev_prn_close(pdev);
+}
+
+private int
+rpdl_print_page_copies(gx_device_printer * pdev, FILE * prn_stream, int num_coipes)
+{
+    gx_device_lprn *const lprn = (gx_device_lprn *) pdev;
+    int code = 0;
+    int bpl = gdev_mem_bytes_per_scan_line(pdev);
+    int maxY = lprn->BlockLine / lprn->nBh * lprn->nBh;
+
+    /* printer initialize */
+    if (pdev->PageCount == 0)
+	rpdl_printer_initialize(pdev, prn_stream, num_coipes);
+
+    if (!(lprn->CompBuf = gs_malloc(bpl * 3 / 2 + 1, maxY, "rpdl_print_page_copies(CompBuf)")))
+	return_error(gs_error_VMerror);
+
+    lprn->NegativePrint = false; /* Not Support */
+
+    code = lprn_print_image(pdev, prn_stream);
+    if (code < 0)
+	return code;
+
+    gs_free(lprn->CompBuf, bpl * 3 / 2 + 1, maxY, "rpdl_print_page_copies(CompBuf)");
+
+    fprintf(prn_stream, "\014");	/* Form  Feed */
+
+    return code;
+}
+
+/* Output data */
+private void
+rpdl_image_out(gx_device_printer * pdev, FILE * prn_stream, int x, int y, int width, int height)
+{
+    gx_device_lprn *const lprn = (gx_device_lprn *) pdev;
+    int Len;
+
+    Len = lips_mode3format_encode(lprn->TmpBuf, lprn->CompBuf, width / 8 * height);
+
+    if (Len < width / 8 * height) {
+      if (pdev->x_pixels_per_inch == 240) {
+	/* Unit Size is 1/720 inch */
+	fprintf(prn_stream, "\033\022G3,%d,%d,,4,%d,%d,%d@",
+		width, height, x * 3, y * 3, Len);
+      } else {
+	fprintf(prn_stream, "\033\022G3,%d,%d,,4,%d,%d,%d@",
+		width, height, x, y, Len);
+      }
+      fwrite(lprn->CompBuf, 1, Len, prn_stream);
+    } else { /* compression result is bad. So, raw data is used. */
+      if (pdev->x_pixels_per_inch == 240) {
+	/* Unit Size is 1/720 inch */
+	fprintf(prn_stream, "\033\022G3,%d,%d,,,%d,%d@",
+		width, height, x * 3, y * 3);
+	fwrite(lprn->TmpBuf, 1, width / 8 * height, prn_stream);
+      } else {
+	fprintf(prn_stream, "\033\022G3,%d,%d,,,%d,%d@",
+		width, height, x, y);
+	fwrite(lprn->TmpBuf, 1, width / 8 * height, prn_stream);
+      }
+    }
+}
+
+/* output printer initialize code */
+
+/* ------ Internal routines ------ */
+
+private void
+rpdl_printer_initialize(gx_device_printer * pdev, FILE * prn_stream, int num_copies)
+{
+    gx_device_lprn *const lprn = (gx_device_lprn *) pdev;
+    int xdpi = (int) pdev->x_pixels_per_inch;
+
+    /* Initialize */
+    fprintf(prn_stream, "\033\022!@R00\033 "); /* Change to RPDL Mode */
+    fprintf(prn_stream, "\0334"); /* Graphic Mode kaijyo */
+    fprintf(prn_stream, "\033\022YP,2 "); /* Select RPDL Mode */
+    fprintf(prn_stream, "\033\022YB,2 "); /* Printable Area - Maximum */
+    fprintf(prn_stream, "\033\022YK,1 "); /* Left Margin - 0 mm */
+    fprintf(prn_stream, "\033\022YL,1 "); /* Top Margin - 0 mm */
+    fprintf(prn_stream, "\033\022YM,1 "); /* 100 % */
+    fprintf(prn_stream, "\033\022YQ,2 "); /* Page Length - Maximum */
+    
+    /* Paper Size Selection */
+    rpdl_paper_set(pdev, prn_stream);
+
+    /* Option Setting */
+    /* Duplex Setting */
+    if (pdev->Duplex_set > 0) {
+	if (pdev->Duplex) {
+	    fprintf(prn_stream, "\033\02261,");
+	    if (lprn->Tumble == 0)
+		fprintf(prn_stream, "\033\022YA01,2 ");
+	    else
+		fprintf(prn_stream, "\033\022YA01,1 ");
+	} else
+	    fprintf(prn_stream, "\033\02260,");
+    }
+
+    /* Resolution and Unit Setting */
+    /* Resolution Seting */
+    switch(xdpi) {
+    case 600:
+      fprintf(prn_stream, "\033\022YA04,3 ");
+      break;
+    case 400:
+      fprintf(prn_stream, "\033\022YA04,1 ");
+      break;
+    default: /* 240 dpi */
+      fprintf(prn_stream, "\033\022YA04,2 ");
+      break;
+    }
+
+    /* Unit Setting */
+    /* Graphics Unit */
+    switch(xdpi) {
+    case 600:
+      fprintf(prn_stream, "\033\022YW,3 ");
+      break;
+    case 400:
+      fprintf(prn_stream, "\033\022YW,1 ");
+      break;
+    default: /* 240 dpi */
+      fprintf(prn_stream, "\033\022YW,2 ");
+      break;
+    }
+
+    /* Spacing Unit */
+    switch(xdpi) {
+    case 600:
+      fprintf(prn_stream, "\033\022Q5 ");
+      break;
+    case 400:
+      fprintf(prn_stream, "\033\022Q4 ");
+      break;
+    default: /* 240 dpi */
+      fprintf(prn_stream, "\033\022Q0 ");
+      break;
+    }
+
+    /* Cartecian Unit */
+    switch(xdpi) {
+    case 600:
+      fprintf(prn_stream, "\033\022#4 ");
+      break;
+    case 400:
+      fprintf(prn_stream, "\033\022#2 ");
+      break;
+    }
+
+    /* Paper Setting */
+    if (pdev->MediaSize[0] > pdev->MediaSize[1])
+      fprintf(prn_stream, "\033\022D2 "); /* landscape */
+    else
+      fprintf(prn_stream, "\033\022D1 "); /* portrait */
+
+    /* Number of Copies */
+    fprintf(prn_stream, "\033\022N%d ", num_copies);
+}
+
+private void
+rpdl_paper_set(gx_device_printer * pdev, FILE * prn_stream)
+{
+    int width, height, w, h, wp, hp;
+
+    width = pdev->MediaSize[0];
+    height = pdev->MediaSize[1];
+
+    if (width < height) {
+	w = width;
+	h = height;
+	wp = width / 72.0 * pdev->x_pixels_per_inch;
+	hp = height / 72.0 * pdev->y_pixels_per_inch;
+    } else {
+	w = height;
+	h = width;
+	wp = height / 72.0 * pdev->y_pixels_per_inch;
+	hp = width / 72.0 * pdev->x_pixels_per_inch;
+    }
+
+    if (w == 1684 && h == 2380) /* A1 */
+      fprintf(prn_stream, "\033\02251@A1R\033 ");
+    else if (w == 1190 && h == 1684) { /* A2 */
+      fprintf(prn_stream, "\033\02251@A2R\033 ");
+      fprintf(prn_stream, "\033\02251@A2\033 ");
+    } else if (w == 842 && h == 1190) { /* A3 */
+      fprintf(prn_stream, "\033\02251@A3R\033 ");
+      fprintf(prn_stream, "\033\02251@A3\033 ");
+    } else if (w == 595 && h == 842) { /* A4 */
+      fprintf(prn_stream, "\033\02251@A4R\033 ");
+      fprintf(prn_stream, "\033\02251@A4\033 ");
+    } else if (w == 597 && h == 842) { /* A4 */
+      fprintf(prn_stream, "\033\02251@A4R\033 ");
+      fprintf(prn_stream, "\033\02251@A4\033 ");
+    } else if (w == 421 && h == 595) { /* A5 */
+      fprintf(prn_stream, "\033\02251@A5R\033 ");
+      fprintf(prn_stream, "\033\02251@A5\033 ");
+    } else if (w == 297 && h == 421) { /* A6 */
+      fprintf(prn_stream, "\033\02251@A6R\033 ");
+      fprintf(prn_stream, "\033\02251@A6\033 ");
+    } else if (w == 729 && h == 1032) { /* B4 */
+      fprintf(prn_stream, "\033\02251@B4R\033 ");
+      fprintf(prn_stream, "\033\02251@B4\033 ");
+    } else if (w == 516 && h == 729) { /* B5 */
+      fprintf(prn_stream, "\033\02251@B5R\033 ");
+      fprintf(prn_stream, "\033\02251@B5\033 ");
+    } else if (w == 363 && h == 516) { /* B6 */
+      fprintf(prn_stream, "\033\02251@A6R\033 ");
+      fprintf(prn_stream, "\033\02251@A6\033 ");
+    } else if (w == 612 && h == 792) { /* Letter */
+      fprintf(prn_stream, "\033\02251@LTR\033 ");
+      fprintf(prn_stream, "\033\02251@LT\033 ");
+    } else if (w == 612 && h == 1008) { /* Legal */
+      fprintf(prn_stream, "\033\02251@LGR\033 ");
+      fprintf(prn_stream, "\033\02251@LG\033 ");
+    } else if (w == 396 && h == 612) { /* Half Letter */
+      fprintf(prn_stream, "\033\02251@HLR\033 ");
+      fprintf(prn_stream, "\033\02251@HLT\033 ");
+    } else if (w == 792 && h == 1224) { /* Ledger */
+      fprintf(prn_stream, "\033\02251@DLT\033 ");
+      fprintf(prn_stream, "\033\02251@DLR\033 ");
+    } else { /* Free Size (mm) */
+      fprintf(prn_stream, "\033\022?5%d,%d\033 ",
+	      (int)((w * 25.4) / 72),
+	      (int)((h * 25.4) / 72));
+    }
+}
diff -urN -x .svn espgs-8.15rc2/addons/lips4/gdevl4v.c trunk/addons/lips4/gdevl4v.c
--- espgs-8.15rc2/addons/lips4/gdevl4v.c	2005-02-02 17:35:12.000000000 +0100
+++ trunk/addons/lips4/gdevl4v.c	2005-03-14 00:03:53.994708154 +0100
@@ -225,8 +225,8 @@
     0 /* FontDL */ ,
     -1 /* current_font */ ,
     0 /* count */ ,
-    {},
-    {}
+    {0},
+    {0}
 };
 
 /* Vector device implementation */
@@ -257,6 +257,7 @@
 lips4v_curveto(gx_device_vector * vdev, floatp x0, floatp y0, floatp x1,
 		floatp y1, floatp x2, floatp y2, floatp x3, floatp y3,
 		gx_path_type_t type);
+private int
 lips4v_closepath(gx_device_vector * vdev, floatp x, floatp y, floatp x_start,
 		  floatp y_start, gx_path_type_t type);
 
@@ -1457,6 +1458,13 @@
     if (code < 0)
 	return code;
 
+#if GS_VERSION_MAJOR >= 8
+	if (pdev->bbox_device != NULL) {
+		if (pdev->bbox_device->memory == NULL)
+			pdev->bbox_device->memory = gs_memory_stable(dev->memory);
+	}
+#endif
+
     gdev_vector_init(vdev);
     pdev->first_page = true;
 
@@ -2470,10 +2478,10 @@
     else
 	lputs(s, "}Q1100");
 	sputc(s, LIPS_IS2);	/* End of Image */
-	
-	pdev->MaskReverse = -1;
-	
-	code = gdev_vector_end_image(vdev, (gdev_vector_image_enum_t *)pie,
-					draw_last, pdev->white);
-	return code;
+
+    pdev->MaskReverse = -1;
+
+    code = gdev_vector_end_image(vdev, (gdev_vector_image_enum_t *) pie,
+				 draw_last, pdev->white);
+    return code;
 }
diff -urN -x .svn espgs-8.15rc2/addons/lips4/gdevlips.h trunk/addons/lips4/gdevlips.h
--- espgs-8.15rc2/addons/lips4/gdevlips.h	2005-02-02 17:35:12.000000000 +0100
+++ trunk/addons/lips4/gdevlips.h	2005-03-14 00:03:53.936710029 +0100
@@ -64,8 +64,8 @@
 #define LIPS_HEIGHT_MIN LIPS_POSTCARD_HEIGHT
 #define LIPS_WIDTH_MIN LIPS_POSTCARD_WIDTH
 
-#define	LIPS_HEIGHT_MAX_720	11905	// =420mm
-#define	LIPS_WIDTH_MAX_720	8418	// =294mm
+#define	LIPS_HEIGHT_MAX_720	11905	/* =420mm */
+#define	LIPS_WIDTH_MAX_720	8418	/* =294mm */
 
 #define LIPS_MAX_SIZE 51840	/* 72 inch */
 
@@ -183,13 +183,13 @@
     int prev_paper_width; \
     int prev_paper_height; \
     int prev_num_copies; \
-    int prev_feed_mode;
+    int prev_feed_mode
 
 #define lips4_params_common \
     int prev_duplex_mode;\
     int nup;\
     bool faceup;\
-    char mediaType[LIPS_MEDIACHAR_MAX];
+    char mediaType[LIPS_MEDIACHAR_MAX]
 
 int lips_media_selection(int width, int height);
 int lips_packbits_encode(byte * inBuff, byte * outBuff, int Length);
diff -urN -x .svn espgs-8.15rc2/addons/opvp/gdevopvp.c trunk/addons/opvp/gdevopvp.c
--- espgs-8.15rc2/addons/opvp/gdevopvp.c	2005-02-02 17:35:12.000000000 +0100
+++ trunk/addons/opvp/gdevopvp.c	2005-03-14 00:03:49.520852798 +0100
@@ -70,6 +70,12 @@
 #include	"gsiparam.h"
 #include	"gxxfont.h"
 
+/* added for image gamma correction */
+#include	"gximage.h"
+#include	"gxfmap.h"
+#include	"gxfrac.h"
+#include	"gxcvalue.h"
+
 #include	"opvp_common.h"
 
 #define	ENABLE_SIMPLE_MODE	1
@@ -469,8 +475,26 @@
 static	char			*fastImage = NULL;
 static	FastImageSupportMode	FastImageMode = FastImageDisable;
 static	bool			begin_image = false;
+static	gs_color_space_index	color_index = 0;
+static	byte			palette[3*256];
 static	bool			reverse_image = false;
 
+/* added for image gamma correction */
+typedef struct bbox_image_enum_s {
+							gx_image_enum_common;
+	gs_memory_t				*memory;
+	gs_matrix				matrix;		/* map from image space to device dpace */
+	const	gx_clip_path	*pcpath;
+	gx_image_enum_common_t	*target_info;
+	bool					params_are_const;
+	int						x0, x1;
+	int						y, height;
+} bbox_image_enum;
+
+/* The following is already defined in stdpre.h */
+/*#define	min(a, b) (((a) < (b))? (a) : (b))*/
+
+
 /* ----- Utilities ----- */
 private	int
 opvp_startpage(
@@ -633,7 +657,7 @@
 	char			*locale;
 	iconv_t			cd;
 	char			*buff = NULL;
-	int			ib, ob;
+	size_t			ib, ob;
 	int			complete = false;
 	char			*ibuff, *obuff;
 	char			*ostring = NULL;
@@ -1126,8 +1150,8 @@
 			apiEntry->EndDrawImage(printerContext);
 
 		} else {
-			// ecode = -1;
-			ecode = 0;	// continue...
+			/* ecode = -1;*/
+			ecode = 0;	/* continue... */
 		}
 	}
 
@@ -1298,6 +1322,11 @@
 			dev->color_info.dither_grays = 256;
 			dev->color_info.dither_colors = 256;
 		}
+#if GS_VERSION_MAJOR >= 8
+		dev->procs.get_color_mapping_procs = NULL;
+		dev->procs.get_color_comp_index = NULL;
+		gx_device_fill_in_procs(dev);
+#endif
 	}
 
 	/* call Closerinter as dummy */
@@ -1393,8 +1422,6 @@
 	if (!inkjet) {
 		pdev->v_memory = gs_memory_stable(pdev->memory);
 		/* open output stream */
-		// code = gdev_vector_open_file((gx_device_vector *)dev,
-		//                              /* 16 */4096);
 		code = gdev_vector_open_file_options((gx_device_vector*)dev,
 		           512,
 		           (VECTOR_OPEN_FILE_SEQUENTIAL
@@ -1404,6 +1431,12 @@
 			ecode = code;
 			return ecode;
 		}
+#if GS_VERSION_MAJOR >= 8
+		if (pdev->bbox_device != NULL) {
+			if (pdev->bbox_device->memory == NULL)
+				pdev->bbox_device->memory = gs_memory_stable(dev->memory);
+		}
+#endif
 		outputFD = fileno(pdev->file);
 	} else {
 		/* open printer device */
@@ -1825,6 +1858,14 @@
 	)
 #endif
 {
+	OPVP_ColorSpace		cs;
+	uint				c, m, y, k;
+
+#if !(ENABLE_SIMPLE_MODE)
+	gx_device_opvp		*pdev;
+	int				code;
+#endif
+
 #if GS_VERSION_MAJOR >= 8
 	gx_color_value	r, g, b;	/* added for gs 8.15 */
 	r = prgb[0];
@@ -1833,11 +1874,10 @@
 #endif
 
 #if !(ENABLE_SIMPLE_MODE)
-	gx_device_opvp		*pdev = (gx_device_opvp *)dev;
-	int			code = -1;
+	pdev = (gx_device_opvp *)dev;
+	code = -1;
 #endif
-	OPVP_ColorSpace		cs = OPVP_cspaceStandardRGB;
-	uint			c, m, y, k;
+	cs = OPVP_cspaceStandardRGB;
 
 #if ENABLE_SIMPLE_MODE
 	cs = colorSpace;
@@ -1891,14 +1931,18 @@
 			break;
 		case	OPVP_cspaceDeviceGray :
 #if GS_VERSION_MAJOR >= 8
-			return gx_default_gray_map_rgb_color(dev, prgb);	/* modified for gs 8.15 */
+			{
+				gx_color_value rgb[3];
+				rgb[0] = rgb[1] = rgb[2] = r;
+				return gx_default_gray_map_rgb_color(dev, rgb);
+			}
 #else
 			return gx_default_gray_map_rgb_color(dev, r, g, b);
 #endif
 			break;
 		case	OPVP_cspaceBW :
 #if GS_VERSION_MAJOR >= 8
-			return gx_default_b_w_map_rgb_color(dev, prgb);		/* modified for gs 8.15 */
+			return gx_default_b_w_map_rgb_color(dev, prgb);
 #else
 			return gx_default_b_w_map_rgb_color(dev, r, g, b);
 #endif
@@ -1907,7 +1951,7 @@
 		case	OPVP_cspaceDeviceRGB :
 		default :
 #if GS_VERSION_MAJOR >= 8
-			return gx_default_rgb_map_rgb_color(dev, prgb);		/* modified for gs 8.15 */
+			return gx_default_rgb_map_rgb_color(dev, prgb);
 #else
 			return gx_default_rgb_map_rgb_color(dev, r, g, b);
 #endif
@@ -2614,7 +2658,7 @@
 			opvp_alloc_string(&vectorDriver, buff);
 			break;
 		case	1 :
-			// opvp_alloc_string(&vectorDriver, NULL);
+			/* opvp_alloc_string(&vectorDriver, NULL);*/
 			break;
 		default :
 			ecode = code;
@@ -2632,7 +2676,7 @@
 			opvp_alloc_string(&printerModel, buff);
 			break;
 		case	1 :
-			//opvp_alloc_string(&printerModel, NULL);
+			/*opvp_alloc_string(&printerModel, NULL);*/
 			break;
 		default :
 			ecode = code;
@@ -2650,7 +2694,7 @@
 			opvp_alloc_string(&jobInfo, buff);
 			break;
 		case	1 :
-			//opvp_alloc_string(&jobInfo, NULL);
+			/*opvp_alloc_string(&jobInfo, NULL);*/
 			break;
 		default :
 			ecode = code;
@@ -2668,7 +2712,7 @@
 			opvp_alloc_string(&docInfo, buff);
 			break;
 		case	1 :
-			//opvp_alloc_string(&docInfo, NULL);
+			/*opvp_alloc_string(&docInfo, NULL);*/
 			break;
 		default :
 			ecode = code;
@@ -2699,7 +2743,7 @@
 			}
 			break;
 		case	1 :
-			//opvp_alloc_string(&fastImage, NULL);
+			/*opvp_alloc_string(&fastImage, NULL);*/
 			break;
 		default :
 			ecode = code;
@@ -2952,15 +2996,15 @@
  */
 private	int
 opvp_begin_image(
-	gx_device		*dev,
-const	gs_imager_state		*pis,
-const	gs_image_t		*pim,
-	gs_image_format_t	format,
-const	gs_int_rect		*prect,
-const	gx_drawing_color	*pdcolor,
-const	gx_clip_path		*pcpath,
-	gs_memory_t		*mem,
-	gx_image_enum_common_t	**pinfo
+		gx_device				*dev,
+const	gs_imager_state			*pis,
+const	gs_image_t				*pim,
+		gs_image_format_t		format,
+const	gs_int_rect				*prect,
+const	gx_drawing_color		*pdcolor,
+const	gx_clip_path			*pcpath,
+		gs_memory_t				*mem,
+		gx_image_enum_common_t	**pinfo
 	)
 {
 	gx_device_vector	*vdev =(gx_device_vector *)dev;
@@ -2980,6 +3024,8 @@
 const	gs_color_space		*pcs = pim->ColorSpace;
 	gs_color_space_index	index;
 
+	color_index = 0;
+
 	vinfo = gs_alloc_struct(mem, gdev_vector_image_enum_t,
 				&st_vector_image_enum,
 				"opvp_begin_image");
@@ -2993,7 +3039,7 @@
 		if (code) ecode = code;
 
 		if (!ecode) {
-
+#if 0	/* deleted to speed up 256-color image printing */
 			/* check 256-color image, Thanks to T */
 			/* Unavailiavle color space check */
 			if (!(pim->ImageMask)) {
@@ -3004,10 +3050,29 @@
 					           prect, pdcolor, pcpath,
 					           mem, pinfo);
 			}
-
+#endif
 			/* bits per pixel */
 			for (bits_per_pixel=0, p=0; p < vinfo->num_planes; p++) 
 				bits_per_pixel += vinfo->plane_depths[p];
+
+			/* for indexed color */
+			if (!(pim->ImageMask)) {
+				color_index = gs_color_space_get_index(pcs);
+				if (color_index == gs_color_space_index_Indexed) {
+					if (pcs->params.indexed.lookup.table.size > 3*256) {
+						return gx_default_begin_image(
+							dev, pis, pim, format,
+							prect, pdcolor, pcpath,
+							mem, pinfo);
+					} else {
+						memcpy(palette, pcs->params.indexed.lookup.table.data,\
+						pcs->params.indexed.lookup.table.size);
+						if (bits_per_pixel == 8)
+							bits_per_pixel = 24;
+					}
+				}
+			}
+
 #if ENABLE_AUTO_REVERSE
 			if (bits_per_pixel % 8 == 0) {
 				can_reverse = true;
@@ -3138,7 +3203,6 @@
 	}
 
 	if (draw_image) {
-
 		*pinfo = (gx_image_enum_common_t *)vinfo;
 
 		if (!ecode) {
@@ -3220,29 +3284,38 @@
  */
 private	int
 opvp_image_plane_data(
-	gx_image_enum_common_t	*info,
-const	gx_image_plane_t	*planes,
-	int			height,
-	int			*rows_used
+		gx_image_enum_common_t	*info,
+const	gx_image_plane_t		*planes,
+		int						height,
+		int						*rows_used
 	)
 {
 	gdev_vector_image_enum_t	*vinfo;
-	byte			*buf = NULL;
+	byte		*tmp_buf = NULL;
+	byte		*buf = NULL;
 	int			bits_per_pixel;
-	int			data_bytes;
-	int			raster_length;
+	int			data_bytes, dst_bytes;
+	int			raster_length, dst_length;
 	int			p;
 	int			x;
 	int			d;
 	int			h;
 	int			ecode = 0;
+	int			i, j;
+	byte		*src_ptr, *dst_ptr, *ppalette;
+	byte		*ptr;
+	bbox_image_enum	*pbe;
+	gx_image_enum	*tinfo;
+	const gs_imager_state	*pis;
 
 	vinfo = (gdev_vector_image_enum_t *)info;
 
-	if (!begin_image) return 0;
+	if (!begin_image)
+		return 0;
 
 	for (bits_per_pixel=0, p=0; p < vinfo->num_planes; p++) 
 		bits_per_pixel += vinfo->plane_depths[p];
+	
 	data_bytes = (bits_per_pixel * vinfo->width + 7) >> 3;
 	raster_length = ((data_bytes + 3) >> 2) << 2;
 	buf = calloc(raster_length, height);
@@ -3300,12 +3373,101 @@
 				}
 			}
 		}
+		
+		/* Convert 256 color -> RGB */
+		if(color_index == gs_color_space_index_Indexed) {	/* 256 color */
+			if (vinfo->bits_per_pixel >= 8) {		/* 8bit image */
+				dst_bytes = data_bytes * 3;
+				dst_length = ((dst_bytes + 3) >> 2) << 2;
+				
+				tmp_buf = calloc(dst_length, height);
+				if (tmp_buf) {
+					for (i = 0; i < height; i++) {
+						src_ptr = buf + raster_length * i;
+						dst_ptr = tmp_buf + dst_length * i;
+						for (j = 0; j < data_bytes; j++) {
+							ppalette = palette + src_ptr[j] * 3;
+							dst_ptr[j*3]     = ppalette[0];		/* R */
+							dst_ptr[j*3 + 1] = ppalette[1];		/* G */
+							dst_ptr[j*3 + 2] = ppalette[2];		/* B */
+						}
+					}
+					
+					free (buf);
+					buf = tmp_buf;
+					data_bytes = dst_bytes;
+					raster_length = dst_length;
+					vinfo->bits_per_pixel = 24;
+				}
+			} else {		/* 1bit image */
+				if (palette[0] == 0) {		/* 0/1 reverse is needed */
+					for (i = 0; i < height; i++) {
+						src_ptr = buf + raster_length * i;
+						for (j = 0; j < data_bytes; j++)
+							src_ptr[j] ^= 0xff;
+					}
+				}
+			}
+		}
+		
+		/* Adjust image data gamma */
+		pbe = (bbox_image_enum *)vinfo->bbox_info;
+		tinfo = pbe->target_info;
+		pis = tinfo->pis;
+		
+#if GS_VERSION_MAJOR >= 8
+		if (vinfo->bits_per_pixel == 24) {	/* 24bit RGB color */
+			for (i = 0; i < height; i++) {
+				ptr = buf + raster_length * i;
+				for (j = 0; j < vinfo->width; j++) {
+					ptr[j*3] = min(255, frac2cv(gx_map_color_frac(pis, cv2frac(ptr[j*3]),\
+													effective_transfer[0])));
+					ptr[j*3+1] = min(255, frac2cv(gx_map_color_frac(pis, cv2frac(ptr[j*3+1]),\
+													effective_transfer[1])));
+					ptr[j*3+2] = min(255, frac2cv(gx_map_color_frac(pis, cv2frac(ptr[j*3+2]),\
+													effective_transfer[2])));
+				}
+			}
+		} else if (vinfo->bits_per_pixel == 8) {	/* 8bit Gray image */
+			for (i = 0; i < height; i++) {
+				ptr = buf + raster_length * i;
+				for (j=0; j < vinfo->width; j++) {
+					ptr[j] = min(255, frac2cv(gx_map_color_frac(pis, cv2frac(ptr[j]),\
+													effective_transfer[3])));
+				}
+			}
+		}
+#else
+		if (vinfo->bits_per_pixel == 24) {	/* 24bit RGB color */
+			for (i = 0; i < height; i++) {
+				ptr = buf + raster_length * i;
+				for (j = 0; j < vinfo->width; j++) {
+					ptr[j*3] = min(255, frac2cv(gx_map_color_frac(pis, cv2frac(ptr[j*3]),\
+													effective_transfer.colored.red)));
+					ptr[j*3+1] = min(255, frac2cv(gx_map_color_frac(pis, cv2frac(ptr[j*3+1]),\
+													effective_transfer.colored.green)));
+					ptr[j*3+2] = min(255, frac2cv(gx_map_color_frac(pis, cv2frac(ptr[j*3+2]),\
+													effective_transfer.colored.blue)));
+				}
+			}
+		} else if (vinfo->bits_per_pixel == 8) {	/* 8bit Gray image */
+			for (i = 0; i < height; i++) {
+				ptr = buf + raster_length * i;
+				for (j = 0; j < vinfo->width; j++) {
+					ptr[j] = min(255, frac2cv(gx_map_color_frac(pis, cv2frac(ptr[j]),\
+													effective_transfer.colored.gray)));
+				}
+			}
+		}
+#endif
+
 		/* call TansferDrawImage */
 		if (apiEntry->TransferDrawImage)
 		apiEntry->TransferDrawImage(printerContext,
 		                            raster_length * height,
 		                            (void *)buf);
-		free(buf);
+		if (buf)
+			free(buf);		/* free buffer */
 	}
 
 	vinfo->y += height;
@@ -3320,7 +3482,7 @@
 private	int
 opvp_image_end_image(
 	gx_image_enum_common_t	*info,
-	bool			draw_last
+	bool					draw_last
 	)
 {
 	gx_device		*dev = info->dev;
@@ -4135,7 +4297,7 @@
 	int			code = -1;
 	int			ecode = 0;
 	gs_point		scale;
-	OPVP_Rectangle		rectangles[0];
+	OPVP_Rectangle		rectangles[1];
 	_fPoint			p;
 
 	/* check page-in */
diff -urN -x .svn espgs-8.15rc2/addons/opvp/opvp_common.h trunk/addons/opvp/opvp_common.h
--- espgs-8.15rc2/addons/opvp/opvp_common.h	2005-02-02 17:35:12.000000000 +0100
+++ trunk/addons/opvp/opvp_common.h	2005-03-14 00:03:49.518852863 +0100
@@ -33,20 +33,20 @@
 #define _PDAPI_VERSION_MINOR_	2
 
 /* Return Values */
-#define	OPVP_OK			0	// エラーは -1
+#define	OPVP_OK			0	/* エラーは -1 */
 
 /* Error Codes */
-#define	OPVP_FATALERROR		-101	// ライブラリ内で復旧不可能なエラーが
-					// 発生した
-#define	OPVP_BADREQUEST		-102	// 関数を呼んではいけないところで、
-					// 呼んでしまった
-#define	OPVP_BADCONTEXT		-103	// パラメータのプリコンテキストが不正
-#define	OPVP_NOTSUPPORTED	-104	// パラメータの組み合わせにより、
-					// ドライバもしくはプリンタが
-					// 扱えないリクエストが行なわれた
-#define	OPVP_JOBCANCELED	-105	// 何らかの要因により、ジョブを
-					// キャンセルしている
-#define	OPVP_PARAMERROR		-106	// パラメータの組み合わせが不正
+#define	OPVP_FATALERROR		-101	/* ライブラリ内で復旧不可能なエラーが */
+					/* 発生した */
+#define	OPVP_BADREQUEST		-102	/* 関数を呼んではいけないところで、 */
+					/* 呼んでしまった */
+#define	OPVP_BADCONTEXT		-103	/* パラメータのプリコンテキストが不正 */
+#define	OPVP_NOTSUPPORTED	-104	/* パラメータの組み合わせにより、 */
+					/* ドライバもしくはプリンタが */
+					/* 扱えないリクエストが行なわれた */
+#define	OPVP_JOBCANCELED	-105	/* 何らかの要因により、ジョブを */
+					/* キャンセルしている */
+#define	OPVP_PARAMERROR		-106	/* パラメータの組み合わせが不正 */
 
 /* Info params */
 #define	OPVP_INFO_PREFIX	"updf:"
@@ -80,13 +80,13 @@
 } OPVP_Point;
 
 typedef	struct	_OPVP_Rectangle {
-	OPVP_Point	p0;		// 開始点
-	OPVP_Point	p1;		// 終了点
+	OPVP_Point	p0;		/* 開始点 */
+	OPVP_Point	p1;		/* 終了点 */
 } OPVP_Rectangle;
 
 typedef	struct	_OPVP_RoundRectangle {
-	OPVP_Point	p0;		// 開始点
-	OPVP_Point	p1;		// 終了点
+	OPVP_Point	p0;		/* 開始点 */
+	OPVP_Point	p1;		/* 終了点 */
 	OPVP_Fix	xellipse;
 	OPVP_Fix	yellipse;
 } OPVP_RoundRectangle;
@@ -169,36 +169,36 @@
 	int		height;
 	int		pitch;
 #if (_PDAPI_VERSION_MAJOR_ == 0 && _PDAPI_VERSION_MINOR_ < 2)
-	void		*data;		// pointer to actual data
+	void		*data;		/* pointer to actual data */
 #else
-	char		data[];
+	char		data[1];
 #endif
 } OPVP_BrushData;
 
 typedef	struct	_OPVP_Brush {
 	OPVP_ColorSpace	colorSpace;
-	int		color[4];	// aRGB quadruplet
+	int		color[4];	/* aRGB quadruplet */
 #if (_PDAPI_VERSION_MAJOR_ == 0 && _PDAPI_VERSION_MINOR_ < 2)
-	OPVP_BrushData	*pbrush;	// pointer to brush data
-					// solid brush used, if null
-	int		xorg;		// brush origin
-	int		yorg;		// ignored for SetBgColor
+	OPVP_BrushData	*pbrush;	/* pointer to brush data */
+					/* solid brush used, if null */
+	int		xorg;		/* brush origin */
+	int		yorg;		/* ignored for SetBgColor */
 #else
-	int		xorg;		// brush origin
-	int		yorg;		// ignored for SetBgColor
-	OPVP_BrushData	*pbrush;	// pointer to brush data
-					// solid brush used, if null
+	int		xorg;		/* brush origin */
+	int		yorg;		/* ignored for SetBgColor */
+	OPVP_BrushData	*pbrush;	/* pointer to brush data */
+					/* solid brush used, if null */
 #endif
 } OPVP_Brush;
 
 /* Misc. Flags */
-#define	OPVP_Arc		0	// 円弧
-#define	OPVP_Chord		1	// 弓形
-#define	OPVP_Pie		2	// 扇形
-#define	OPVP_Clockwise		0	// 時計方向
-#define	OPVP_Counterclockwise	1	// 反時計方向
-#define	OPVP_PathClose		0	// Close path upon LinePath
-#define	OPVP_PathOpen		1	// Do not close path upon LinePath
+#define	OPVP_Arc		0	/* 円弧 */
+#define	OPVP_Chord		1	/* 弓形 */
+#define	OPVP_Pie		2	/* 扇形 */
+#define	OPVP_Clockwise		0	/* 時計方向 */
+#define	OPVP_Counterclockwise	1	/* 反時計方向 */
+#define	OPVP_PathClose		0	/* Close path upon LinePath */
+#define	OPVP_PathOpen		1	/* Do not close path upon LinePath */
 
 /* CTM */
 typedef	struct	_OPVP_CTM {
diff -urN -x .svn espgs-8.15rc2/addons/pcl3/eprn/eprnrend.c trunk/addons/pcl3/eprn/eprnrend.c
--- espgs-8.15rc2/addons/pcl3/eprn/eprnrend.c	2005-01-21 01:41:07.000000000 +0100
+++ trunk/addons/pcl3/eprn/eprnrend.c	2005-03-14 00:03:57.208604245 +0100
@@ -163,8 +163,7 @@
 gx_color_index eprn_map_rgb_color_for_RGB(gx_device *device,
   const gx_color_value cv[])
 {
-  gx_color_value red, green, blue;
-  red = cv[0]; green = cv[1]; blue = cv[2];
+  gx_color_value red = cv[0], green = cv[1], blue = cv[2];
   static const gx_color_value half = gx_max_color_value/2;
   gx_color_index value = 0;
   const eprn_Device *dev = (eprn_Device *)device;
@@ -201,8 +200,7 @@
 gx_color_index eprn_map_rgb_color_for_CMY_or_K(gx_device *device,
   const gx_color_value cv[])
 {
-  gx_color_value red, green, blue;
-  red = cv[0]; green = cv[1]; blue = cv[2];
+  gx_color_value red = cv[0], green = cv[1], blue = cv[2];
   static const gx_color_value half = gx_max_color_value/2;
   gx_color_index value = (CYAN_BIT | MAGENTA_BIT | YELLOW_BIT);
   const eprn_Device *dev = (eprn_Device *)device;
@@ -246,8 +244,7 @@
 gx_color_index eprn_map_rgb_color_for_RGB_flex(gx_device *device,
   const gx_color_value cv[])
 {
-  gx_color_value red, green, blue;
-  red = cv[0]; green = cv[1]; blue = cv[2];
+  gx_color_value red = cv[0], green = cv[1], blue = cv[2];
   gx_color_index value = 0;
   gx_color_value step;
   unsigned int level;
@@ -292,8 +289,7 @@
 gx_color_index eprn_map_rgb_color_for_CMY_or_K_flex(gx_device *device,
   const gx_color_value cv[])
 {
-  gx_color_value red, green, blue;
-  red = cv[0]; green = cv[1]; blue = cv[2];
+  gx_color_value red = cv[0], green = cv[1], blue = cv[2];
   const eprn_Device *dev = (eprn_Device *)device;
 
 #ifdef EPRN_TRACE
@@ -332,8 +328,7 @@
 gx_color_index eprn_map_rgb_color_for_RGB_max(gx_device *device,
   const gx_color_value cv[])
 {
-  gx_color_value red, green, blue;
-  red = cv[0]; green = cv[1]; blue = cv[2];
+  gx_color_value red = cv[0], green = cv[1], blue = cv[2];
   gx_color_index value;
 
 #ifdef EPRN_TRACE
@@ -364,8 +359,7 @@
 gx_color_index eprn_map_rgb_color_for_CMY_or_K_max(gx_device *device,
   const gx_color_value cv[])
 {
-  gx_color_value red, green, blue;
-  red = cv[0]; green = cv[1]; blue = cv[2];
+  gx_color_value red = cv[0], green = cv[1], blue = cv[2];
   const eprn_Device *dev = (eprn_Device *)device;
 
 #ifdef EPRN_TRACE
@@ -442,8 +436,7 @@
 gx_color_index eprn_map_cmyk_color(gx_device *device,
   const gx_color_value cv[])
 {
-  gx_color_value cyan, magenta, yellow, black;
-  cyan = cv[0]; magenta = cv[1]; yellow = cv[2]; black = cv[3];
+  gx_color_value cyan = cv[0], magenta = cv[1], yellow = cv[2], black = cv[3];
   gx_color_index value = 0;
   static const gx_color_value threshold = gx_max_color_value/2;
 
@@ -477,8 +470,7 @@
 gx_color_index eprn_map_cmyk_color_flex(gx_device *device,
   const gx_color_value cv[])
 {
-  gx_color_value cyan, magenta, yellow, black;
-  cyan = cv[0]; magenta = cv[1]; yellow = cv[2]; black = cv[3];
+  gx_color_value cyan = cv[0], magenta = cv[1], yellow = cv[2], black = cv[3];
   gx_color_index value = 0;
   gx_color_value step;
   unsigned int level;
@@ -559,8 +551,7 @@
 gx_color_index eprn_map_cmyk_color_max(gx_device *device,
   const gx_color_value cv[])
 {
-  gx_color_value cyan, magenta, yellow, black;
-  cyan = cv[0]; magenta = cv[1]; yellow = cv[2]; black = cv[3];
+  gx_color_value cyan = cv[0], magenta = cv[1], yellow = cv[2], black = cv[3];
   gx_color_index value;
 
 #ifdef EPRN_TRACE

